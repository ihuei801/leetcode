{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"re",
				"request"
			]
		]
	},
	"buffers":
	[
		{
			"file": "Pascal's Triangle II.cpp",
			"settings":
			{
				"buffer_size": 516,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Min Stack.cpp",
			"settings":
			{
				"buffer_size": 574,
				"line_ending": "Unix",
				"name": "class MinStack {"
			}
		},
		{
			"file": "Is Stack Pop Order.cpp",
			"settings":
			{
				"buffer_size": 634,
				"line_ending": "Unix",
				"name": "bool isPopOrder(vector<int>pushOrder, vector<int>p"
			}
		},
		{
			"file": "Copy List with Random Pointer.cpp",
			"settings":
			{
				"buffer_size": 1379,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Binary Tree Preorder Traversal.cpp",
			"settings":
			{
				"buffer_size": 775,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Populating Next Right Pointers in Each Node.cpp",
			"settings":
			{
				"buffer_size": 727,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Reorder List.cpp",
			"settings":
			{
				"buffer_size": 1382,
				"line_ending": "Unix",
				"name": "/**"
			}
		},
		{
			"file": "N-Queens.cpp",
			"settings":
			{
				"buffer_size": 1499,
				"line_ending": "Windows"
			}
		},
		{
			"file": "N-Queens II.cpp",
			"settings":
			{
				"buffer_size": 1001,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Populating Next Right Pointers in Each Node II.cpp",
			"settings":
			{
				"buffer_size": 1328,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Remove Nth Node From End of List.cpp",
			"settings":
			{
				"buffer_size": 682,
				"line_ending": "Unix"
			}
		},
		{
			"file": "First Missing Positive.cpp",
			"settings":
			{
				"buffer_size": 735,
				"line_ending": "Windows"
			}
		},
		{
			"file": "partition.cpp",
			"settings":
			{
				"buffer_size": 430,
				"line_ending": "Unix",
				"name": "void partition(vector<int> &data, int start, int e"
			}
		},
		{
			"contents": "Package Control Messages\n========================\n\nSublimeLinter:\n-------------\n\n  SublimeLinter 3.4.29\n  ---------------------\n  \n  To lower the amount of administration we have to do, the google group has been\n  deprecated. From now on, please follow these steps when seeking support or\n  completing a bug report:\n  \n  - Read the installation and troubleshooting documentation at http://sublimelinter.readthedocs.org/\n  \n  - Search the now deprecated SublimeLinter Google Group at https://groups.google.com/forum/#!forum/sublimelinter\n  \n  - Search the issue tracker at https://github.com/SublimeLinter/SublimeLinter3/issues\n  \n  if you can't find an issue or post for your problem, please submit one in the issue tracker.\n  Be sure to put your OS, SublimeLinter version, and **ENTIRE** debug console output in the issue.\n  \n  \n  NOW GO CREATE SOMETHING AWESOME!!\n",
			"settings":
			{
				"buffer_size": 866,
				"line_ending": "Unix",
				"name": "Package Control Messages",
				"scratch": true
			}
		},
		{
			"file": "Combination Sum.cpp",
			"settings":
			{
				"buffer_size": 1121,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Convert Sorted Array to Binary Search Tree.cpp",
			"settings":
			{
				"buffer_size": 881,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Convert Sorted List to Binary Search Tree.cpp",
			"settings":
			{
				"buffer_size": 1189,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MergeSort.c",
			"settings":
			{
				"buffer_size": 1201,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Rotate List.cpp",
			"settings":
			{
				"buffer_size": 933,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Search in Rotated Sorted Array II.cpp",
			"settings":
			{
				"buffer_size": 1390,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Reverse Integer.cpp",
			"settings":
			{
				"buffer_size": 387,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Reverse Words in a String.cpp",
			"settings":
			{
				"buffer_size": 2201,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "class Solution {\npublic:\n    static bool comp(int a, int b)\n    {\n        string ptr_a, ptr_b;\n        ptr_a = to_string(a);\n        ptr_b = to_string(b);\n        \n        return (ptr_a + ptr_b) > (ptr_b + ptr_a);\n    }\n    string largestNumber(vector<int> &num) {\n        string res;\n        sort(num.begin(), num.end(), comp);\n        for (int i = 0; i < num.size(); i++)\n        {\n            if (num[0] == 0)\n                return \"0\";\n            res += to_string(num[i]);\n        }\n        return res;\n    }\n};",
			"file": "Largest Number.cpp",
			"file_size": 509,
			"file_write_time": 130658602300000000,
			"settings":
			{
				"buffer_size": 517,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Merge Sorted Array.cpp",
			"settings":
			{
				"buffer_size": 526,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Merge Two Sorted Lists.cpp",
			"settings":
			{
				"buffer_size": 1430,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Merge k Sorted Lists.cpp",
			"settings":
			{
				"buffer_size": 1451,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Merge Intervals.cpp",
			"settings":
			{
				"buffer_size": 1283,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 125 files for \"end()\"\n\n/Users/Sean/Sean/Interview/Leetcode/3Sum Closest.cpp:\n    7          int size = num.size();\n    8          \n    9:         sort(num.begin(), num.end());\n   10          \n   11          for (int i = 0; i < size-2;)\n\n/Users/Sean/Sean/Interview/Leetcode/3Sum.cpp:\n   10          int i, j, k;\n   11  \n   12:         sort(num.begin(), num.end());\n   13  \n   14          //note: 1. num.size() is unsigned we need to cast it to singed (for case: num.size() == 0)\n\n/Users/Sean/Sean/Interview/Leetcode/4Sum.cpp:\n    9          int i, j, k, m;\n   10          \n   11:         sort(num.begin(), num.end());\n   12          \n   13          if (num.size() < 4) return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n   11          {\n   12              string s = strs[i];\n   13:             sort(s.begin(), s.end());\n   14              \n   15:             if (anagram.find(s) == anagram.end())\n   16              {\n   17                  anagram[s] = i;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Postorder Traversal.cpp:\n   66          right = postorderTraversal(root->right);\n   67  \n   68:         left.insert(left.end(), right.begin(), right.end());\n   69:         left.insert(left.end(), 1, root->val);\n   70          return left;\n   71      }\n\n/Users/Sean/Sean/Interview/Leetcode/Combination Sum II.cpp:\n   40          int curr_sum = 0;\n   41          \n   42:         sort(candidates.begin(), candidates.end());\n   43          do_combine(candidates, res, solution, target, &curr_sum, 0);\n   44          return res;                \n\n/Users/Sean/Sean/Interview/Leetcode/Combination Sum.cpp:\n   34          int curr_sum = 0;\n   35          \n   36:         sort(candidates.begin(), candidates.end());\n   37          do_combine(candidates, res, solution, target, &curr_sum, 0);\n   38          return res;                \n\n/Users/Sean/Sean/Interview/Leetcode/Insert Interval.cpp:\n   12              int new_interval_exist = 0;\n   13              \n   14:             while (it != intervals.end())\n   15              {\n   16                  if (it->end < newInterval.start)\n   ..\n   55          vector<Interval>::iterator it = intervals.begin();\n   56          \n   57:         while (it != intervals.end())\n   58          {\n   59              if (it->end < newInterval.start)\n\n/Users/Sean/Sean/Interview/Leetcode/leetcode.SearchResults:\n   10  Merge k Sorted Lists.cpp://compare the min node for every list in one iteration\n   11  Two Sum.cpp:    static bool compare(const Node &left, const Node &right)\n   12: Two Sum.cpp:        sort(elements.begin(), elements.end(), compare);\n   13  \n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n\n/Users/Sean/Sean/Interview/Leetcode/Max Points on a Line.cpp:\n   41              }\n   42              map<float, int>::iterator it = slope.begin();\n   43:             for (;it != slope.end(); it++)\n   44              {\n   45                  //count the duplicate number of points[i]\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Intervals.cpp:\n   19          int done = 0;\n   20  \n   21:         while (it != res.end())\n   22          {\n   23              if (new_interval.end < it->start)\n\n/Users/Sean/Sean/Interview/Leetcode/Multiply Strings.cpp:\n    5          int total_digits = num1.size() + num2.size();\n    6          string res;\n    7:         reverse(num1.begin(), num1.end());\n    8:         reverse(num2.begin(), num2.end());\n    9          \n   10          int *remain = (int *)malloc(sizeof(int)*total_digits);\n   ..\n   35              res.push_back(remain[total_digits-1]+'0');\n   36              \n   37:         reverse(res.begin(), res.end());\n   38          if (res[0] == '0')\n   39          {                        \n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   15          for (int i = 0; i < num.size(); i++)\n   16          {\n   17:             if (selected[i] || duplicate.find(num[i]) != duplicate.end())\n   18                  continue;\n   19                  \n\n/Users/Sean/Sean/Interview/Leetcode/Subsets II.cpp:\n   21          \n   22          res.push_back(one_comb);\n   23:         sort(S.begin(), S.end());\n   24          do_combine(S, one_comb, res, 0);\n   25          return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Subsets.cpp:\n   22  \n   23          res.push_back(one_comb);\n   24:         sort(S.begin(), S.end());\n   25          do_combine(S, res, one_comb, 0);\n   26          return res;\n   ..\n   61          vector<int>one_comb;\n   62  \n   63:         sort(S.begin(), S.end());\n   64  \n   65          for (int i = 0; i <= S.size(); i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n   28              {\n   29                  string substr = S.substr(i+j*each_size, each_size);\n   30:                 if (L_table.find(substr) == L_table.end())                        \n   31                      break;\n   32                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   27          }  \n   28          \n   29:         sort(elements.begin(), elements.end(), compare);  \n   30          \n   31          for (int i = 0, j = numbers.size()-1; i < j;)\n   ..\n   72          {\n   73              int diff = target - numbers[i];\n   74:             if (hash_table.find(diff) != hash_table.end() && hash_table[diff] != i)\n   75              {\n   76                  res.push_back(i+1);\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp:\n   18              string str = s.substr(start, i-start+1);\n   19              //if s[0] to s[i] is matched, then do recursive on remaining sub string.\n   20:             if (dict.find(str) != dict.end() && possible[i+1])\n   21              {\n   22                  int pre_size = res.size();\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break.cpp:\n   12              for (int k = 0; k < i ; k++)\n   13              {\n   14:                 hit[i] = hit[k] && (dict.find(s2.substr(k+1, i-k)) != dict.end());\n   15                  if (hit[i]) break;\n   16              }\n\n29 matches across 20 files\n\n\nSearching 127 files for \"listNode\"\n\n/Users/Sean/Sean/Interview/Leetcode/Add Two Numbers.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    .\n   13  public:\n   14  \n   15:     void addNode(ListNode **head, ListNode **tail, int val)\n   16      {\n   17:         ListNode *node = (ListNode *)malloc(sizeof(ListNode));\n   18          node->val = val;\n   19          node->next = NULL;\n   ..\n   28      }\n   29  \n   30:     ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\n   31          \n   32          int num1, num2, carry = 0;\n   33:         ListNode *head = NULL, *tail = NULL;\n   34          \n   35          if (!l1 && !l2) return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted List to Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    .\n   18  class Solution {\n   19  public:\n   20:     TreeNode *buildBST(ListNode *&head, int start, int end)\n   21      {\n   22          TreeNode *left, *right, *parent;\n   ..\n   42      }\n   43      \n   44:     TreeNode *sortedListToBST(ListNode *head) {\n   45          \n   46:         ListNode *p = head;\n   47          int i;\n   48          \n\n/Users/Sean/Sean/Interview/Leetcode/Copy List with Random Pointer.cpp:\n    3  /**\n    4   * Definition for singly-linked list with a random pointer.\n    5:  * struct RandomListNode {\n    6   *     int label;\n    7:  *     RandomListNode *next, *random;\n    8:  *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}\n    9   * };\n   10   */\n   11  class Solution {\n   12  public:\n   13:     RandomListNode *copyRandomList(RandomListNode *head) {\n   14          \n   15:         RandomListNode *curr = head;\n   16:         RandomListNode *dup;\n   17:         RandomListNode *copy;\n   18          \n   19          //generat copied ones\n   20          while (curr)\n   21          {\n   22:             RandomListNode *new_node = new RandomListNode(curr->label);\n   23              new_node->next = curr->next;\n   24              curr->next = new_node;\n\n/Users/Sean/Sean/Interview/Leetcode/Insertion Sort List.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     ListNode *insertionSortList(ListNode *head) {\n   12:         ListNode *curr, *next;\n   13:         ListNode *new_head = NULL, *pivot, *pre_pivot;\n   14          int inserted;\n   15          \n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Linked List Cycle II.cpp:\n    2  /**\n    3   * Definition for singly-linked list.\n    4:  * struct ListNode {\n    5   *     int val;\n    6:  *     ListNode *next;\n    7:  *     ListNode(int x) : val(x), next(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     ListNode *detectCycle(ListNode *head) {\n   13  \n   14:         ListNode *slow, *fast;\n   15          int cycle = 0;\n   16          if (!head || !head->next) return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Linked List Cycle.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     bool hasCycle(ListNode *head) {\n   12:         ListNode *slow, *fast;    \n   13          \n   14          if (!head || !head->next) return false;\n\n/Users/Sean/Sean/Interview/Leetcode/Merge k Sorted Lists.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    .\n   11  class Solution {\n   12  public:\n   13:     ListNode *mergeKLists(vector<ListNode *> &lists) {\n   14          \n   15          int min_index = -1;\n   16:         ListNode *head = NULL, *tail = NULL, *next;\n   17          int all_empty = 1;\n   18          int i;\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Two Sorted Lists.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n   12:         ListNode *head = NULL;\n   13:         ListNode *tail = NULL;\n   14          \n   15          if (!l1) return l2;\n   ..\n   18          while (l1 && l2)\n   19          {\n   20:             ListNode *min_node;\n   21              min_node = (l1->val < l2->val) ? (l1) : (l2);\n   22  \n\n/Users/Sean/Sean/Interview/Leetcode/Partition List.cpp:\n    3  public:        \n    4  \n    5:     ListNode *partition(ListNode *head, int x) {  \n    6          \n    7:         ListNode *curr = head, *pre_curr = NULL, *pre_pivot = NULL, *pivot = NULL;\n    8          \n    9          while (curr)\n   ..\n   24                  if (curr->val < x)\n   25                  {\n   26:                     ListNode *next = curr->next;\n   27                      curr->next = pivot;\n   28                      \n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted List II.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     ListNode *deleteDuplicates(ListNode *head) {\n   12:         ListNode *pivot = NULL, *pre_pivot = NULL, *curr = head;\n   13  \n   14          while (curr)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted List.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     ListNode *deleteDuplicates(ListNode *head) {\n   12:         ListNode *pivot = NULL, *curr = head;\n   13  \n   14          while (curr)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Nth Node From End of List.cpp:\n    1  class Solution {\n    2  public:\n    3:     ListNode *removeNthFromEnd(ListNode *head, int n) {\n    4              \n    5:             ListNode *target = head, *p = head, *pre = NULL;\n    6              \n    7              for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Reorder List.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     void doReorder(ListNode *&head, int num)\n   12      {\n   13:         ListNode *tail, *curr, *next;\n   14  \n   15          if (num == 0)\n   ..\n   41      }\n   42  \n   43:     void reorderList(ListNode *head) {\n   44:         ListNode *curr = head;\n   45          int num = 0;\n   46          while (curr)\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Linked List II.cpp:\n    2  public:\n    3      //reverse the list with num elements\n    4:     int reverseList(ListNode *&head, int num)\n    5      {\n    6:         ListNode *pre= NULL, *next;\n    7:         ListNode *tail = NULL;\n    8  \n    9          if (!head)\n   ..\n   26      }\n   27  \n   28:     ListNode *reverseBetween(ListNode *head, int m, int n) {\n   29:         ListNode *pre = NULL;\n   30:         ListNode *reverse_head = head;\n   31  \n   32          if (!head) return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Rotate List.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    .\n   10  class Solution {\n   11  public:\n   12:     ListNode *rotateRight(ListNode *head, int k) {\n   13          \n   14:         ListNode *pre_target = 0, *target = 0;\n   15:         ListNode *tail = 0, *temp = head;\n   16          int num = 0;\n   17          int i;\n\n/Users/Sean/Sean/Interview/Leetcode/Sort List.cpp:\n    1  /**\n    2   * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    .\n   11  public:\n   12  \n   13:     ListNode *merge(ListNode *first, ListNode *sec)\n   14      {\n   15:         ListNode *head = NULL, *tail = NULL;\n   16:         ListNode *min;\n   17  \n   18          if (!first) return sec;\n   ..\n   44      }\n   45  \n   46:     ListNode *mergeSort(ListNode **head, int num)\n   47      {\n   48:         ListNode *left, *right;\n   49  \n   50          if (num == 0)\n   ..\n   53          if (num == 1)\n   54          {\n   55:             ListNode *old_head = (*head);\n   56              //Important: we should make sure that head will advance. otherwise head will always the first element.\n   57              (*head) = (*head)->next;\n   ..\n   65      }\n   66  \n   67:     ListNode *sortList(ListNode *head) {\n   68  \n   69          int num = 0;\n   70:         ListNode *p = head;\n   71  \n   72          while (p)\n\n/Users/Sean/Sean/Interview/Leetcode/Swap Nodes in Pairs.cpp:\n    2  /**\n    3   * Definition for singly-linked list.\n    4:  * struct ListNode {\n    5   *     int val;\n    6:  *     ListNode *next;\n    7:  *     ListNode(int x) : val(x), next(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     ListNode *swapPairs(ListNode *head) {\n   13:         ListNode *new_head, *next;\n   14  \n   15          if (!head || !head->next)\n   ..\n   27  /**\n   28   * Definition for singly-linked list.\n   29:  * struct ListNode {\n   30   *     int val;\n   31:  *     ListNode *next;\n   32:  *     ListNode(int x) : val(x), next(NULL) {}\n   33   * };\n   34   */\n   35  class Solution {\n   36  public:\n   37:     ListNode *swapPairs(ListNode *head) {\n   38  \n   39:         ListNode *new_head = NULL, *new_tail = NULL;\n   40:         ListNode *curr = head, *pre = NULL, *next;\n   41  \n   42          if (!head || !head->next) return head;\n\n130 matches across 18 files\n\n\nSearching 127 files for \"stack\"\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Postorder Traversal.cpp:\n    9   */\n   10  \n   11: //iterative solution: stack\n   12  class Solution {\n   13  public:\n   14      vector<int> postorderTraversal(TreeNode *root) {\n   15:         stack<TreeNode*> s;\n   16          TreeNode *top_node, *popped = 0;\n   17          vector<int>res;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Preorder Traversal.cpp:\n    9   */\n   10   \n   11: //non recursive solution: stack\n   12  class Solution {\n   13  public:\n   14      vector<int> preorderTraversal(TreeNode *root) {\n   15  \n   16:         stack<TreeNode*> s;\n   17          TreeNode *top_node, *popped = 0;\n   18          vector<int>res;\n\n/Users/Sean/Sean/Interview/Leetcode/Evaluate Reverse Polish Notation.cpp:\n    1  class Solution {\n    2  public:\n    3:     void compute(stack<int> &stk, string comp_type)\n    4      {\n    5          int x, y, res;\n    .\n   22      \n   23      int evalRPN(vector<string> &tokens) {\n   24:         stack<int> stk;\n   25  \n   26          for (int i = 0; i < tokens.size(); i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Implement strStr().cpp:\n    1  class Solution {\n    2  public:\n    3:     char *strStr(char *haystack, char *needle) {\n    4          \n    5          int i, j, k;\n    6          \n    7:         int h_len = strlen(haystack);\n    8          int n_len = strlen(needle);\n    9          \n   10:         if (!haystack || !needle)\n   11              return NULL;\n   12      \n   ..\n   15          \n   16          if (n_len == 0)\n   17:             return haystack;\n   18              \n   19          for (i = 0; i < h_len - (n_len -1); i++)\n   ..\n   21              for (j = 0, k = i; j < n_len; j++, k++)\n   22              {\n   23:                 if (haystack[k] != needle[j])\n   24                      break;\n   25              }\n   26              \n   27              if (j == n_len)\n   28:                 return haystack+i;\n   29          }            \n   30          return NULL;\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Valid Parentheses.cpp:\n    1: //1. use left_index to record the most left index when stack is emtpy.\n    2: //2. push '(' into stack\n    3  //3. pop '(' when input is ')'\n    4: //3.1 when the stack is not empty, the valid length is i - stk.top().\n    5: //3.2 when the stack is empty, the valid length is i - left_index + 1.\n    6: //4. reset the most left index when invalid sequence happens (i.e. stack is empty and input is ')').\n    7  class Solution {\n    8  public:\n    9      int longestValidParentheses(string s) {\n   10          int max_len = 0;\n   11:         stack<int>stk;\n   12          int left_index = -1;\n   13  \n\n/Users/Sean/Sean/Interview/Leetcode/Valid Parentheses.cpp:\n    2  public:\n    3      bool isValid(string s) {\n    4:         stack<char> stk;\n    5  \n    6          for (int i = 0; i < s.size(); i++)\n\n20 matches across 7 files\n\n\nSearching 126 files for \"map\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n    6      vector<string> anagrams(vector<string> &strs) {\n    7          vector<string>res;\n    8:         map<string, int>anagram;\n    9          \n   10          for (int i = 0; i < strs.size(); i++)\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Consecutive Sequence.cpp:\n    3  public:\n    4      int longestConsecutive(vector<int> &num) {\n    5:         map<int, int>hash_table;\n    6          int count;\n    7          int max_count = 0;\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   18          {\n   19:             int value = m_map[key]->value;\n   20              erase_key(key);\n   21              insert_to_head(key, value);\n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n   31              {\n   32                  //remove the least-used one (the last element)\n   33:                 m_map.erase(m_LRU_cache.back().key);\n   34                  m_LRU_cache.pop_back();\n   35              }\n   ..\n   44      //we should use list instead of vector for 2 reasons.\n   45      //1. vector is continuous memory, insert() will reuslt in re-allocate a whole new memory (bad performance)\n   46:     //2. memory re-allocate will cause the original key-value stored in m_map invalid.\n   47:     map<int, list<cache_entry>::iterator>m_map;\n   48      int m_capacity;\n   49      list<cache_entry>m_LRU_cache;\n   ..\n   52      void erase_key(int key)    \n   53      {\n   54:         list<cache_entry>::iterator it = m_map[key];\n   55          m_LRU_cache.erase(it);\n   56      }\n   ..\n   59          cache_entry cache(key, value);\n   60          m_LRU_cache.insert(m_LRU_cache.begin(), cache);\n   61:         m_map[key] = m_LRU_cache.begin();\n   62      }\n   63  };\n\n/Users/Sean/Sean/Interview/Leetcode/Max Points on a Line.cpp:\n   14      int maxPoints(vector<Point> &points) {  \n   15          int max_num = 0;\n   16:         map<float, int>slope;\n   17          \n   18          for (int i = 0; i < points.size(); i++)\n   ..\n   40                  }\n   41              }\n   42:             map<float, int>::iterator it = slope.begin();\n   43              for (;it != slope.end(); it++)\n   44              {\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n    1: //add map<int, int>duplicate to record duplicate num at the same position.\n    2  class Solution {\n    3  public:\n    .\n    5      void do_permute(vector<int> &num, vector<vector<int> > &res, vector<int> &one_sol, vector<int> &selected)\n    6      {\n    7:         map<int, int>duplicate;        \n    8          \n    9          if (one_sol.size() == num.size())\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    4          \n    5          vector<int> res;\n    6:         map<string, int>L_table;        \n    7:         map<string, int>match_count;        \n    8          int L_num = L.size();\n    9          int each_size;\n   ..\n   14          each_size = L[0].size();\n   15          \n   16:         //create map table for each stirng in L\n   17          for (int i = 0; i < L_num; i++)       \n   18              L_table[L[i]]++;\n   19                     \n   20  \n   21:         //create map table for each stirng in L. \n   22          //L[i] may be repeating so we should use addition to record the corresponding count.\n   23          for (i = 0; i < (int)S.size() - (each_size*L_num-1); i++)            \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   54      }\n   55  };\n   56: #else //hash map solution\n   57: #include <map>\n   58  class Solution {\n   59  public:\n   60      vector<int> twoSum(vector<int> &numbers, int target) {\n   61          \n   62:         map<int, int>hash_table;\n   63          int i;\n   64          vector<int>res;\n\n27 matches across 10 files\n\n\nSearching 127 files for \"int a[]\"\n\n/Users/Sean/Sean/Interview/Leetcode/First Missing Positive.cpp:\n    8  class Solution {\n    9  public:\n   10:     int firstMissingPositive(int A[], int n) {\n   11  \n   12          int k;\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41              return findMedian(A, m, B, n, (m + n)/2 + 1);\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Sorted Array.cpp:\n    2  class Solution {\n    3  public:\n    4:     void merge(int A[], int m, int B[], int n) {\n    5          \n    6          int end = m + n - 1;\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array II.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeDuplicates(int A[], int n) {\n    4          int repeat, num = 0;\n    5          for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeDuplicates(int A[], int n) {\n    4          int num = 0;\n    5          for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Element.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeElement(int A[], int n, int elem) {\n    4          \n    5          int num = 0;\n\n/Users/Sean/Sean/Interview/Leetcode/Search for a Range.cpp:\n    4  public:\n    5  \n    6:     int search_index(int A[], int left, int right, int target)\n    7      {\n    8          int mid = (left + right) >> 1;\n    .\n   18      }\n   19  \n   20:     vector<int> searchRange(int A[], int n, int target) {\n   21  \n   22          int index;\n   ..\n   48  class Solution {\n   49  public:\n   50:     vector<int> searchRange(int A[], int n, int target) {\n   51  \n   52          int left = 0, right = n-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array II.cpp:\n    2  public:\n    3  \n    4:     bool search(int A[], int n, int target) {\n    5          \n    6          int left = 0, right = n-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array.cpp:\n    2  public:\n    3  \n    4:     int search(int A[], int n, int target) {\n    5          \n    6          int left = 0, right = n-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search Insert Position.cpp:\n    2  class Solution {\n    3  public:\n    4:     int searchInsert(int A[], int n, int target) {\n    5          int left = 0, right = n - 1;\n    6  \n\n/Users/Sean/Sean/Interview/Leetcode/Single Number II.cpp:\n    9  class Solution {\n   10  public:\n   11:     int singleNumber(int A[], int n) {\n   12          int num = 0;\n   13          \n\n/Users/Sean/Sean/Interview/Leetcode/Single Number.cpp:\n    1  class Solution {\n    2  public:\n    3:     int singleNumber(int A[], int n) {\n    4          int num = 0;\n    5          for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Sort Colors.cpp:\n   13          *b = temp;                                                                                                     \n   14      }                                                                                                                  \n   15:     void sortColors(int A[], int n) {                                                                                  \n   16                                                                                                                         \n   17          int red_idx = 0, blue_idx = n - 1;                                                                             \n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    6  class Solution {                                                                       \n    7  public:                                                                                \n    8:     int trap(int A[], int n) {                                                         \n    9          int total  = 0;                                                                \n   10          int *left  = new int[n];                                                       \n\n17 matches across 14 files\n\n\nSearching 128 files for \"pop_back\"\n\n/Users/Sean/Sean/Interview/Leetcode/Combination Sum II.cpp:\n   26              do_combine(candidates, res, solution, target, curr_sum, i+1);\n   27              *curr_sum -= candidates[i];\n   28:             solution.pop_back();\n   29              \n   30              //difference between Combination Sum: skip the repeating elements\n\n/Users/Sean/Sean/Interview/Leetcode/Combination Sum.cpp:\n   24              do_combine(candidates, res, solution, target, curr_sum, i);\n   25              *curr_sum -= candidates[i];\n   26:             solution.pop_back();\n   27          }\n   28      }\n\n/Users/Sean/Sean/Interview/Leetcode/Combinations.cpp:\n   14              one_sol.push_back(i);\n   15              do_combine(res, one_sol, i+1, end, k);\n   16:             one_sol.pop_back();\n   17          }\n   18          return 0;\n\n/Users/Sean/Sean/Interview/Leetcode/Generate Parentheses.cpp:\n   15              one_sol.push_back('(');\n   16              genParentheses(one_sol, res, n, left_num+1, right_num);\n   17:             one_sol.pop_back();\n   18          }\n   19          \n   ..\n   22              one_sol.push_back(')');\n   23              genParentheses(one_sol, res, n, left_num, right_num+1);\n   24:             one_sol.pop_back();\n   25          }\n   26      }\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   32                  //remove the least-used one (the last element)\n   33                  m_map.erase(m_LRU_cache.back().key);\n   34:                 m_LRU_cache.pop_back();\n   35              }\n   36          }\n\n/Users/Sean/Sean/Interview/Leetcode/N-Queens II.cpp:\n   26                  one_sol.push_back(col);\n   27                  doNQueen(row+1, n, res, one_sol);\n   28:                 one_sol.pop_back();\n   29              }\n   30          }\n\n/Users/Sean/Sean/Interview/Leetcode/N-Queens.cpp:\n   27                  one_sol.push_back(col);\n   28                  doNQueen(row+1, n, res, one_sol);\n   29:                 one_sol.pop_back();\n   30              }\n   31          }\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n   24                  one_sol.push_back(s.substr(start, i-start+1));\n   25                  findPalindrome(s, i+1, one_sol, res);\n   26:                 one_sol.pop_back();\n   27              }\n   28          }\n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n   20              one_sol.push_back(root->val);\n   21              res.push_back(one_sol);\n   22:             one_sol.pop_back();\n   23              return;\n   24          }\n   ..\n   27          findPathSum(root->left, sum-root->val, res, one_sol);\n   28          findPathSum(root->right, sum-root->val, res, one_sol);        \n   29:         one_sol.pop_back();                    \n   30      }\n   31      \n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   22              one_sol.push_back(num[i]);\n   23              do_permute(num, res, one_sol, selected);\n   24:             one_sol.pop_back();\n   25              selected[i] = 0;\n   26          }\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations.cpp:\n   17              one_sol.push_back(num[i]);\n   18              do_permute(num, res, one_sol, selected);\n   19:             one_sol.pop_back();\n   20              selected[i] = 0;\n   21          }\n\n/Users/Sean/Sean/Interview/Leetcode/Subsets II.cpp:\n    9              res.push_back(one_comb);\n   10              do_combine(S, one_comb, res, i+1);\n   11:             one_comb.pop_back();\n   12              \n   13              while (i < S.size() - 1 && S[i] == S[i+1])\n\n/Users/Sean/Sean/Interview/Leetcode/Subsets.cpp:\n   11              res.push_back(one_comb);\n   12              do_combine(S, res, one_comb, i+1);\n   13:             one_comb.pop_back();\n   14          }\n   15      }\n   ..\n   48              {\n   49                  res.push_back(one_comb);\n   50:                 one_comb.pop_back();\n   51                  continue;\n   52              }\n   53              do_combine(S, res, one_comb, num, i+1);\n   54:             one_comb.pop_back();\n   55          }\n   56      }\n\n17 matches across 13 files\n\n\nSearching 129 files for \"stack<\"\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Postorder Traversal.cpp:\n   13  public:\n   14      vector<int> postorderTraversal(TreeNode *root) {\n   15:         stack<TreeNode*> s;\n   16          TreeNode *top_node, *popped = 0;\n   17          vector<int>res;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Preorder Traversal.cpp:\n   14      vector<int> preorderTraversal(TreeNode *root) {\n   15  \n   16:         stack<TreeNode*> s;\n   17          TreeNode *top_node;\n   18          vector<int>res;\n\n/Users/Sean/Sean/Interview/Leetcode/Evaluate Reverse Polish Notation.cpp:\n    1  class Solution {\n    2  public:\n    3:     void compute(stack<int> &stk, string comp_type)\n    4      {\n    5          int x, y, res;\n    .\n   22      \n   23      int evalRPN(vector<string> &tokens) {\n   24:         stack<int> stk;\n   25  \n   26          for (int i = 0; i < tokens.size(); i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Valid Parentheses.cpp:\n    9      int longestValidParentheses(string s) {\n   10          int max_len = 0;\n   11:         stack<int>stk;\n   12          int left_index = -1;\n   13  \n\n/Users/Sean/Sean/Interview/Leetcode/Valid Parentheses.cpp:\n    2  public:\n    3      bool isValid(string s) {\n    4:         stack<char> stk;\n    5  \n    6          for (int i = 0; i < s.size(); i++)\n\n<untitled 712>:\n    1: stack<int>\n    2  map<int, string>\n    3  vector<>\n\n7 matches across 6 files\n\n\nSearching 129 files for \"map\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n    6      vector<string> anagrams(vector<string> &strs) {\n    7          vector<string>res;\n    8:         map<string, int>anagram;\n    9          \n   10          for (int i = 0; i < strs.size(); i++)\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Consecutive Sequence.cpp:\n    3  public:\n    4      int longestConsecutive(vector<int> &num) {\n    5:         map<int, int>hash_table;\n    6          int count;\n    7          int max_count = 0;\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   18          {\n   19:             int value = m_map[key]->value;\n   20              erase_key(key);\n   21              insert_to_head(key, value);\n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n   31              {\n   32                  //remove the least-used one (the last element)\n   33:                 m_map.erase(m_LRU_cache.back().key);\n   34                  m_LRU_cache.pop_back();\n   35              }\n   ..\n   44      //we should use list instead of vector for 2 reasons.\n   45      //1. vector is continuous memory, insert() will reuslt in re-allocate a whole new memory (bad performance)\n   46:     //2. memory re-allocate will cause the original key-value stored in m_map invalid.\n   47:     map<int, list<cache_entry>::iterator>m_map;\n   48      int m_capacity;\n   49      list<cache_entry>m_LRU_cache;\n   ..\n   52      void erase_key(int key)    \n   53      {\n   54:         list<cache_entry>::iterator it = m_map[key];\n   55          m_LRU_cache.erase(it);\n   56      }\n   ..\n   59          cache_entry cache(key, value);\n   60          m_LRU_cache.insert(m_LRU_cache.begin(), cache);\n   61:         m_map[key] = m_LRU_cache.begin();\n   62      }\n   63  };\n\n/Users/Sean/Sean/Interview/Leetcode/Max Points on a Line.cpp:\n   14      int maxPoints(vector<Point> &points) {\n   15          int max_num = 0;\n   16:         map<float, int>slope;\n   17  \n   18          for (int i = 0; i < points.size(); i++)\n   ..\n   40                  }\n   41              }\n   42:             map<float, int>::iterator it = slope.begin();\n   43              for (;it != slope.end(); it++)\n   44              {\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n    1: //add map<int, int>duplicate to record duplicate num at the same position.\n    2  class Solution {\n    3  public:\n    .\n    5      void do_permute(vector<int> &num, vector<vector<int> > &res, vector<int> &one_sol, vector<int> &selected)\n    6      {\n    7:         map<int, int>duplicate;        \n    8          \n    9          if (one_sol.size() == num.size())\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    4          \n    5          vector<int> res;\n    6:         map<string, int>L_table;        \n    7:         map<string, int>match_count;        \n    8          int L_num = L.size();\n    9          int each_size;\n   ..\n   14          each_size = L[0].size();\n   15          \n   16:         //create map table for each stirng in L\n   17          for (int i = 0; i < L_num; i++)       \n   18              L_table[L[i]]++;\n   19                     \n   20  \n   21:         //create map table for each stirng in L. \n   22          //L[i] may be repeating so we should use addition to record the corresponding count.\n   23          for (i = 0; i < (int)S.size() - (each_size*L_num-1); i++)            \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   54      }\n   55  };\n   56: #else //hash map solution\n   57: #include <map>\n   58  class Solution {\n   59  public:\n   60      vector<int> twoSum(vector<int> &numbers, int target) {\n   61          \n   62:         map<int, int>hash_table;\n   63          int i;\n   64          vector<int>res;\n\n<untitled 75>:\n    1  stack<int>\n    2: map<int, string>\n    3  vector<>\n\n28 matches across 11 files\n\n\nSearching 129 files for \"end\"\n\n/Users/Sean/Sean/Interview/Leetcode/3Sum Closest.cpp:\n    7          int size = num.size();\n    8          \n    9:         sort(num.begin(), num.end());\n   10          \n   11          for (int i = 0; i < size-2;)\n\n/Users/Sean/Sean/Interview/Leetcode/3Sum.cpp:\n   10          int i, j, k;\n   11  \n   12:         sort(num.begin(), num.end());\n   13  \n   14          //note: 1. num.size() is unsigned we need to cast it to singed (for case: num.size() == 0)\n\n/Users/Sean/Sean/Interview/Leetcode/4Sum.cpp:\n    9          int i, j, k, m;\n   10          \n   11:         sort(num.begin(), num.end());\n   12          \n   13          if (num.size() < 4) return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n   11          {\n   12              string s = strs[i];\n   13:             sort(s.begin(), s.end());\n   14              \n   15:             if (anagram.find(s) == anagram.end())\n   16              {\n   17                  anagram[s] = i;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Maximum Path Sum.cpp:\n   12  public:\n   13  \n   14:     //1. return value: the max value whose ending point is root. This return value can be used by the parent of current root.\n   15      //2. max_val is current max value.\n   16      int computeMax(TreeNode *root, int &max_val)\n   ..\n   33  \n   34          /*\n   35:             For each node(sub tree), there are two status, one is the path ends at\n   36              this node, the other is the path goes through this node.\n   37              In the first case, the path sum is curr_val+max(left_s,right_s).\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Postorder Traversal.cpp:\n   66          right = postorderTraversal(root->right);\n   67  \n   68:         left.insert(left.end(), right.begin(), right.end());\n   69:         left.insert(left.end(), 1, root->val);\n   70          return left;\n   71      }\n   72  };\n   73: #endif\n\n/Users/Sean/Sean/Interview/Leetcode/Combination Sum II.cpp:\n   40          int curr_sum = 0;\n   41          \n   42:         sort(candidates.begin(), candidates.end());\n   43          do_combine(candidates, res, solution, target, &curr_sum, 0);\n   44          return res;                \n\n/Users/Sean/Sean/Interview/Leetcode/Combination Sum.cpp:\n   34          int curr_sum = 0;\n   35          \n   36:         sort(candidates.begin(), candidates.end());\n   37          do_combine(candidates, res, solution, target, &curr_sum, 0);\n   38          return res;                \n\n/Users/Sean/Sean/Interview/Leetcode/Combinations.cpp:\n    2  public:\n    3  \n    4:     int do_combine(vector<vector<int> > &res, vector<int> &one_sol, int start, int end, int k)\n    5      {\n    6          if (one_sol.size() == k)\n    .\n   10          }\n   11  \n   12:         for (int i = start; i <= end; i++)\n   13          {\n   14              one_sol.push_back(i);\n   15:             do_combine(res, one_sol, i+1, end, k);\n   16              one_sol.pop_back();\n   17          }\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted Array to Binary Search Tree.cpp:\n   12      //note: the first param should use \"&\" (called by reference),\n   13      // if not using \"&\" (i. e. call by value) will cause memory limit exceeding\n   14:     TreeNode *buildBST(vector<int> &num, int start, int end)\n   15      {\n   16          TreeNode *left, *right, *parent;\n   17:         int mid = (start + end) >> 1;\n   18  \n   19:         if (start > end)\n   20              return NULL;\n   21  \n   ..\n   23          parent = new TreeNode(num[mid]);\n   24          parent->left = left;\n   25:         right = buildBST(num, mid+1, end);\n   26          parent->right = right;\n   27          return parent;\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted List to Binary Search Tree.cpp:\n   18  class Solution {\n   19  public:\n   20:     TreeNode *buildBST(ListNode *&head, int start, int end)\n   21      {\n   22          TreeNode *left, *right, *parent;\n   23          int mid;\n   24          \n   25:         if (start > end)\n   26              return NULL;\n   27          \n   28:         mid = (start + end) >> 1;\n   29          \n   30          //build left subtree, after finishing, head will move to mid.\n   ..\n   35          \n   36          head = head->next;\n   37:         right = buildBST(head, mid+1, end);\n   38          \n   39          parent->right = right;\n\n/Users/Sean/Sean/Interview/Leetcode/Count and Say.cpp:\n   15              {\n   16                  sprintf(buf, \"%d\", count);\n   17:                 res.append(buf);\n   18:                 res.append(1, curr_char);\n   19  				count = 1;\n   20  				curr_char = str[j];\n   ..\n   23  \n   24          sprintf(buf, \"%d\", count);\n   25:         res.append(buf);\n   26:         res.append(1, curr_char);\n   27          return res;\n   28      }\n\n/Users/Sean/Sean/Interview/Leetcode/Divide Two Integers.cpp:\n    1  class Solution {\n    2  public:\n    3:     int divide(int dividend, int divisor) {\n    4          //should use long long for the case , \"INT_MIN / -1\"\n    5          long long count = 0;\n    6          long long d;\n    7:         long long temp_dividend = dividend;\n    8          long long temp_divisor  = divisor;\n    9          \n   10:         if (divisor == 0 || dividend == 0)\n   11              return 0;\n   12                  \n   13          //cannot use abs because abs only support int range. abs(INT_MIN) has problem!!\n   14:         if (dividend < 0)            \n   15:             temp_dividend = -(long long)(dividend);\n   16          if (divisor < 0)            \n   17              temp_divisor = -(long long)(divisor);\n   18          \n   19:         while (temp_dividend >= temp_divisor)\n   20          {\n   21              //\"d = temp_divisor;\" cannot write in \"int i = 0, d = temp_divisor\", Otherwise d will be cast to int.\n   22              d = temp_divisor;\n   23:             for (int i = 0; temp_dividend >= d; i++)\n   24              {\n   25:                 temp_dividend -= d;\n   26                  count += 1 << i;\n   27                  d <<= 1;\n   28              }\n   29          }      \n   30:         return ((dividend^divisor) >> 31) ? (-count) : (count);\n   31      }\n   32  };\n\n/Users/Sean/Sean/Interview/Leetcode/Flatten Binary Tree to Linked List.cpp:\n   67      }\n   68  };\n   69: #endif\n\n/Users/Sean/Sean/Interview/Leetcode/Insert Interval.cpp:\n   12              int new_interval_exist = 0;\n   13              \n   14:             while (it != intervals.end())\n   15              {\n   16:                 if (it->end < newInterval.start)\n   17                  {\n   18                      res.push_back(*it);\n   19                  }                    \n   20:                 else if (newInterval.end < it->start)\n   21                  {\n   22                      res.push_back(newInterval);\n   23                      \n   24                      newInterval.start = it->start;\n   25:                     newInterval.end   = it->end;\n   26                  }\n   27                  else\n   28                  {\n   29                      newInterval.start = MIN(newInterval.start, it->start);\n   30:                     newInterval.end   = MAX(newInterval.end, it->end);\n   31                  }\n   32                  it++;\n   ..\n   43   * struct Interval {\n   44   *     int start;\n   45:  *     int end;\n   46:  *     Interval() : start(0), end(0) {}\n   47:  *     Interval(int s, int e) : start(s), end(e) {}\n   48   * };\n   49   */\n   ..\n   55          vector<Interval>::iterator it = intervals.begin();\n   56          \n   57:         while (it != intervals.end())\n   58          {\n   59:             if (it->end < newInterval.start)\n   60                  it++;\n   61:             else if (newInterval.end < it->start)\n   62              {\n   63                  intervals.insert(it, newInterval);\n   ..\n   67              {\n   68                  newInterval.start = MIN(newInterval.start, it->start);\n   69:                 newInterval.end   = MAX(newInterval.end, it->end);\n   70                  it = intervals.erase(it);\n   71              }\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PR:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/leetcode.SearchResults:\n   10  Merge k Sorted Lists.cpp://compare the min node for every list in one iteration\n   11  Two Sum.cpp:    static bool compare(const Node &left, const Node &right)\n   12: Two Sum.cpp:        sort(elements.begin(), elements.end(), compare);\n   13  \n\n/Users/Sean/Sean/Interview/Leetcode/Letter Combinations of a Phone Number.cpp:\n    8          int index;\n    9          \n   10:         //'0' is NULL. That means end of string.\n   11          if (digits.size() == 0 || digits[0] == '0')\n   12          {\n   ..\n   19          for (int i = 0; i < table[index].size(); i++)\n   20          {\n   21:             curr_str.append(1, table[index][i]);\n   22              gen_string(digits.substr(1), curr_str, res);\n   23              curr_str.erase(curr_str.size()-1, 1);\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Common Prefix.cpp:\n   18                      return LCP;\n   19              }\n   20:             LCP.append(1, strs[0][j]);\n   21          }            \n   22          return LCP;\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n\n/Users/Sean/Sean/Interview/Leetcode/Max Points on a Line.cpp:\n   41              }\n   42              map<float, int>::iterator it = slope.begin();\n   43:             for (;it != slope.end(); it++)\n   44              {\n   45                  //count the duplicate number of points[i]\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Intervals.cpp:\n    3   * struct Interval {\n    4   *     int start;\n    5:  *     int end;\n    6:  *     Interval() : start(0), end(0) {}\n    7:  *     Interval(int s, int e) : start(s), end(e) {}\n    8   * };\n    9   */\n   ..\n   19          int done = 0;\n   20  \n   21:         while (it != res.end())\n   22          {\n   23:             if (new_interval.end < it->start)\n   24              {\n   25                  res.insert(it, new_interval);\n   ..\n   27                  break;\n   28              }\n   29:             else if (it->end < new_interval.start)\n   30              {\n   31                  it++;\n   ..\n   35              {\n   36                  new_interval.start = MIN(new_interval.start, it->start);\n   37:                 new_interval.end   = MAX(new_interval.end, it->end);\n   38                  res.erase(it);\n   39              }\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Sorted Array.cpp:\n    4      void merge(int A[], int m, int B[], int n) {\n    5          \n    6:         int end = m + n - 1;\n    7          int i, j;\n    8          \n    .\n   11              if (A[i] >= B[j])\n   12              {\n   13:                 A[end--] = A[i];\n   14                  i--;\n   15              }\n   16              else\n   17              {\n   18:                 A[end--] = B[j];\n   19                  j--;\n   20              }\n   ..\n   22              \n   23          while (j >= 0)\n   24:             A[end--] = B[j--];\n   25      }\n   26  };\n\n/Users/Sean/Sean/Interview/Leetcode/MergeSort.c:\n   21  void merge(int numbers[], int temp[], int left, int mid, int right)\n   22  {\n   23:   int i, left_end, num_elements, tmp_pos;\n   24   \n   25:   left_end = mid - 1;\n   26    tmp_pos = left;\n   27    num_elements = right - left + 1;\n   28   \n   29:   while ((left <= left_end) && (mid <= right))\n   30    {\n   31      if (numbers[left] <= numbers[mid])\n   ..\n   43    }\n   44   \n   45:   while (left <= left_end)\n   46    {\n   47      temp[tmp_pos] = numbers[left];\n\n/Users/Sean/Sean/Interview/Leetcode/Multiply Strings.cpp:\n    5          int total_digits = num1.size() + num2.size();\n    6          string res;\n    7:         reverse(num1.begin(), num1.end());\n    8:         reverse(num2.begin(), num2.end());\n    9          \n   10          int *remain = (int *)malloc(sizeof(int)*total_digits);\n   ..\n   35              res.push_back(remain[total_digits-1]+'0');\n   36              \n   37:         reverse(res.begin(), res.end());\n   38          if (res[0] == '0')\n   39          {                        \n\n/Users/Sean/Sean/Interview/Leetcode/Next Permutation.cpp:\n   11              return;\n   12          \n   13:         //from right to left, find the first descending index            \n   14          for (int i = size - 2; i >= 0; i--)\n   15          {\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n    3  public:\n    4  \n    5:     bool isPalindrome(string s, int start, int end)\n    6      {\n    7:         while (start < end)\n    8          {\n    9:             if (s[start] != s[end])\n   10                  return false;\n   11:             start++, end--;\n   12          }\n   13          return true;\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   15          for (int i = 0; i < num.size(); i++)\n   16          {\n   17:             if (selected[i] || duplicate.find(num[i]) != duplicate.end())\n   18                  continue;\n   19                  \n\n/Users/Sean/Sean/Interview/Leetcode/Remove Nth Node From End of List.cpp:\n    1  class Solution {\n    2  public:\n    3:     ListNode *removeNthFromEnd(ListNode *head, int n) {\n    4              \n    5              ListNode *target = head, *p = head, *pre = NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Words in a String.cpp:\n   29  \n   30      void reverseWords(string &s) {\n   31:         int start = 0, end;\n   32          int write_pos = 0;\n   33  \n   ..\n   45                      i++;\n   46  \n   47:                 end = i-1;\n   48:                 str = s.substr(start, end-start+1);\n   49                  reverseString(str);\n   50  \n\n/Users/Sean/Sean/Interview/Leetcode/Search for a Range.cpp:\n   79      }\n   80  };\n   81: #endif\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array II.cpp:\n   29              else if (A[mid] > A[left])\n   30              {\n   31:                 //consider target in the ascending region or not\n   32                  if (A[left] < target && target < A[mid])\n   33                      right = mid - 1;\n   ..\n   37              else\n   38              {\n   39:                 //consider target in the ascending region or not\n   40                  if (A[mid] < target && target < A[right])\n   41                      left = mid + 1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array.cpp:\n   24              if (A[mid] >= A[left])\n   25              {\n   26:                 //consider target in the ascending region or not\n   27                  if (A[left] < target && target < A[mid])\n   28                      right = mid - 1;\n   ..\n   32              else\n   33              {\n   34:                 //consider target in the ascending region or not\n   35                  if (A[mid] < target && target < A[right])\n   36                      left = mid + 1;\n\n/Users/Sean/Sean/Interview/Leetcode/Single Number II.cpp:\n    1  /*\n    2  Idea: if we look all the last bit of the numbers (assuming all are 32-bit) in the array, there must be 3k+1 or 3k '1's in total\n    3:       depending whether the single number's last bit is one or zero.\n    4        This observation holds for all the rest 31 bits as well.\n    5        Hence, if we sum all the numbers only at certain bit and mod by 3, we can get the corresponding bit the single number.\n\n/Users/Sean/Sean/Interview/Leetcode/Sort Colors.cpp:\n    1  //two-pass solution: First: count number of 0's, 1's, 2's. Second: outupt each number according to their count         \n    2  //one-pass solution: two pointer solution. init red_index = 0, blue_index = n-1,                                       \n    3: //                   Once encountering red, swap it with the left_end. Once encountering blue swap it to the right_end.\n    4  //                                                                                                                     \n    5  class Solution {                                                                                                       \n\n/Users/Sean/Sean/Interview/Leetcode/Sqrt(x).cpp:\n    3      int sqrt(int x) {\n    4          \n    5:         int start = 0, end = (x >> 1) + 1;\n    6          long long mid, mid_square;\n    7          \n    .\n    9              return -1;\n   10          \n   11:         while (start <= end)\n   12          {\n   13:             mid = ((long long )(start + end )) >> 1;\n   14              mid_square = mid*mid;\n   15              \n   ..\n   19                  start = mid + 1;\n   20              else\n   21:                 end = mid - 1;\n   22          }\n   23          \n   24:         return (start+end) >> 1;\n   25      }\n   26  };\n\n/Users/Sean/Sean/Interview/Leetcode/Subsets II.cpp:\n   21          \n   22          res.push_back(one_comb);\n   23:         sort(S.begin(), S.end());\n   24          do_combine(S, one_comb, res, 0);\n   25          return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Subsets.cpp:\n   22  \n   23          res.push_back(one_comb);\n   24:         sort(S.begin(), S.end());\n   25          do_combine(S, res, one_comb, 0);\n   26          return res;\n   ..\n   61          vector<int>one_comb;\n   62  \n   63:         sort(S.begin(), S.end());\n   64  \n   65          for (int i = 0; i <= S.size(); i++)\n   ..\n   69      }\n   70  };\n   71: #endif\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n   28              {\n   29                  string substr = S.substr(i+j*each_size, each_size);\n   30:                 if (L_table.find(substr) == L_table.end())                        \n   31                      break;\n   32                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Swap Nodes in Pairs.cpp:\n   63      }\n   64  };\n   65: #endif\n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   27          }  \n   28          \n   29:         sort(elements.begin(), elements.end(), compare);  \n   30          \n   31          for (int i = 0, j = numbers.size()-1; i < j;)\n   ..\n   72          {\n   73              int diff = target - numbers[i];\n   74:             if (hash_table.find(diff) != hash_table.end() && hash_table[diff] != i)\n   75              {\n   76                  res.push_back(i+1);\n\n/Users/Sean/Sean/Interview/Leetcode/Unique Binary Search Trees II.cpp:\n   11  public:\n   12  \n   13:     int genBST(vector<TreeNode *> &res, int start, int end)\n   14      {\n   15          vector<TreeNode *>left, right;\n   16  \n   17:         if (start > end)\n   18          {\n   19              res.push_back(NULL);\n   ..\n   21          }\n   22  \n   23:         for (int i = start; i <= end; i++)\n   24          {\n   25              left.clear();\n   26              right.clear();\n   27              genBST(left, start, i-1);\n   28:             genBST(right, i+1, end);\n   29              for (int j = 0; j < left.size(); j++)\n   30                  for (int k = 0; k < right.size(); k++)\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Number.cpp:\n   11  \n   12  		//trim space\n   13: 		size_t end_pos = str.find_last_not_of(\" \\t\\n\");\n   14  \n   15: 		if (end_pos != string::npos)\n   16: 			str = str.substr(0, end_pos + 1);\n   17  \n   18  		size_t start_pos = str.find_first_not_of(\" \\t\\n\");\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n    9   */\n   10  \n   11: //When BST is inorder sequence, it shoud be an ascending sequence.\n   12  class Solution {\n   13  public:\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp:\n   18              string str = s.substr(start, i-start+1);\n   19              //if s[0] to s[i] is matched, then do recursive on remaining sub string.\n   20:             if (dict.find(str) != dict.end() && possible[i+1])\n   21              {\n   22                  int pre_size = res.size();\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break.cpp:\n   12              for (int k = 0; k < i ; k++)\n   13              {\n   14:                 hit[i] = hit[k] && (dict.find(s2.substr(k+1, i-k)) != dict.end());\n   15                  if (hit[i]) break;\n   16              }\n\n/Users/Sean/Sean/Interview/Leetcode/Word Search.cpp:\n    6  (2) For each position found where the 1st element lies, recursively do:\n    7             (i) Search the around cell to see if the next element exists. (4 directions: (i-1,j),(i+1,j),(i,j-1),(i,j+1) )\n    8:            (ii) If the word ends, return true.\n    9  (3) Return false if no matching found.\n   10  Note: A mask matrix is needed to store the positions where have already been visited. Details can be found in code.\n\n/Users/Sean/Sean/Interview/Leetcode/ZigZag Conversion.cpp:\n   15          for (int i = 0; i < nRows && i < s.size(); i++)\n   16          {\n   17:             res.append(1, s[i]);\n   18              j = i;\n   19              k = 1;\n   ..\n   34  \n   35                  if (j < s.size())\n   36:                     res.append(1, s[j]);\n   37                  else\n   38                      break;\n\n133 matches across 50 files\n\n\nSearching 130 files for \"map\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n    6      vector<string> anagrams(vector<string> &strs) {\n    7          vector<string>res;\n    8:         map<string, int>anagram;\n    9          \n   10          for (int i = 0; i < strs.size(); i++)\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Consecutive Sequence.cpp:\n    3  public:\n    4      int longestConsecutive(vector<int> &num) {\n    5:         map<int, int>hash_table;\n    6          int count;\n    7          int max_count = 0;\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   18          {\n   19:             int value = m_map[key]->value;\n   20              erase_key(key);\n   21              insert_to_head(key, value);\n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n   31              {\n   32                  //remove the least-used one (the last element)\n   33:                 m_map.erase(m_LRU_cache.back().key);\n   34                  m_LRU_cache.pop_back();\n   35              }\n   ..\n   44      //we should use list instead of vector for 2 reasons.\n   45      //1. vector is continuous memory, insert() will reuslt in re-allocate a whole new memory (bad performance)\n   46:     //2. memory re-allocate will cause the original key-value stored in m_map invalid.\n   47:     map<int, list<cache_entry>::iterator>m_map;\n   48      int m_capacity;\n   49      list<cache_entry>m_LRU_cache;\n   ..\n   52      void erase_key(int key)    \n   53      {\n   54:         list<cache_entry>::iterator it = m_map[key];\n   55          m_LRU_cache.erase(it);\n   56      }\n   ..\n   59          cache_entry cache(key, value);\n   60          m_LRU_cache.insert(m_LRU_cache.begin(), cache);\n   61:         m_map[key] = m_LRU_cache.begin();\n   62      }\n   63  };\n\n/Users/Sean/Sean/Interview/Leetcode/Max Points on a Line.cpp:\n   14      int maxPoints(vector<Point> &points) {\n   15          int max_num = 0;\n   16:         map<float, int>slope;\n   17  \n   18          for (int i = 0; i < points.size(); i++)\n   ..\n   40                  }\n   41              }\n   42:             map<float, int>::iterator it = slope.begin();\n   43              for (;it != slope.end(); it++)\n   44              {\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n    1: //add map<int, int>duplicate to record duplicate num at the same position.\n    2  class Solution {\n    3  public:\n    .\n    5      void do_permute(vector<int> &num, vector<vector<int> > &res, vector<int> &one_sol, vector<int> &selected)\n    6      {\n    7:         map<int, int>duplicate;        \n    8          \n    9          if (one_sol.size() == num.size())\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    4          \n    5          vector<int> res;\n    6:         map<string, int>L_table;        \n    7:         map<string, int>match_count;        \n    8          int L_num = L.size();\n    9          int each_size;\n   ..\n   14          each_size = L[0].size();\n   15          \n   16:         //create map table for each stirng in L\n   17          for (int i = 0; i < L_num; i++)       \n   18              L_table[L[i]]++;\n   19                     \n   20  \n   21:         //create map table for each stirng in L. \n   22          //L[i] may be repeating so we should use addition to record the corresponding count.\n   23          for (i = 0; i < (int)S.size() - (each_size*L_num-1); i++)            \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   54      }\n   55  };\n   56: #else //hash map solution\n   57: #include <map>\n   58  class Solution {\n   59  public:\n   60      vector<int> twoSum(vector<int> &numbers, int target) {\n   61          \n   62:         map<int, int>hash_table;\n   63          int i;\n   64          vector<int>res;\n\n<untitled 214>:\n    1: map\n\n<untitled 75>:\n    1  stack<int>\n    2: map<int, string>\n    3  vector<>\n\n29 matches across 12 files\n\n\nSearching 134 files for \"[]\"\n\n/Users/Sean/Sean/Interview/Leetcode/First Missing Positive.cpp:\n    8  class Solution {\n    9  public:\n   10:     int firstMissingPositive(int A[], int n) {\n   11  \n   12          int k;\n\n/Users/Sean/Sean/Interview/Leetcode/Letter Combinations of a Phone Number.cpp:\n    4      void gen_string(string digits, string &curr_str, vector<string >&res)\n    5      {\n    6:         string table[] = {\"\", \" \", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    7              \n    8          int index;\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   21          if (A[half_m] >= B[half_n])\n   22          {\n   23:             //half A[]: A[0] to A[half_m-1]\n   24:             //half B[]: B[0] to B[half_n]\n   25              if (half_m + half_n + 1 >= k)\n   26                  return findMedian(A, half_m, B, n, k);\n   ..\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41              return findMedian(A, m, B, n, (m + n)/2 + 1);\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Sorted Array.cpp:\n    2  class Solution {\n    3  public:\n    4:     void merge(int A[], int m, int B[], int n) {\n    5          \n    6          int end = m + n - 1;\n\n/Users/Sean/Sean/Interview/Leetcode/MergeSort.c:\n    1: void mergeSort(int numbers[], int temp[], int array_size)\n    2  {\n    3    m_sort(numbers, temp, 0, array_size - 1);\n    .\n    5   \n    6   \n    7: void m_sort(int numbers[], int temp[], int left, int right)\n    8  {\n    9    int mid;\n   ..\n   19  }\n   20   \n   21: void merge(int numbers[], int temp[], int left, int mid, int right)\n   22  {\n   23    int i, left_end, num_elements, tmp_pos;\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array II.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeDuplicates(int A[], int n) {\n    4          int repeat, num = 0;\n    5          for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeDuplicates(int A[], int n) {\n    4          int num = 0;\n    5          for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Element.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeElement(int A[], int n, int elem) {\n    4          \n    5          int num = 0;\n\n/Users/Sean/Sean/Interview/Leetcode/Search for a Range.cpp:\n    4  public:\n    5  \n    6:     int search_index(int A[], int left, int right, int target)\n    7      {\n    8          int mid = (left + right) >> 1;\n    .\n   18      }\n   19  \n   20:     vector<int> searchRange(int A[], int n, int target) {\n   21  \n   22          int index;\n   ..\n   48  class Solution {\n   49  public:\n   50:     vector<int> searchRange(int A[], int n, int target) {\n   51  \n   52          int left = 0, right = n-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array II.cpp:\n    2  public:\n    3  \n    4:     bool search(int A[], int n, int target) {\n    5          \n    6          int left = 0, right = n-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array.cpp:\n    2  public:\n    3  \n    4:     int search(int A[], int n, int target) {\n    5          \n    6          int left = 0, right = n-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search Insert Position.cpp:\n    2  class Solution {\n    3  public:\n    4:     int searchInsert(int A[], int n, int target) {\n    5          int left = 0, right = n - 1;\n    6  \n\n/Users/Sean/Sean/Interview/Leetcode/Single Number II.cpp:\n    9  class Solution {\n   10  public:\n   11:     int singleNumber(int A[], int n) {\n   12          int num = 0;\n   13          for (int i = 0; i < 32; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Single Number.cpp:\n    1  class Solution {\n    2  public:\n    3:     int singleNumber(int A[], int n) {\n    4          int num = 0;\n    5          for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Sort Colors.cpp:\n   13          *b = temp;                                                                                                     \n   14      }                                                                                                                  \n   15:     void sortColors(int A[], int n) {                                                                                  \n   16                                                                                                                         \n   17          int red_idx = 0, blue_idx = n - 1;                                                                             \n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    6  class Solution {                                                                       \n    7  public:                                                                                \n    8:     int trap(int A[], int n) {                                                         \n    9          int total  = 0;                                                                \n   10          int *left  = new int[n];                                                       \n\n29 matches across 16 files\n\n\nSearching 134 files for \"find\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n   13              sort(s.begin(), s.end());\n   14              \n   15:             if (anagram.find(s) == anagram.end())\n   16              {\n   17                  anagram[s] = i;\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int findMin(vector<int> &num) {\n    4  \n    5          int left = 0, right = num.size()-1;\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   24              //half B[]: B[0] to B[half_n]\n   25              if (half_m + half_n + 1 >= k)\n   26:                 return findMedian(A, half_m, B, n, k);\n   27              else\n   28:                 return findMedian(A, m, B+half_n+1, n-(half_n+1), k-(half_n+1));\n   29          }\n   30          else\n   31          {\n   32              if (half_m + half_n + 1 >= k)\n   33:                 return findMedian(A, m, B, half_n, k);\n   34              else\n   35:                 return findMedian(A+half_m+1, m-(half_m+1), B, n, k-(half_m+1));               \n   36          }\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41:             return findMedian(A, m, B, n, (m + n)/2 + 1);\n   42          else\n   43:             return (findMedian(A, m, B, n, (m + n)/2) + findMedian(A, m, B, n, (m + n)/2 + 1)) / 2;\n   44      }\n   45  };\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Window Substring.cpp:\n    1: //use two pointers (left, right) to find the match region.\n    2  //1. advance right index to collect enough char.\n    3  //2. advance left index to shrink the (left, right) region.\n    4: //3. adnvace left index and right index to find the next possible solutoin.\n    5  //4. repeat step1-step3\n    6  class Solution {\n    .\n   47                  }\n   48  \n   49:                 //increase left to find the next possible solution.\n   50                  S_table[S[left]]--;\n   51                  match_num--;\n\n/Users/Sean/Sean/Interview/Leetcode/Next Permutation.cpp:\n   11              return;\n   12          \n   13:         //from right to left, find the first descending index            \n   14          for (int i = size - 2; i >= 0; i--)\n   15          {\n   ..\n   21          }\n   22          \n   23:         //from right to left, find the first number larger than the partition number            \n   24          if (partition_idx != -1)\n   25          {\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n   14      }\n   15  \n   16:     void findPalindrome(string s, int start, vector<string> &one_sol, vector<vector<string> > &res)\n   17      {\n   18          if (start == s.size())\n   ..\n   23              {\n   24                  one_sol.push_back(s.substr(start, i-start+1));\n   25:                 findPalindrome(s, i+1, one_sol, res);\n   26                  one_sol.pop_back();\n   27              }\n   ..\n   32          vector<string>one_sol;\n   33          vector<vector<string> >res;\n   34:         findPalindrome(s, 0, one_sol, res);\n   35          return res;\n   36      }\n\n/Users/Sean/Sean/Interview/Leetcode/Partition List.cpp:\n    1: //find the first element greater than or equal to x, call it pivot, then move every smaller element to the left of the pivot.\n    2  class Solution {\n    3  public:        \n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   25          \n   26          one_sol.push_back(root->val);\n   27:         findPathSum(root->left, sum-root->val, res, one_sol);\n   28:         findPathSum(root->right, sum-root->val, res, one_sol);        \n   29          one_sol.pop_back();                    \n   30      }\n   ..\n   34          vector<int>one_sol;\n   35          \n   36:         findPathSum(root, sum, res, one_sol);\n   37          return res;\n   38      }\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   15          for (int i = 0; i < num.size(); i++)\n   16          {\n   17:             if (selected[i] || duplicate.find(num[i]) != duplicate.end())\n   18                  continue;\n   19                  \n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   16              return -1;\n   17          \n   18:         find_err_node(root->left, pre_node, large_err, small_err);\n   19          \n   20          if (pre_node && pre_node->val > root->val)\n   ..\n   32          pre_node = root;\n   33          \n   34:         find_err_node(root->right, pre_node, large_err, small_err);\n   35          return 0;                    \n   36      }\n   ..\n   41          \n   42          TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43:         find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n   45          if (!root)\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Words in a String.cpp:\n   19          size_t left, right;\n   20          string delimiter = \" \\f\\n\\r\\t\\v\";\n   21:         left = s.find_first_not_of(delimiter);\n   22:         right  = s.find_last_not_of(delimiter);\n   23  \n   24          if (left == string::npos || right == string::npos)\n\n/Users/Sean/Sean/Interview/Leetcode/Rotate List.cpp:\n   19          if (!head) return head;\n   20          \n   21:         //find total number\n   22          while (temp)\n   23          {\n   ..\n   31          if (k == 0) return head;\n   32          \n   33:         //find new head (target)\n   34          for (i = 0, target = head; i < num - k; i++)\n   35          {\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    1  class Solution {\n    2  public:\n    3:     vector<int> findSubstring(string S, vector<string> &L) {\n    4          \n    5          vector<int> res;\n    .\n   28              {\n   29                  string substr = S.substr(i+j*each_size, each_size);\n   30:                 if (L_table.find(substr) == L_table.end())                        \n   31                      break;\n   32                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   24              sum += one_num;\n   25              \n   26:         findNumber(root->left, one_num, sum);\n   27:         findNumber(root->right, one_num, sum);\n   28          return;\n   29      }\n   ..\n   31      int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33:         findNumber(root, one_num, sum);\n   34          return sum;\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    1  //The area for each A[i]                                                               \n    2: //1. find the max height of the left of A[i], call it A_left_max[i]                    \n    3: //2. find the max height of the right of A[i], call it A_right_max[i]                  \n    4  //3. area of A[i] = (min(A_left_max[i], A_right_max[i]) - A[i])*1                      \n    5  #define MIN(a, b) ((a < b) ? (a) : (b))                                                \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   72          {\n   73              int diff = target - numbers[i];\n   74:             if (hash_table.find(diff) != hash_table.end() && hash_table[diff] != i)\n   75              {\n   76                  res.push_back(i+1);\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Number.cpp:\n   11  \n   12  		//trim space\n   13: 		size_t end_pos = str.find_last_not_of(\" \\t\\n\");\n   14  \n   15  		if (end_pos != string::npos)\n   16  			str = str.substr(0, end_pos + 1);\n   17  \n   18: 		size_t start_pos = str.find_first_not_of(\" \\t\\n\");\n   19  		if (start_pos != string::npos)\n   20  			str = str.substr(start_pos);\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp:\n   18              string str = s.substr(start, i-start+1);\n   19              //if s[0] to s[i] is matched, then do recursive on remaining sub string.\n   20:             if (dict.find(str) != dict.end() && possible[i+1])\n   21              {\n   22                  int pre_size = res.size();\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break.cpp:\n   12              for (int k = 0; k < i ; k++)\n   13              {\n   14:                 hit[i] = hit[k] && (dict.find(s2.substr(k+1, i-k)) != dict.end());\n   15                  if (hit[i]) break;\n   16              }\n\n/Users/Sean/Sean/Interview/Leetcode/Word Search.cpp:\n    3  Analysis:\n    4  The idea of this question is as follows:\n    5: (1) Find the 1st element of the word in the board.\n    6  (2) For each position found where the 1st element lies, recursively do:\n    7             (i) Search the around cell to see if the next element exists. (4 directions: (i-1,j),(i+1,j),(i,j-1),(i,j+1) )\n\n<untitled 302>:\n    6  vector\n    7  \n    8: hash.find(i) != hash.end()\n    9  vector<int>table;\n   10  \n\n90 matches across 24 files\n\n\nSearching 135 files for \"find\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n   13              sort(s.begin(), s.end());\n   14              \n   15:             if (anagram.find(s) == anagram.end())\n   16              {\n   17                  anagram[s] = i;\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int findMin(vector<int> &num) {\n    4  \n    5          int left = 0, right = num.size()-1;\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   24              //half B[]: B[0] to B[half_n]\n   25              if (half_m + half_n + 1 >= k)\n   26:                 return findMedian(A, half_m, B, n, k);\n   27              else\n   28:                 return findMedian(A, m, B+half_n+1, n-(half_n+1), k-(half_n+1));\n   29          }\n   30          else\n   31          {\n   32              if (half_m + half_n + 1 >= k)\n   33:                 return findMedian(A, m, B, half_n, k);\n   34              else\n   35:                 return findMedian(A+half_m+1, m-(half_m+1), B, n, k-(half_m+1));               \n   36          }\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41:             return findMedian(A, m, B, n, (m + n)/2 + 1);\n   42          else\n   43:             return (findMedian(A, m, B, n, (m + n)/2) + findMedian(A, m, B, n, (m + n)/2 + 1)) / 2;\n   44      }\n   45  };\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Window Substring.cpp:\n    1: //use two pointers (left, right) to find the match region.\n    2  //1. advance right index to collect enough char.\n    3  //2. advance left index to shrink the (left, right) region.\n    4: //3. adnvace left index and right index to find the next possible solutoin.\n    5  //4. repeat step1-step3\n    6  class Solution {\n    .\n   47                  }\n   48  \n   49:                 //increase left to find the next possible solution.\n   50                  S_table[S[left]]--;\n   51                  match_num--;\n\n/Users/Sean/Sean/Interview/Leetcode/Next Permutation.cpp:\n   11              return;\n   12          \n   13:         //from right to left, find the first descending index            \n   14          for (int i = size - 2; i >= 0; i--)\n   15          {\n   ..\n   21          }\n   22          \n   23:         //from right to left, find the first number larger than the partition number            \n   24          if (partition_idx != -1)\n   25          {\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n   14      }\n   15  \n   16:     void findPalindrome(string s, int start, vector<string> &one_sol, vector<vector<string> > &res)\n   17      {\n   18          if (start == s.size())\n   ..\n   23              {\n   24                  one_sol.push_back(s.substr(start, i-start+1));\n   25:                 findPalindrome(s, i+1, one_sol, res);\n   26                  one_sol.pop_back();\n   27              }\n   ..\n   32          vector<string>one_sol;\n   33          vector<vector<string> >res;\n   34:         findPalindrome(s, 0, one_sol, res);\n   35          return res;\n   36      }\n\n/Users/Sean/Sean/Interview/Leetcode/Partition List.cpp:\n    1: //find the first element greater than or equal to x, call it pivot, then move every smaller element to the left of the pivot.\n    2  class Solution {\n    3  public:        \n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   25          \n   26          one_sol.push_back(root->val);\n   27:         findPathSum(root->left, sum-root->val, res, one_sol);\n   28:         findPathSum(root->right, sum-root->val, res, one_sol);        \n   29          one_sol.pop_back();                    \n   30      }\n   ..\n   34          vector<int>one_sol;\n   35          \n   36:         findPathSum(root, sum, res, one_sol);\n   37          return res;\n   38      }\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   15          for (int i = 0; i < num.size(); i++)\n   16          {\n   17:             if (selected[i] || duplicate.find(num[i]) != duplicate.end())\n   18                  continue;\n   19                  \n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   16              return -1;\n   17          \n   18:         find_err_node(root->left, pre_node, large_err, small_err);\n   19          \n   20          if (pre_node && pre_node->val > root->val)\n   ..\n   32          pre_node = root;\n   33          \n   34:         find_err_node(root->right, pre_node, large_err, small_err);\n   35          return 0;                    \n   36      }\n   ..\n   41          \n   42          TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43:         find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n   45          if (!root)\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Words in a String.cpp:\n   19          size_t left, right;\n   20          string delimiter = \" \\f\\n\\r\\t\\v\";\n   21:         left = s.find_first_not_of(delimiter);\n   22:         right  = s.find_last_not_of(delimiter);\n   23  \n   24          if (left == string::npos || right == string::npos)\n\n/Users/Sean/Sean/Interview/Leetcode/Rotate List.cpp:\n   19          if (!head) return head;\n   20          \n   21:         //find total number\n   22          while (temp)\n   23          {\n   ..\n   31          if (k == 0) return head;\n   32          \n   33:         //find new head (target)\n   34          for (i = 0, target = head; i < num - k; i++)\n   35          {\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    1  class Solution {\n    2  public:\n    3:     vector<int> findSubstring(string S, vector<string> &L) {\n    4          \n    5          vector<int> res;\n    .\n   28              {\n   29                  string substr = S.substr(i+j*each_size, each_size);\n   30:                 if (L_table.find(substr) == L_table.end())                        \n   31                      break;\n   32                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   24              sum += one_num;\n   25              \n   26:         findNumber(root->left, one_num, sum);\n   27:         findNumber(root->right, one_num, sum);\n   28          return;\n   29      }\n   ..\n   31      int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33:         findNumber(root, one_num, sum);\n   34          return sum;\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    1  //The area for each A[i]                                                               \n    2: //1. find the max height of the left of A[i], call it A_left_max[i]                    \n    3: //2. find the max height of the right of A[i], call it A_right_max[i]                  \n    4  //3. area of A[i] = (min(A_left_max[i], A_right_max[i]) - A[i])*1                      \n    5  #define MIN(a, b) ((a < b) ? (a) : (b))                                                \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   72          {\n   73              int diff = target - numbers[i];\n   74:             if (hash_table.find(diff) != hash_table.end() && hash_table[diff] != i)\n   75              {\n   76                  res.push_back(i+1);\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Number.cpp:\n   11  \n   12  		//trim space\n   13: 		size_t end_pos = str.find_last_not_of(\" \\t\\n\");\n   14  \n   15  		if (end_pos != string::npos)\n   16  			str = str.substr(0, end_pos + 1);\n   17  \n   18: 		size_t start_pos = str.find_first_not_of(\" \\t\\n\");\n   19  		if (start_pos != string::npos)\n   20  			str = str.substr(start_pos);\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp:\n   18              string str = s.substr(start, i-start+1);\n   19              //if s[0] to s[i] is matched, then do recursive on remaining sub string.\n   20:             if (dict.find(str) != dict.end() && possible[i+1])\n   21              {\n   22                  int pre_size = res.size();\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break.cpp:\n   12              for (int k = 0; k < i ; k++)\n   13              {\n   14:                 hit[i] = hit[k] && (dict.find(s2.substr(k+1, i-k)) != dict.end());\n   15                  if (hit[i]) break;\n   16              }\n\n/Users/Sean/Sean/Interview/Leetcode/Word Search.cpp:\n    3  Analysis:\n    4  The idea of this question is as follows:\n    5: (1) Find the 1st element of the word in the board.\n    6  (2) For each position found where the 1st element lies, recursively do:\n    7             (i) Search the around cell to see if the next element exists. (4 directions: (i-1,j),(i+1,j),(i,j-1),(i,j+1) )\n\n/Users/Sean/Sean/Interview/Snapchat/code.cpp:\n    8  // To execute C++, please define \"int main()\"\n    9  \n   10: vector<int> findSum(vector<int> data, int k)\n   11  {\n   12    vector<int>res;\n   ..\n   40  if (hash_table[k-1] != hash_table.end())\n   41  \n   42: vector<int> findSum(vector<int> data, int k)\n   43  {\n   44    vector<int>res;\n   ..\n   49    for (int i = 0; i < num; i++)\n   50    {\n   51:     if (index_table.find(i) == index_table.end())\n   52        index_table[data[i]] = i;\n   53      else\n   ..\n   60    for (int i = 0; i < num; i++)\n   61    {\n   62:     if (index_table.find(k - data[i]) != index_table.end())\n   63      {\n   64        int max_one = MAX(index_table[k - data[i]], index_table[data[i]]);\n\n<untitled 302>:\n    6  vector\n    7  \n    8: hash.find(i) != hash.end()\n    9  vector<int>table;\n   10  \n\n94 matches across 25 files\n\n\nSearching 142 files for \"find\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n   13              sort(s.begin(), s.end());\n   14              \n   15:             if (anagram.find(s) == anagram.end())\n   16              {\n   17                  anagram[s] = i;\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int findMin(vector<int> &num) {\n    4  \n    5          int left = 0, right = num.size()-1;\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   24              //half B[]: B[0] to B[half_n]\n   25              if (half_m + half_n + 1 >= k)\n   26:                 return findMedian(A, half_m, B, n, k);\n   27              else\n   28:                 return findMedian(A, m, B+half_n+1, n-(half_n+1), k-(half_n+1));\n   29          }\n   30          else\n   31          {\n   32              if (half_m + half_n + 1 >= k)\n   33:                 return findMedian(A, m, B, half_n, k);\n   34              else\n   35:                 return findMedian(A+half_m+1, m-(half_m+1), B, n, k-(half_m+1));               \n   36          }\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41:             return findMedian(A, m, B, n, (m + n)/2 + 1);\n   42          else\n   43:             return (findMedian(A, m, B, n, (m + n)/2) + findMedian(A, m, B, n, (m + n)/2 + 1)) / 2;\n   44      }\n   45  };\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Window Substring.cpp:\n    1: //use two pointers (left, right) to find the match region.\n    2  //1. advance right index to collect enough char.\n    3  //2. advance left index to shrink the (left, right) region.\n    4: //3. adnvace left index and right index to find the next possible solutoin.\n    5  //4. repeat step1-step3\n    6  class Solution {\n    .\n   47                  }\n   48  \n   49:                 //increase left to find the next possible solution.\n   50                  S_table[S[left]]--;\n   51                  match_num--;\n\n/Users/Sean/Sean/Interview/Leetcode/Next Permutation.cpp:\n   11              return;\n   12          \n   13:         //from right to left, find the first descending index            \n   14          for (int i = size - 2; i >= 0; i--)\n   15          {\n   ..\n   21          }\n   22          \n   23:         //from right to left, find the first number larger than the partition number            \n   24          if (partition_idx != -1)\n   25          {\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n   14      }\n   15  \n   16:     void findPalindrome(string s, int start, vector<string> &one_sol, vector<vector<string> > &res)\n   17      {\n   18          if (start == s.size())\n   ..\n   23              {\n   24                  one_sol.push_back(s.substr(start, i-start+1));\n   25:                 findPalindrome(s, i+1, one_sol, res);\n   26                  one_sol.pop_back();\n   27              }\n   ..\n   32          vector<string>one_sol;\n   33          vector<vector<string> >res;\n   34:         findPalindrome(s, 0, one_sol, res);\n   35          return res;\n   36      }\n\n/Users/Sean/Sean/Interview/Leetcode/Partition List.cpp:\n    1: //find the first element greater than or equal to x, call it pivot, then move every smaller element to the left of the pivot.\n    2  class Solution {\n    3  public:        \n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   25          \n   26          one_sol.push_back(root->val);\n   27:         findPathSum(root->left, sum-root->val, res, one_sol);\n   28:         findPathSum(root->right, sum-root->val, res, one_sol);        \n   29          one_sol.pop_back();                    \n   30      }\n   ..\n   34          vector<int>one_sol;\n   35          \n   36:         findPathSum(root, sum, res, one_sol);\n   37          return res;\n   38      }\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   15          for (int i = 0; i < num.size(); i++)\n   16          {\n   17:             if (selected[i] || duplicate.find(num[i]) != duplicate.end())\n   18                  continue;\n   19                  \n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   16              return -1;\n   17          \n   18:         find_err_node(root->left, pre_node, large_err, small_err);\n   19          \n   20          if (pre_node && pre_node->val > root->val)\n   ..\n   32          pre_node = root;\n   33          \n   34:         find_err_node(root->right, pre_node, large_err, small_err);\n   35          return 0;                    \n   36      }\n   ..\n   41          \n   42          TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43:         find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n   45          if (!root)\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Words in a String.cpp:\n   19          size_t left, right;\n   20          string delimiter = \" \\f\\n\\r\\t\\v\";\n   21:         left = s.find_first_not_of(delimiter);\n   22:         right  = s.find_last_not_of(delimiter);\n   23  \n   24          if (left == string::npos || right == string::npos)\n\n/Users/Sean/Sean/Interview/Leetcode/Rotate List.cpp:\n   19          if (!head) return head;\n   20          \n   21:         //find total number\n   22          while (temp)\n   23          {\n   ..\n   31          if (k == 0) return head;\n   32          \n   33:         //find new head (target)\n   34          for (i = 0, target = head; i < num - k; i++)\n   35          {\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    1  class Solution {\n    2  public:\n    3:     vector<int> findSubstring(string S, vector<string> &L) {\n    4          \n    5          vector<int> res;\n    .\n   28              {\n   29                  string substr = S.substr(i+j*each_size, each_size);\n   30:                 if (L_table.find(substr) == L_table.end())                        \n   31                      break;\n   32                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   24              sum += one_num;\n   25              \n   26:         findNumber(root->left, one_num, sum);\n   27:         findNumber(root->right, one_num, sum);\n   28          return;\n   29      }\n   ..\n   31      int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33:         findNumber(root, one_num, sum);\n   34          return sum;\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    1  //The area for each A[i]                                                               \n    2: //1. find the max height of the left of A[i], call it A_left_max[i]                    \n    3: //2. find the max height of the right of A[i], call it A_right_max[i]                  \n    4  //3. area of A[i] = (min(A_left_max[i], A_right_max[i]) - A[i])*1                      \n    5  #define MIN(a, b) ((a < b) ? (a) : (b))                                                \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   72          {\n   73              int diff = target - numbers[i];\n   74:             if (hash_table.find(diff) != hash_table.end() && hash_table[diff] != i)\n   75              {\n   76                  res.push_back(i+1);\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Number.cpp:\n   11  \n   12  		//trim space\n   13: 		size_t end_pos = str.find_last_not_of(\" \\t\\n\");\n   14  \n   15  		if (end_pos != string::npos)\n   16  			str = str.substr(0, end_pos + 1);\n   17  \n   18: 		size_t start_pos = str.find_first_not_of(\" \\t\\n\");\n   19  		if (start_pos != string::npos)\n   20  			str = str.substr(start_pos);\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp:\n   18              string str = s.substr(start, i-start+1);\n   19              //if s[0] to s[i] is matched, then do recursive on remaining sub string.\n   20:             if (dict.find(str) != dict.end() && possible[i+1])\n   21              {\n   22                  int pre_size = res.size();\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break.cpp:\n   12              for (int k = 0; k < i ; k++)\n   13              {\n   14:                 hit[i] = hit[k] && (dict.find(s2.substr(k+1, i-k)) != dict.end());\n   15                  if (hit[i]) break;\n   16              }\n\n/Users/Sean/Sean/Interview/Leetcode/Word Search.cpp:\n    3  Analysis:\n    4  The idea of this question is as follows:\n    5: (1) Find the 1st element of the word in the board.\n    6  (2) For each position found where the 1st element lies, recursively do:\n    7             (i) Search the around cell to see if the next element exists. (4 directions: (i-1,j),(i+1,j),(i,j-1),(i,j+1) )\n\n<untitled 1874>:\n    6  vector\n    7  \n    8: hash.find(i) != hash.end()\n    9  vector<int>table;\n   10  \n\n90 matches across 24 files\n\n\nSearching 143 files for \"find\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n   13              sort(s.begin(), s.end());\n   14              \n   15:             if (anagram.find(s) == anagram.end())\n   16              {\n   17                  anagram[s] = i;\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int findMin(vector<int> &num) {\n    4  \n    5          int left = 0, right = num.size()-1;\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   24              //half B[]: B[0] to B[half_n]\n   25              if (half_m + half_n + 1 >= k)\n   26:                 return findMedian(A, half_m, B, n, k);\n   27              else\n   28:                 return findMedian(A, m, B+half_n+1, n-(half_n+1), k-(half_n+1));\n   29          }\n   30          else\n   31          {\n   32              if (half_m + half_n + 1 >= k)\n   33:                 return findMedian(A, m, B, half_n, k);\n   34              else\n   35:                 return findMedian(A+half_m+1, m-(half_m+1), B, n, k-(half_m+1));               \n   36          }\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41:             return findMedian(A, m, B, n, (m + n)/2 + 1);\n   42          else\n   43:             return (findMedian(A, m, B, n, (m + n)/2) + findMedian(A, m, B, n, (m + n)/2 + 1)) / 2;\n   44      }\n   45  };\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Window Substring.cpp:\n    1: //use two pointers (left, right) to find the match region.\n    2  //1. advance right index to collect enough char.\n    3  //2. advance left index to shrink the (left, right) region.\n    4: //3. adnvace left index and right index to find the next possible solutoin.\n    5  //4. repeat step1-step3\n    6  class Solution {\n    .\n   47                  }\n   48  \n   49:                 //increase left to find the next possible solution.\n   50                  S_table[S[left]]--;\n   51                  match_num--;\n\n/Users/Sean/Sean/Interview/Leetcode/Next Permutation.cpp:\n   11              return;\n   12          \n   13:         //from right to left, find the first descending index            \n   14          for (int i = size - 2; i >= 0; i--)\n   15          {\n   ..\n   21          }\n   22          \n   23:         //from right to left, find the first number larger than the partition number            \n   24          if (partition_idx != -1)\n   25          {\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n   14      }\n   15  \n   16:     void findPalindrome(string s, int start, vector<string> &one_sol, vector<vector<string> > &res)\n   17      {\n   18          if (start == s.size())\n   ..\n   23              {\n   24                  one_sol.push_back(s.substr(start, i-start+1));\n   25:                 findPalindrome(s, i+1, one_sol, res);\n   26                  one_sol.pop_back();\n   27              }\n   ..\n   32          vector<string>one_sol;\n   33          vector<vector<string> >res;\n   34:         findPalindrome(s, 0, one_sol, res);\n   35          return res;\n   36      }\n\n/Users/Sean/Sean/Interview/Leetcode/Partition List.cpp:\n    1: //find the first element greater than or equal to x, call it pivot, then move every smaller element to the left of the pivot.\n    2  class Solution {\n    3  public:        \n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   25          \n   26          one_sol.push_back(root->val);\n   27:         findPathSum(root->left, sum-root->val, res, one_sol);\n   28:         findPathSum(root->right, sum-root->val, res, one_sol);        \n   29          one_sol.pop_back();                    \n   30      }\n   ..\n   34          vector<int>one_sol;\n   35          \n   36:         findPathSum(root, sum, res, one_sol);\n   37          return res;\n   38      }\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   15          for (int i = 0; i < num.size(); i++)\n   16          {\n   17:             if (selected[i] || duplicate.find(num[i]) != duplicate.end())\n   18                  continue;\n   19                  \n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   16              return -1;\n   17          \n   18:         find_err_node(root->left, pre_node, large_err, small_err);\n   19          \n   20          if (pre_node && pre_node->val > root->val)\n   ..\n   32          pre_node = root;\n   33          \n   34:         find_err_node(root->right, pre_node, large_err, small_err);\n   35          return 0;                    \n   36      }\n   ..\n   41          \n   42          TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43:         find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n   45          if (!root)\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Words in a String.cpp:\n   19          size_t left, right;\n   20          string delimiter = \" \\f\\n\\r\\t\\v\";\n   21:         left = s.find_first_not_of(delimiter);\n   22:         right  = s.find_last_not_of(delimiter);\n   23  \n   24          if (left == string::npos || right == string::npos)\n\n/Users/Sean/Sean/Interview/Leetcode/Rotate List.cpp:\n   19          if (!head) return head;\n   20          \n   21:         //find total number\n   22          while (temp)\n   23          {\n   ..\n   31          if (k == 0) return head;\n   32          \n   33:         //find new head (target)\n   34          for (i = 0, target = head; i < num - k; i++)\n   35          {\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    1  class Solution {\n    2  public:\n    3:     vector<int> findSubstring(string S, vector<string> &L) {\n    4          \n    5          vector<int> res;\n    .\n   28              {\n   29                  string substr = S.substr(i+j*each_size, each_size);\n   30:                 if (L_table.find(substr) == L_table.end())                        \n   31                      break;\n   32                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   24              sum += one_num;\n   25              \n   26:         findNumber(root->left, one_num, sum);\n   27:         findNumber(root->right, one_num, sum);\n   28          return;\n   29      }\n   ..\n   31      int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33:         findNumber(root, one_num, sum);\n   34          return sum;\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    1  //The area for each A[i]                                                               \n    2: //1. find the max height of the left of A[i], call it A_left_max[i]                    \n    3: //2. find the max height of the right of A[i], call it A_right_max[i]                  \n    4  //3. area of A[i] = (min(A_left_max[i], A_right_max[i]) - A[i])*1                      \n    5  #define MIN(a, b) ((a < b) ? (a) : (b))                                                \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   72          {\n   73              int diff = target - numbers[i];\n   74:             if (hash_table.find(diff) != hash_table.end() && hash_table[diff] != i)\n   75              {\n   76                  res.push_back(i+1);\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Number.cpp:\n   11  \n   12  		//trim space\n   13: 		size_t end_pos = str.find_last_not_of(\" \\t\\n\");\n   14  \n   15  		if (end_pos != string::npos)\n   16  			str = str.substr(0, end_pos + 1);\n   17  \n   18: 		size_t start_pos = str.find_first_not_of(\" \\t\\n\");\n   19  		if (start_pos != string::npos)\n   20  			str = str.substr(start_pos);\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp:\n   18              string str = s.substr(start, i-start+1);\n   19              //if s[0] to s[i] is matched, then do recursive on remaining sub string.\n   20:             if (dict.find(str) != dict.end() && possible[i+1])\n   21              {\n   22                  int pre_size = res.size();\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break.cpp:\n   12              for (int k = 0; k < i ; k++)\n   13              {\n   14:                 hit[i] = hit[k] && (dict.find(s2.substr(k+1, i-k)) != dict.end());\n   15                  if (hit[i]) break;\n   16              }\n\n/Users/Sean/Sean/Interview/Leetcode/Word Search.cpp:\n    3  Analysis:\n    4  The idea of this question is as follows:\n    5: (1) Find the 1st element of the word in the board.\n    6  (2) For each position found where the 1st element lies, recursively do:\n    7             (i) Search the around cell to see if the next element exists. (4 directions: (i-1,j),(i+1,j),(i,j-1),(i,j+1) )\n\n<untitled 2126>:\n    6  vector\n    7  \n    8: hash.find(i) != hash.end()\n    9  vector<int>table;\n   10  \n\n90 matches across 24 files\n\n\nSearching 153 files for \"treenode\"\n\n/Users/Sean/Sean/Interview/Leetcode/Balanced Binary Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   13      \n   14      //-1: not balanced. otherwise: the depth\n   15:     int getDepth(TreeNode *root)\n   16      {\n   17          int left, right;\n   ..\n   31      }\n   32      \n   33:     bool isBalanced(TreeNode *root) {\n   34          return (getDepth(root) == -1) ? (false) : (true);\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Inorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     vector<int> inorderTraversal(TreeNode *root) {\n   14          vector<int>left, right;\n   15  \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal II.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   14      {\n   15          if (!root) return -1;\n   ..\n   28      }\n   29  \n   30:     vector<vector<int> > levelOrderBottom(TreeNode *root) {\n   31          vector<vector<int> >result, reverse;\n   32          \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   13      {\n   14          if (!root) return -1;\n   ..\n   27      }\n   28  \n   29:     vector<vector<int> > levelOrder(TreeNode *root) {\n   30          vector<vector<int> >res;\n   31          res.clear();\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Maximum Path Sum.cpp:\n    2  /**\n    3   * Definition for binary tree\n    4:  * struct TreeNode {\n    5   *     int val;\n    6:  *     TreeNode *left;\n    7:  *     TreeNode *right;\n    8:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    9   * };\n   10   */\n   ..\n   14      //1. return value: the max value whose ending point is root. This return value can be used by the parent of current root.\n   15      //2. max_val is current max value.\n   16:     int computeMax(TreeNode *root, int &max_val)\n   17      {\n   18          int max_left, max_right;\n   ..\n   46      }\n   47  \n   48:     int maxPathSum(TreeNode *root)\n   49      {\n   50          int max_val = INT_MIN;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Postorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     vector<int> postorderTraversal(TreeNode *root) {\n   15:         stack<TreeNode*> s;\n   16:         TreeNode *top_node, *popped = 0;\n   17          vector<int>res;\n   18  \n   ..\n   54  public:\n   55  \n   56:     vector<int> postorderTraversal(TreeNode *root) {\n   57          vector<int>left, right;\n   58          int i;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Preorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     vector<int> preorderTraversal(TreeNode *root) {\n   15  \n   16:         stack<TreeNode*> s;\n   17:         TreeNode *top_node;\n   18          vector<int>res;\n   19  \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Zigzag Level Order Traversal.cpp:\n    2  /**\n    3   * Definition for binary tree\n    4:  * struct TreeNode {\n    5   *     int val;\n    6:  *     TreeNode *left;\n    7:  *     TreeNode *right;\n    8:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    9   * };\n   10   */\n   ..\n   12  public:\n   13  \n   14:     vector<vector<int> > zigzagLevelOrder(TreeNode *root) {\n   15          vector<vector<int> >res;\n   16          vector<int>one_sol;\n   17          //use stack to store the next level node,\n   18          //such that ordering of the next level is reverse to that of the current level.\n   19:         stack<TreeNode *>next_stk, curr_stk;\n   20          int right_to_left = 1;\n   21  \n   ..\n   27          while (!curr_stk.empty())\n   28          {\n   29:             TreeNode *top = curr_stk.top();\n   30              one_sol.push_back(top->val);\n   31  \n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Inorder and Postorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     TreeNode *genBST(vector<int> &inorder, int in_start, int in_end, vector<int> &postorder, int post_start, int post_end)\n   13      {\n   14:         TreeNode *root, *left, *right;\n   15          int root_val;\n   16          int root_pos;\n   ..\n   25  \n   26          root_val = postorder[post_end];\n   27:         root = new TreeNode(root_val);\n   28  \n   29          //base condition\n   ..\n   42      }\n   43  \n   44:     TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\n   45          if (inorder.size() == 0 || postorder.size() == 0)\n   46              return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Preorder and Inorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12      //find the root position first. Then generate left/right tree recursively.\n   13:     TreeNode *genBST(vector<int> &preorder, int pre_start, int pre_end, vector<int> &inorder, int in_start, int in_end)\n   14      {\n   15:         TreeNode *root, *left, *right;\n   16          int root_val;\n   17          int root_pos;\n   ..\n   23  \n   24          root_val = preorder[pre_start];\n   25:         root = new TreeNode(root_val);\n   26          //base condition\n   27          if (pre_start == pre_end)\n   ..\n   41      }\n   42  \n   43:     TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n   44          if (preorder.size() == 0 || inorder.size() == 0)\n   45              return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted Array to Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12      //note: the first param should use \"&\" (called by reference),\n   13      // if not using \"&\" (i. e. call by value) will cause memory limit exceeding\n   14:     TreeNode *buildBST(vector<int> &num, int start, int end)\n   15      {\n   16:         TreeNode *left, *right, *parent;\n   17          int mid = (start + end) >> 1;\n   18  \n   ..\n   21  \n   22          left = buildBST(num, start, mid-1);\n   23:         parent = new TreeNode(num[mid]);\n   24          parent->left = left;\n   25          right = buildBST(num, mid+1, end);\n   ..\n   28      }\n   29  \n   30:     TreeNode *sortedArrayToBST(vector<int> &num) {\n   31          return buildBST(num, 0, num.size()-1);\n   32      }\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted List to Binary Search Tree.cpp:\n    9  /**\n   10   * Definition for binary tree\n   11:  * struct TreeNode {\n   12   *     int val;\n   13:  *     TreeNode *left;\n   14:  *     TreeNode *right;\n   15:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n   16   * };\n   17   */\n   18  class Solution {\n   19  public:\n   20:     TreeNode *buildBST(ListNode *&head, int start, int end)\n   21      {\n   22:         TreeNode *left, *right, *parent;\n   23          int mid;\n   24          \n   ..\n   31          left = buildBST(head, start, mid-1);\n   32          \n   33:         parent = new TreeNode(head->val);\n   34          parent->left = left;\n   35          \n   ..\n   42      }\n   43      \n   44:     TreeNode *sortedListToBST(ListNode *head) {\n   45          \n   46          ListNode *p = head;\n\n/Users/Sean/Sean/Interview/Leetcode/Flatten Binary Tree to Linked List.cpp:\n    4  class Solution {\n    5  public:\n    6:     void build(TreeNode *root, TreeNode *&tmp)\n    7      {\n    8          if(root)\n    .\n   16          }\n   17      }\n   18:     void flatten(TreeNode *root) {\n   19          // Start typing your C/C++ solution below\n   20          // DO NOT write int main() function\n   21:         TreeNode *tmp=NULL;\n   22          build(root, tmp);\n   23  \n   ..\n   29  \n   30      //leaf: the last node in preorder after do_flatten\n   31:     void do_flatten(TreeNode *&root, TreeNode *&leaf)\n   32      {\n   33:         TreeNode *left_leaf, *right_leaf;\n   34  \n   35          if (!root)\n   ..\n   62  \n   63  \n   64:     void flatten(TreeNode *root) {\n   65:         TreeNode *leaf;\n   66          do_flatten(root, leaf);\n   67      }\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Maximum Depth of Binary Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     int maxDepth(TreeNode *root) {\n   13          \n   14          int left_depth, right_depth;\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Depth of Binary Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  class Solution {\n   12  public:\n   13:     int minDepth(TreeNode *root) {\n   14  \n   15          int left_min, right_min;\n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   30      }\n   31      \n   32:     vector<vector<int> > pathSum(TreeNode *root, int sum) {\n   33          vector<vector<int> >res;\n   34          vector<int>one_sol;\n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool hasPathSum(TreeNode *root, int sum) {\n   13          \n   14          bool left, right;\n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   ..\n   36      }\n   37      \n   38:     void recoverTree(TreeNode *root) {\n   39          \n   40          int temp;\n   41          \n   42:         TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43          find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n\n/Users/Sean/Sean/Interview/Leetcode/Same Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool isSameTree(TreeNode *p, TreeNode *q) {\n   13          \n   14          if (!p && !q)\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   29      }\n   30      \n   31:     int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33          findNumber(root, one_num, sum);\n\n/Users/Sean/Sean/Interview/Leetcode/Symmetric Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool isSymmetricTree(TreeNode *left_root, TreeNode *right_root)\n   13      {\n   14          if (!left_root && !right_root)\n   ..\n   27      }\n   28  \n   29:     bool isSymmetric(TreeNode *root) {\n   30  \n   31          if (!root) return true;\n\n/Users/Sean/Sean/Interview/Leetcode/Unique Binary Search Trees II.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int genBST(vector<TreeNode *> &res, int start, int end)\n   14      {\n   15:         vector<TreeNode *>left, right;\n   16  \n   17          if (start > end)\n   ..\n   30                  for (int k = 0; k < right.size(); k++)\n   31                  {\n   32:                     TreeNode *root = new TreeNode(i);\n   33                      root->left = left[j];\n   34                      root->right = right[k];\n   ..\n   39      }\n   40  \n   41:     vector<TreeNode *> generateTrees(int n) {\n   42:         vector<TreeNode *>res;\n   43          genBST(res, 1, n);\n   44          return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     bool verifyBST(TreeNode *root, TreeNode *&pre_node)\n   15      {\n   16          if (!root) return true;\n   ..\n   31      }\n   32  \n   33:     bool isValidBST(TreeNode *root) {\n   34:         TreeNode *pre_node = 0;\n   35          return verifyBST(root, pre_node);\n   36      }\n\n<untitled 3557>:\n    1: struct TreeNode\n    2  {\n    3      int val;\n    4:     TreeNode *left;\n    5:     TreeNode *right;\n    6:     TreeNode (int x): val(x), left(NULL), right(NULL) {}\n    7  \n    8  };\n\n165 matches across 25 files\n\n\nSearching 155 files for \"list\"\n\n/Users/Sean/Sean/Interview/Leetcode/Add Two Numbers.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    .\n   13  public:\n   14  \n   15:     void addNode(ListNode **head, ListNode **tail, int val)\n   16      {\n   17:         ListNode *node = (ListNode *)malloc(sizeof(ListNode));\n   18          node->val = val;\n   19          node->next = NULL;\n   ..\n   28      }\n   29  \n   30:     ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {\n   31          \n   32          int num1, num2, carry = 0;\n   33:         ListNode *head = NULL, *tail = NULL;\n   34          \n   35          if (!l1 && !l2) return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal II.cpp:\n   11  public:\n   12  \n   13:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   14      {\n   15          if (!root) return -1;\n   16          \n   17:         if (level >= list.size())\n   18          {\n   19              vector<int>level_node;\n   20              level_node.clear();\n   21:             list.push_back(level_node);\n   22          }\n   23      \n   24:         list[level].push_back(root->val);\n   25:         genlevelOrder(root->left, list, level+1);\n   26:         genlevelOrder(root->right, list, level+1);        \n   27          return 0;\n   28      }\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal.cpp:\n   10  class Solution {\n   11  public:\n   12:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   13      {\n   14          if (!root) return -1;\n   15          \n   16:         if (level >= list.size())\n   17          {\n   18              vector<int>level_node;\n   19              level_node.clear();\n   20:             list.push_back(level_node);\n   21          }\n   22      \n   23:         list[level].push_back(root->val);\n   24:         genlevelOrder(root->left, list, level+1);\n   25:         genlevelOrder(root->right, list, level+1);        \n   26          return 0;\n   27      }\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted List to Binary Search Tree.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    .\n   18  class Solution {\n   19  public:\n   20:     TreeNode *buildBST(ListNode *&head, int start, int end)\n   21      {\n   22          TreeNode *left, *right, *parent;\n   ..\n   42      }\n   43      \n   44:     TreeNode *sortedListToBST(ListNode *head) {\n   45          \n   46:         ListNode *p = head;\n   47          int i;\n   48          \n\n/Users/Sean/Sean/Interview/Leetcode/Copy List with Random Pointer.cpp:\n    1: //http://fisherlei.blogspot.tw/2013/11/leetcode-copy-list-with-random-pointer.html\n    2  //deep copy means \"allocating\" additional memory then copy\n    3  /**\n    4:  * Definition for singly-linked list with a random pointer.\n    5:  * struct RandomListNode {\n    6   *     int label;\n    7:  *     RandomListNode *next, *random;\n    8:  *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}\n    9   * };\n   10   */\n   11  class Solution {\n   12  public:\n   13:     RandomListNode *copyRandomList(RandomListNode *head) {\n   14  \n   15:         RandomListNode *curr = head;\n   16:         RandomListNode *dup;\n   17:         RandomListNode *copy;\n   18  \n   19          //generate copied ones\n   20          while (curr)\n   21          {\n   22:             RandomListNode *new_node = new RandomListNode(curr->label);\n   23              new_node->next = curr->next;\n   24              curr->next = new_node;\n\n/Users/Sean/Sean/Interview/Leetcode/Insertion Sort List.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     ListNode *insertionSortList(ListNode *head) {\n   12:         ListNode *curr, *next;\n   13:         ListNode *new_head = NULL, *pivot, *pre_pivot;\n   14          int inserted;\n   15          \n\n/Users/Sean/Sean/Interview/Leetcode/Intersection of Two Linked Lists.cpp:\n    1: //http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/\n    2  /**\n    3:  * Definition for singly-linked list.\n    4:  * struct ListNode {\n    5   *     int val;\n    6:  *     ListNode *next;\n    7:  *     ListNode(int x) : val(x), next(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n   13          int len_A = 0, len_B = 0;\n   14:         ListNode *curr, *long_one, *short_one;\n   15          int diff;\n   16  \n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PR:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/leetcode.SearchResults:\n    8  Evaluate Reverse Polish Notation.cpp:                || (tokens[i].compare(\"*\") == 0)\n    9  Evaluate Reverse Polish Notation.cpp:                || (tokens[i].compare(\"/\") == 0))\n   10: Merge k Sorted Lists.cpp://compare the min node for every list in one iteration\n   11  Two Sum.cpp:    static bool compare(const Node &left, const Node &right)\n   12  Two Sum.cpp:        sort(elements.begin(), elements.end(), compare);\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Linked List Cycle II.cpp:\n    1  //refer to the solution of : http://www.cnblogs.com/hiddenfox/p/3408931.html\n    2  /**\n    3:  * Definition for singly-linked list.\n    4:  * struct ListNode {\n    5   *     int val;\n    6:  *     ListNode *next;\n    7:  *     ListNode(int x) : val(x), next(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     ListNode *detectCycle(ListNode *head) {\n   13  \n   14:         ListNode *slow, *fast;\n   15          int cycle = 0;\n   16          if (!head || !head->next) return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Linked List Cycle.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     bool hasCycle(ListNode *head) {\n   12:         ListNode *slow, *fast;    \n   13          \n   14          if (!head || !head->next) return false;\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   42  \n   43  private:\n   44:     //we should use list instead of vector for 2 reasons.\n   45      //1. vector is continuous memory, insert() will reuslt in re-allocate a whole new memory (bad performance)\n   46      //2. memory re-allocate will cause the original key-value stored in m_map invalid.\n   47:     map<int, list<cache_entry>::iterator>m_map;\n   48      int m_capacity;\n   49:     list<cache_entry>m_LRU_cache;\n   50      \n   51  \n   52      void erase_key(int key)    \n   53      {\n   54:         list<cache_entry>::iterator it = m_map[key];\n   55          m_LRU_cache.erase(it);\n   56      }\n\n/Users/Sean/Sean/Interview/Leetcode/Merge k Sorted Lists.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9   #define MIN(a, b) ((a < b) ? (a) : (b))\n   10: //compare the min node for every list in one iteration\n   11  class Solution {\n   12  public:\n   13:     ListNode *mergeKLists(vector<ListNode *> &lists) {\n   14          \n   15          int min_index = -1;\n   16:         ListNode *head = NULL, *tail = NULL, *next;\n   17          int all_empty = 1;\n   18          int i;\n   19          \n   20:         if (lists.size() == 0)\n   21              return NULL;\n   22              \n   23          while (1)\n   24          {\n   25:             for (i = 0, min_index = -1, all_empty = 1; i < lists.size(); i++)\n   26              {\n   27:                 if (lists[i])                       \n   28                      all_empty = 0;\n   29                  else\n   ..\n   32                  if (min_index == -1)\n   33                      min_index = i;\n   34:                 else if (lists[i]->val < lists[min_index]->val)\n   35                      min_index = i;\n   36              }\n   ..\n   39                  break;\n   40                  \n   41:             next = lists[min_index]->next;\n   42              \n   43              if (!head)\n   44:                 head = tail = lists[min_index];\n   45              else\n   46:                 tail->next = lists[min_index];\n   47              \n   48:             tail = lists[min_index];\n   49              tail->next = NULL;    \n   50:             lists[min_index] = next;\n   51          }      \n   52          return head;\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Two Sorted Lists.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\n   12:         ListNode *head = NULL;\n   13:         ListNode *tail = NULL;\n   14          \n   15          if (!l1) return l2;\n   ..\n   18          while (l1 && l2)\n   19          {\n   20:             ListNode *min_node;\n   21              min_node = (l1->val < l2->val) ? (l1) : (l2);\n   22  \n\n/Users/Sean/Sean/Interview/Leetcode/Partition List.cpp:\n    3  public:        \n    4  \n    5:     ListNode *partition(ListNode *head, int x) {  \n    6          \n    7:         ListNode *curr = head, *pre_curr = NULL, *pre_pivot = NULL, *pivot = NULL;\n    8          \n    9          while (curr)\n   ..\n   24                  if (curr->val < x)\n   25                  {\n   26:                     ListNode *next = curr->next;\n   27                      curr->next = pivot;\n   28                      \n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted List II.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     ListNode *deleteDuplicates(ListNode *head) {\n   12:         ListNode *pivot = NULL, *pre_pivot = NULL, *curr = head;\n   13  \n   14          while (curr)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted List.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     ListNode *deleteDuplicates(ListNode *head) {\n   12:         ListNode *pivot = NULL, *curr = head;\n   13  \n   14          while (curr)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Nth Node From End of List.cpp:\n    1  class Solution {\n    2  public:\n    3:     ListNode *removeNthFromEnd(ListNode *head, int n) {\n    4              \n    5:             ListNode *target = head, *p = head, *pre = NULL;\n    6              \n    7              for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Reorder List.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     void doReorder(ListNode *&head, int num)\n   12      {\n   13:         ListNode *tail, *curr, *next;\n   14  \n   15          if (num == 0)\n   ..\n   41      }\n   42  \n   43:     void reorderList(ListNode *head) {\n   44:         ListNode *curr = head;\n   45          int num = 0;\n   46          while (curr)\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Linked List II.cpp:\n    1  class Solution {\n    2  public:\n    3:     //reverse the list with num elements\n    4:     int reverseList(ListNode *&head, int num)\n    5      {\n    6:         ListNode *pre= NULL, *next;\n    7:         ListNode *tail = NULL;\n    8  \n    9          if (!head)\n   ..\n   26      }\n   27  \n   28:     ListNode *reverseBetween(ListNode *head, int m, int n) {\n   29:         ListNode *pre = NULL;\n   30:         ListNode *reverse_head = head;\n   31  \n   32          if (!head) return NULL;\n   ..\n   38          }\n   39  \n   40:         reverseList(reverse_head, n-m+1);\n   41  \n   42          if (pre)\n\n/Users/Sean/Sean/Interview/Leetcode/Rotate List.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    .\n   10  class Solution {\n   11  public:\n   12:     ListNode *rotateRight(ListNode *head, int k) {\n   13          \n   14:         ListNode *pre_target = 0, *target = 0;\n   15:         ListNode *tail = 0, *temp = head;\n   16          int num = 0;\n   17          int i;\n\n/Users/Sean/Sean/Interview/Leetcode/Sort List.cpp:\n    1  /**\n    2:  * Definition for singly-linked list.\n    3:  * struct ListNode {\n    4   *     int val;\n    5:  *     ListNode *next;\n    6:  *     ListNode(int x) : val(x), next(NULL) {}\n    7   * };\n    8   */\n    .\n   11  public:\n   12  \n   13:     ListNode *merge(ListNode *first, ListNode *sec)\n   14      {\n   15:         ListNode *head = NULL, *tail = NULL;\n   16:         ListNode *min;\n   17  \n   18          if (!first) return sec;\n   ..\n   44      }\n   45  \n   46:     ListNode *mergeSort(ListNode **head, int num)\n   47      {\n   48:         ListNode *left, *right;\n   49  \n   50          if (num == 0)\n   ..\n   53          if (num == 1)\n   54          {\n   55:             ListNode *old_head = (*head);\n   56              //Important: we should make sure that head will advance. otherwise head will always the first element.\n   57              (*head) = (*head)->next;\n   ..\n   65      }\n   66  \n   67:     ListNode *sortList(ListNode *head) {\n   68  \n   69          int num = 0;\n   70:         ListNode *p = head;\n   71  \n   72          while (p)\n\n/Users/Sean/Sean/Interview/Leetcode/Subsets.cpp:\n    1  #if 1\n    2: //list all possible combinations\n    3  class Solution {\n    4  public:\n\n/Users/Sean/Sean/Interview/Leetcode/Swap Nodes in Pairs.cpp:\n    1  #if 1 //recursive version\n    2  /**\n    3:  * Definition for singly-linked list.\n    4:  * struct ListNode {\n    5   *     int val;\n    6:  *     ListNode *next;\n    7:  *     ListNode(int x) : val(x), next(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     ListNode *swapPairs(ListNode *head) {\n   13:         ListNode *new_head, *next;\n   14  \n   15          if (!head || !head->next)\n   ..\n   26  //iterative version, skip 2 nodes in every iteration.\n   27  /**\n   28:  * Definition for singly-linked list.\n   29:  * struct ListNode {\n   30   *     int val;\n   31:  *     ListNode *next;\n   32:  *     ListNode(int x) : val(x), next(NULL) {}\n   33   * };\n   34   */\n   35  class Solution {\n   36  public:\n   37:     ListNode *swapPairs(ListNode *head) {\n   38  \n   39:         ListNode *new_head = NULL, *new_tail = NULL;\n   40:         ListNode *curr = head, *pre = NULL, *next;\n   41  \n   42          if (!head || !head->next) return head;\n\n236 matches across 27 files\n\n\nSearching 155 files for \"[]\"\n\n/Users/Sean/Sean/Interview/Leetcode/Big Integer.cpp:\n   70  }\n   71  \n   72: int main(int argc, const char *argv[])\n   73  {\n   74      bigIntAdd(covertToBigInt(\"123456789012345678001234567\"), covertToBigInt(\"1\"));\n\n/Users/Sean/Sean/Interview/Leetcode/First Missing Positive.cpp:\n    8  class Solution {\n    9  public:\n   10:     int firstMissingPositive(int A[], int n) {\n   11  \n   12          int k;\n\n/Users/Sean/Sean/Interview/Leetcode/Generate N-digit number.cpp:\n   24  }\n   25  \n   26: int main(int argc, const char * argv[])\n   27  {\n   28      int n = 3;\n\n/Users/Sean/Sean/Interview/Leetcode/Jump Game.cpp:\n    2  class Solution {\n    3  public:\n    4:     bool canJump(int A[], int n) {\n    5          int jump_left = 0;\n    6          for (int i = 1; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Letter Combinations of a Phone Number.cpp:\n    4      void gen_string(string digits, string &curr_str, vector<string >&res)\n    5      {\n    6:         string table[] = {\"\", \" \", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    7              \n    8          int index;\n\n/Users/Sean/Sean/Interview/Leetcode/Maximum Product Subarray.cpp:\n    2  class Solution {\n    3  public:\n    4:     int maxProduct(int A[], int n) {\n    5          int min_temp;\n    6          int max_temp ;\n\n/Users/Sean/Sean/Interview/Leetcode/Maximum Subarray.cpp:\n    2  class Solution {\n    3  public:\n    4:     int maxSubArray(int A[], int n) {\n    5          int curr_sum = 0;\n    6          int max_sum = INT_MIN;\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   21          if (A[half_m] >= B[half_n])\n   22          {\n   23:             //half A[]: A[0] to A[half_m-1]\n   24:             //half B[]: B[0] to B[half_n]\n   25              if (half_m + half_n + 1 >= k)\n   26                  return findMedian(A, half_m, B, n, k);\n   ..\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41              return findMedian(A, m, B, n, (m + n)/2 + 1);\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Sorted Array.cpp:\n    2  class Solution {\n    3  public:\n    4:     void merge(int A[], int m, int B[], int n) {\n    5          \n    6          int end = m + n - 1;\n\n/Users/Sean/Sean/Interview/Leetcode/MergeSort.c:\n    1: void mergeSort(int numbers[], int temp[], int array_size)\n    2  {\n    3    m_sort(numbers, temp, 0, array_size - 1);\n    .\n    5   \n    6   \n    7: void m_sort(int numbers[], int temp[], int left, int right)\n    8  {\n    9    int mid;\n   ..\n   19  }\n   20   \n   21: void merge(int numbers[], int temp[], int left, int mid, int right)\n   22  {\n   23    int i, left_end, num_elements, tmp_pos;\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array II.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeDuplicates(int A[], int n) {\n    4          int repeat, num = 0;\n    5          for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeDuplicates(int A[], int n) {\n    4          int num = 0;\n    5          for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Element.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeElement(int A[], int n, int elem) {\n    4          \n    5          int num = 0;\n\n/Users/Sean/Sean/Interview/Leetcode/Search for a Range.cpp:\n    4  public:\n    5  \n    6:     int search_index(int A[], int left, int right, int target)\n    7      {\n    8          int mid = (left + right) >> 1;\n    .\n   18      }\n   19  \n   20:     vector<int> searchRange(int A[], int n, int target) {\n   21  \n   22          int index;\n   ..\n   48  class Solution {\n   49  public:\n   50:     vector<int> searchRange(int A[], int n, int target) {\n   51  \n   52          int left = 0, right = n-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array II.cpp:\n    2  public:\n    3  \n    4:     bool search(int A[], int n, int target) {\n    5          \n    6          int left = 0, right = n-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array.cpp:\n    2  public:\n    3  \n    4:     int search(int A[], int n, int target) {\n    5          \n    6          int left = 0, right = n-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Search Insert Position.cpp:\n    2  class Solution {\n    3  public:\n    4:     int searchInsert(int A[], int n, int target) {\n    5          int left = 0, right = n - 1;\n    6  \n\n/Users/Sean/Sean/Interview/Leetcode/Single Number II.cpp:\n    9  class Solution {\n   10  public:\n   11:     int singleNumber(int A[], int n) {\n   12          int num = 0;\n   13          for (int i = 0; i < 32; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Single Number.cpp:\n    1  class Solution {\n    2  public:\n    3:     int singleNumber(int A[], int n) {\n    4          int num = 0;\n    5          for (int i = 0; i < n; i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Sort Colors.cpp:\n   13          *b = temp;                                                                                                     \n   14      }                                                                                                                  \n   15:     void sortColors(int A[], int n) {                                                                                  \n   16                                                                                                                         \n   17          int red_idx = 0, blue_idx = n - 1;                                                                             \n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    6  class Solution {                                                                       \n    7  public:                                                                                \n    8:     int trap(int A[], int n) {                                                         \n    9          int total  = 0;                                                                \n   10          int *left  = new int[n];                                                       \n\n34 matches across 21 files\n\n\nSearching 155 files for \"[\"\n\n/Users/Sean/Sean/Interview/Leetcode/3Sum Closest.cpp:\n   11          for (int i = 0; i < size-2;)\n   12          {\n   13:             int temp_target = target - num[i];\n   14              for (int j = i+1, k = size-1; j < k;)\n   15              {\n   16:                 int temp_sum = num[j] + num[k];\n   17                  int temp_diff;\n   18                  \n   ..\n   24                  {\n   25                      min_diff = temp_diff;\n   26:                     sum = temp_sum + num[i];\n   27                  }   \n   28                  \n   ..\n   34              \n   35              i++;\n   36:             while (i < size-2 && num[i] == num[i-1]) i++;\n   37          }                \n   38          return sum;\n\n/Users/Sean/Sean/Interview/Leetcode/3Sum.cpp:\n   18              for (j = i+1, k = num.size()-1; j < k;)\n   19              {\n   20:                 int target = -num[i];\n   21:                 int sum    =  num[j] + num[k];\n   22                  if (sum == target)\n   23                  {\n   24:                     one_solution.push_back(num[i]);\n   25:                     one_solution.push_back(num[j]);\n   26:                     one_solution.push_back(num[k]);\n   27                      res.push_back(one_solution);\n   28                      one_solution.clear();\n   ..\n   30                      //skip repeating numbers.\n   31                      j++, k--;\n   32:                     while (j < k && num[j] == num[j-1]) j++;\n   33:                     while (j < k && num[k] == num[k+1]) k--;\n   34                  }\n   35                  else if (sum < target)\n   ..\n   41              //skip repeating numbers.\n   42              i++;\n   43:             while (i < num.size() && num[i] == num[i-1]) i++;\n   44          }\n   45          return res;\n\n/Users/Sean/Sean/Interview/Leetcode/4Sum.cpp:\n   20                  for (j = i+1, k = num.size()-1; j < k;)\n   21                  {\n   22:                     int sum = num[m] + num[i] + num[j] + num[k];\n   23                      if (sum == target)\n   24                      {\n   25:                         one_solution.push_back(num[m]);\n   26:                         one_solution.push_back(num[i]);\n   27:                         one_solution.push_back(num[j]);                    \n   28:                         one_solution.push_back(num[k]);                    \n   29                          res.push_back(one_solution);\n   30                          one_solution.clear();\n   ..\n   32                          //skip repeating numbers.\n   33                          j++, k--;\n   34:                         while (j < k && num[j] == num[j-1]) j++;\n   35:                         while (j < k && num[k] == num[k+1]) k--;\n   36                      }\n   37                      else if (sum < target)\n   ..\n   43                  //skip repeating numbers.\n   44                  i++;\n   45:                 while (i < num.size() && num[i] == num[i-1]) i++;\n   46              }\n   47              //skip repeating numbers.\n   48              m++;\n   49:             while (m < num.size() && num[m] == num[m-1]) m++;\n   50          }            \n   51          return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Add Binary.cpp:\n   11          while (i >= 0 || j >= 0)\n   12          {\n   13:             num_a = (i >= 0) ? (a[i] - '0') : 0;\n   14:             num_b = (j >= 0) ? (b[j] - '0') : 0;            \n   15              sum   = num_a^num_b^carry;\n   16              carry = (num_a&num_b) || (num_a&carry) || (num_b&carry);\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n   10          for (int i = 0; i < strs.size(); i++)\n   11          {\n   12:             string s = strs[i];\n   13              sort(s.begin(), s.end());\n   14              \n   15              if (anagram.find(s) == anagram.end())\n   16              {\n   17:                 anagram[s] = i;\n   18              }\n   19              else\n   20              {\n   21                  //if this anagram never output to res, output the first element of this anagram.\n   22:                 if (anagram[s] >= 0)\n   23                  {\n   24:                     res.push_back(strs[anagram[s]]);\n   25:                     anagram[s] = -1;\n   26                  }\n   27:                 res.push_back(strs[i]);\n   28              }\n   29          }            \n\n/Users/Sean/Sean/Interview/Leetcode/Best Time to Buy and Sell Stock II.cpp:\n    6          for (int i = 1; i < prices.size(); i++)\n    7          {\n    8:             if (prices[i] - prices[i-1] > 0)\n    9              {\n   10:                 sum += prices[i] - prices[i-1];\n   11              }\n   12          }\n\n/Users/Sean/Sean/Interview/Leetcode/Best Time to Buy and Sell Stock.cpp:\n    6          for (int i = 0; i < prices.size(); i++)\n    7          {\n    8:             if (prices[i] < min_price)\n    9:                 min_price = prices[i];\n   10:             if (prices[i] - min_price > max_diff)\n   11:                 max_diff = prices[i] - min_price;\n   12          }\n   13          return max_diff;\n\n/Users/Sean/Sean/Interview/Leetcode/Big Integer.cpp:\n   37          int num_a, num_b;\n   38  \n   39:         num_a = (first_idx >= size1) ? (0) : (num1[first_idx]);\n   40:         num_b = (sec_idx >= size2) ? (0) : (num2[sec_idx]);\n   41  \n   42          sum = num_a + num_b + carry;\n   ..\n   58      for (int i = res.size()-1; i >= 0; i--)\n   59      {\n   60:         char str[10];\n   61:         if (res[i] < (MAX_NUM + 1) && i != res.size()-1)\n   62          {\n   63:             sprintf(str,\"%09d\", res[i]);\n   64              printf(\"%s\", str);\n   65          }\n   66          else\n   67:             printf(\"%d\", res[i]);\n   68      }\n   69      printf(\"\\n\");\n   70  }\n   71  \n   72: int main(int argc, const char *argv[])\n   73  {\n   74      bigIntAdd(covertToBigInt(\"123456789012345678001234567\"), covertToBigInt(\"1\"));\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal II.cpp:\n   22          }\n   23      \n   24:         list[level].push_back(root->val);\n   25          genlevelOrder(root->left, list, level+1);\n   26          genlevelOrder(root->right, list, level+1);        \n   ..\n   38          //reveser the top-down result\n   39          for (int i = result.size() - 1; i >= 0; i--)\n   40:             reverse.push_back(result[i]);\n   41          return reverse;        \n   42      }\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal.cpp:\n   21          }\n   22      \n   23:         list[level].push_back(root->val);\n   24          genlevelOrder(root->left, list, level+1);\n   25          genlevelOrder(root->right, list, level+1);        \n\n/Users/Sean/Sean/Interview/Leetcode/Candy.cpp:\n    5      void adjust(vector<int> &candy, vector<int> &ratings, int start_index)\n    6      {\n    7:         int diff = 1 - candy[start_index];\n    8          int i;\n    9:         for (i = start_index; i > 0 && ratings[i-1] > ratings[i]; i--)\n   10          {\n   11:             candy[i] += diff;\n   12          }\n   13  \n   ..\n   15          //e.g. 1,2,1,0,-1: process \"2\"\n   16          if (diff > 0)\n   17:             candy[i] += diff;\n   18      }\n   19  \n   ..\n   29                  continue;\n   30              }\n   31:             else if (ratings[i] > ratings[i-1])\n   32              {\n   33:                 candy.push_back(candy[i-1]+1);\n   34              }\n   35:             else if (ratings[i] < ratings[i-1])\n   36              {\n   37:                 candy.push_back(candy[i-1]-1);\n   38              }\n   39:             //ratings[i] == ratings[i-1]\n   40              else\n   41                  candy.push_back(1);\n   42  \n   43:             if (i < ratings.size()-1 && ratings[i] < ratings[i-1] && ratings[i] <= ratings[i+1])\n   44                  adjust(candy, ratings, i);\n   45          }\n   ..\n   47  \n   48          for (int k = 0; k < candy.size(); k++)\n   49:             total += candy[k];\n   50  \n   51          return total;\n\n/Users/Sean/Sean/Interview/Leetcode/Clone Graph.cpp:\n   20          visit.push(node);\n   21  \n   22:         root = node_map[node] = new UndirectedGraphNode(node->label);\n   23  \n   24          while(!visit.empty())\n   ..\n   32              for (int i = 0; i < neighbor_num; i++)\n   33              {\n   34:                 UndirectedGraphNode *neighbor = curr_node->neighbors[i];\n   35                  if (node_map.find(neighbor) == node_map.end())\n   36                  {\n   37                      UndirectedGraphNode *new_node = new UndirectedGraphNode(neighbor->label);\n   38:                     node_map[neighbor] = new_node;\n   39                      visit.push(neighbor);\n   40                  }\n   41                  //store duplicate neighbor to duplicate curr_node\n   42:                 node_map[curr_node]->neighbors.push_back(node_map[neighbor]);\n   43              }\n   44          }\n   ..\n   55          if(!node)return node;\n   56          ///if this node is already created then just return the reference of the new node created earlier\n   57:         if(created.find(node)!=created.end())return created[node];\n   58          ///otherwise create a new node and mark corresponding node in original graph created.\n   59          UndirectedGraphNode * t=new UndirectedGraphNode(node->label);\n   60:         created[node]=t;\n   61          for(int i=0;i<node->neighbors.size();i++){\n   62              //do recursively for all its neighbors...:)\n   63:             t->neighbors.push_back(cloneGraph(node->neighbors[i]));\n   64          }\n   65          return t;\n\n/Users/Sean/Sean/Interview/Leetcode/Combination Sum II.cpp:\n   20          for (int i = start; i < candidates.size(); i++)\n   21          {\n   22:             solution.push_back(candidates[i]);\n   23:             *curr_sum += candidates[i];\n   24              \n   25              //difference between Combination Sum: (i to i+1)\n   26              do_combine(candidates, res, solution, target, curr_sum, i+1);\n   27:             *curr_sum -= candidates[i];\n   28              solution.pop_back();\n   29              \n   30              //difference between Combination Sum: skip the repeating elements\n   31:             while (i < candidates.size() - 1 && candidates[i] == candidates[i+1])\n   32                  i++;\n   33          }\n\n/Users/Sean/Sean/Interview/Leetcode/Combination Sum.cpp:\n   20          for (int i = start; i < candidates.size(); i++)\n   21          {\n   22:             solution.push_back(candidates[i]);\n   23:             *curr_sum += candidates[i];\n   24              do_combine(candidates, res, solution, target, curr_sum, i);\n   25:             *curr_sum -= candidates[i];\n   26              solution.pop_back();\n   27          }\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Inorder and Postorder Traversal.cpp:\n   24              return NULL;\n   25  \n   26:         root_val = postorder[post_end];\n   27          root = new TreeNode(root_val);\n   28  \n   ..\n   32  \n   33          for (root_pos = in_start; root_pos <= in_end; root_pos++)\n   34:             if (inorder[root_pos] == root_val)\n   35                  break;\n   36          left_num = root_pos - in_start;\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Preorder and Inorder Traversal.cpp:\n   22              return NULL;\n   23  \n   24:         root_val = preorder[pre_start];\n   25          root = new TreeNode(root_val);\n   26          //base condition\n   ..\n   29  \n   30          for (root_pos = in_start; root_pos <= in_end; root_pos++)\n   31:             if (inorder[root_pos] == root_val)\n   32                  break;\n   33  \n\n/Users/Sean/Sean/Interview/Leetcode/Container With Most Water.cpp:\n    9          while (left < right)\n   10          {\n   11:             int min_height = MIN(height[left], height[right]);\n   12              int area = min_height * (right - left);\n   13              \n   ..\n   15                  max_area = area;\n   16              \n   17:             if (min_height == height[left])\n   18                  left++;\n   19              else \n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted Array to Binary Search Tree.cpp:\n   21  \n   22          left = buildBST(num, start, mid-1);\n   23:         parent = new TreeNode(num[mid]);\n   24          parent->left = left;\n   25          right = buildBST(num, mid+1, end);\n\n/Users/Sean/Sean/Interview/Leetcode/Count and Say.cpp:\n    4      {\n    5          int count = 1;\n    6:         char curr_char = str[0];\n    7:         char buf[100];\n    8          string res;\n    9  \n   10          for (int j = 1; j < str.size(); j++)\n   11          {\n   12:             if (curr_char == str[j])\n   13                  count++;\n   14              else\n   ..\n   18                  res.append(1, curr_char);\n   19  				count = 1;\n   20: 				curr_char = str[j];\n   21              }\n   22          }\n\n/Users/Sean/Sean/Interview/Leetcode/Decode Ways.cpp:\n    1: /*Dynamic programming: if s[i] is valid, f(i) += f(i-1)\n    2:                        if (s[i-1], s[i]) pair is valid, f(i) += f(i-2)\n    3  */                       \n    4  class Solution {\n    .\n   24          \n   25          if (len == 0) return 0;\n   26:         if (len == 1) return check(s[0]);\n   27          \n   28:         fn_1 = check(s[0]); // f(n-1) == f(1)\n   29          fn_2 = 1;           // f(n-2) == f(0)\n   30          \n   ..\n   33              fn = 0; \n   34              \n   35:             if (check(s[i]))\n   36                  fn += fn_1;\n   37:             if (check(s[i-1], s[i]))\n   38                  fn += fn_2;\n   39                  \n\n/Users/Sean/Sean/Interview/Leetcode/Evaluate Reverse Polish Notation.cpp:\n   26          for (int i = 0; i < tokens.size(); i++)\n   27          {\n   28:             if ((tokens[i].compare(\"+\") == 0)\n   29:                 || (tokens[i].compare(\"-\") == 0)\n   30:                 || (tokens[i].compare(\"*\") == 0)\n   31:                 || (tokens[i].compare(\"/\") == 0))\n   32:                 compute(stk, tokens[i]);\n   33              else\n   34:                 stk.push(atoi(tokens[i].c_str()));    \n   35          }\n   36          return stk.top();\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array II.cpp:\n    9              int mid = (left + right) >> 1;\n   10  \n   11:             if (num[left] < num[right])\n   12:                 return num[left];\n   13  \n   14:             if (num[mid] > num[left])\n   15                  left = mid+1;\n   16:             else if (num[mid] < num[right])\n   17                  right = mid;\n   18              else\n   19              {\n   20:                 if (num[left] == num[mid])\n   21                      left++;\n   22:                 else if (num[right] == num[mid])\n   23                      right--;\n   24              }\n   25          }\n   26:         return num[left];\n   27      }\n   28  };\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array.cpp:\n    5          int left = 0, right = num.size()-1;\n    6  \n    7:         //notice: this is \"<\" instead of \"<=\". We compare num[left] < num[right] so left cannot be equal to right.\n    8          while (left < right)\n    9          {\n   10              int mid = (left + right) >> 1;\n   11  \n   12:             //left is move right sequtially. So, the first num[left] less than num[right] is the minimun one.\n   13:             if (num[left] < num[right])\n   14:                 return num[left];\n   15:             if (num[mid] >= num[left])\n   16                  left = mid + 1;\n   17              else\n   ..\n   19  \n   20          }\n   21:         return num[left];\n   22      }\n   23  };\n\n/Users/Sean/Sean/Interview/Leetcode/First Missing Positive.cpp:\n    1  //http://fisherlei.blogspot.tw/2012/12/leetcode-first-missing-positive.html\n    2  /*\n    3: The answer is positive integer. So, arrange the original array to A[0]=1, A[1]=2,... A[i]=i+1\n    4  \n    5: [-2, -1, 0, 5, 6] => answer: 1\n    6: [-2, 0, 1, 5, 8] => answer: 2\n    7  */\n    8  class Solution {\n    9  public:\n   10:     int firstMissingPositive(int A[], int n) {\n   11  \n   12          int k;\n   ..\n   14          for (int i = 0; i < n; i++)\n   15          {\n   16:             //0 <= A[i] - 1 < n, if A[i]-1 is valid index, make A[A[i]-1] == A[i]\n   17:             while (A[i] >= 1 && A[i]-1 < n && A[A[i]-1] != A[i])\n   18              {\n   19:                 swap(A[i], A[A[i]-1]);\n   20              }\n   21          }\n   ..\n   23          for (k = 0; k < n; k++)\n   24          {\n   25:             if (A[k] != k+1)\n   26                  return k+1;\n   27          }\n\n/Users/Sean/Sean/Interview/Leetcode/Gas Station.cpp:\n   10          int total_sum = 0;\n   11          for (int i = 0; i < diff.size(); i++)\n   12:             diff[i] = gas[i] - cost[i];\n   13  \n   14          for (int i = 0; i < diff.size(); i++)\n   15          {\n   16:             curr_sum += diff[i];\n   17:             total_sum += diff[i];\n   18              if (curr_sum < 0)\n   19              {\n\n/Users/Sean/Sean/Interview/Leetcode/Generate N-digit number.cpp:\n    4      for (int i = 0; i < num.size(); i++)\n    5      {\n    6:         if (!start && num[i] != '0')\n    7              start = 1;\n    8          if (start)\n    9:             printf(\"%c\", num[i]);\n   10      }\n   11      printf(\"\\n\");\n   ..\n   16      for (int i = 0; i < 10; i++)\n   17      {\n   18:         num[index] = i + '0';\n   19          if (index == n-1)\n   20              printNum(num);\n   ..\n   24  }\n   25  \n   26: int main(int argc, const char * argv[])\n   27  {\n   28      int n = 3;\n\n/Users/Sean/Sean/Interview/Leetcode/Gray Code.cpp:\n    9          for (int j = 0; j < n; j++)\n   10              for (int i = res.size()-1; i >= 0; i--)\n   11:                 res.push_back(res[i] | (1 << j));\n   12  \n   13          return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Implement strStr().cpp:\n   21              for (j = 0, k = i; j < n_len; j++, k++)\n   22              {\n   23:                 if (haystack[k] != needle[j])\n   24                      break;\n   25              }\n\n/Users/Sean/Sean/Interview/Leetcode/Jump Game.cpp:\n    2  class Solution {\n    3  public:\n    4:     bool canJump(int A[], int n) {\n    5          int jump_left = 0;\n    6          for (int i = 1; i < n; i++)\n    7          {\n    8:             //jump_left means the number of remaning jump when arriving at A[i].\n    9:             //So, jump_left at A[i] is the max(A[i-1], jump_left at A[i-1]) - 1\n   10:             jump_left = max(A[i-1], jump_left) - 1;\n   11              if (jump_left < 0)\n   12                  return false;\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.IMB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PFI:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PR:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PRI:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/leetcode.SearchResults:\n    4  Evaluate Reverse Polish Notation.cpp:        else if (comp_type.compare(\"*\") == 0)\n    5  Evaluate Reverse Polish Notation.cpp:        else if (comp_type.compare(\"/\") == 0)\n    6: Evaluate Reverse Polish Notation.cpp:            if ((tokens[i].compare(\"+\") == 0)\n    7: Evaluate Reverse Polish Notation.cpp:                || (tokens[i].compare(\"-\") == 0)\n    8: Evaluate Reverse Polish Notation.cpp:                || (tokens[i].compare(\"*\") == 0)\n    9: Evaluate Reverse Polish Notation.cpp:                || (tokens[i].compare(\"/\") == 0))\n   10  Merge k Sorted Lists.cpp://compare the min node for every list in one iteration\n   11  Two Sum.cpp:    static bool compare(const Node &left, const Node &right)\n\n/Users/Sean/Sean/Interview/Leetcode/leetcode.sublime-project:\n    1  {\n    2  	\"folders\":\n    3: 	[\n    4  		{\n    5  			\"follow_symlinks\": true,\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Length of Last Word.py:\n    9              return 0;\n   10          else:\n   11:             return len(word[-1]);\n   12  \n\n/Users/Sean/Sean/Interview/Leetcode/Letter Combinations of a Phone Number.cpp:\n    4      void gen_string(string digits, string &curr_str, vector<string >&res)\n    5      {\n    6:         string table[] = {\"\", \" \", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    7              \n    8          int index;\n    9          \n   10          //'0' is NULL. That means end of string.\n   11:         if (digits.size() == 0 || digits[0] == '0')\n   12          {\n   13              res.push_back(curr_str);\n   ..\n   15          }\n   16          \n   17:         index = digits[0]-'0';\n   18          \n   19:         for (int i = 0; i < table[index].size(); i++)\n   20          {\n   21:             curr_str.append(1, table[index][i]);\n   22              gen_string(digits.substr(1), curr_str, res);\n   23              curr_str.erase(curr_str.size()-1, 1);\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Common Prefix.cpp:\n    9          \n   10          if (strs.size () == 1)\n   11:             return strs[0];\n   12          \n   13:         for (int j = 0; j < strs[0].size(); j++)   \n   14          {\n   15              for (int i = 1; i < strs.size(); i++)\n   16              {\n   17:                 if (j >= strs[i].size() || strs[i][j] != strs[0][j])\n   18                      return LCP;\n   19              }\n   20:             LCP.append(1, strs[0][j]);\n   21          }            \n   22          return LCP;\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Consecutive Sequence.cpp:\n    8          \n    9          for (int i = 0; i < num.size(); i++)\n   10:             hash_table[num[i]] = 1;\n   11              \n   12          for (int i = 0; i < num.size(); i++)\n   13          {\n   14:             int target = num[i] + 1;\n   15              \n   16              count = 1;\n   17              \n   18:             while (hash_table.count(target) && hash_table[target])\n   19              {\n   20:                 hash_table[target] = 0;\n   21                  count++;\n   22                  target++;\n   23              }\n   24  \n   25:             target = num[i] - 1;\n   26:             while (hash_table.count(target) && hash_table[target])\n   27              {\n   28:                 hash_table[target] = 0;\n   29                  count++;\n   30                  target--;\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Palindromic Substring.cpp:\n    3      string longestPalindrome(string s) {\n    4      \n    5:         char table[1000][1000] = {0};\n    6          int max_len = 0;\n    7          int start_index;\n    .\n   10          for (i = 0; i < s.size(); i++)\n   11          {\n   12:             table[i][i] = 1;\n   13              max_len = 1;\n   14              start_index = i;\n   ..\n   17          for (i = 0; i < s.size() - 1; i++)\n   18          {\n   19:             if (s[i] == s[i+1])\n   20              {\n   21:                 table[i][i+1] = 1;\n   22                  max_len = 2;\n   23                  start_index = i;\n   ..\n   28              for (i = 0; i < s.size() - (len-1); i++)\n   29              {\n   30:                 if (table[i+1][i+len-2] == 1 && s[i] == s[i+len-1])\n   31                  {\n   32:                     table[i][i+len-1] = 1;\n   33                      if (len > max_len)\n   34                      {\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Substring Without Repeating Characters.cpp:\n    4      \n    5          int max_len = 0;\n    6:         char letter[256] = {0};\n    7          int len;\n    8          \n    .\n   10          {\n   11              memset(letter, 0, 256);\n   12:             letter[s[i]] = 1;\n   13              len = 1;\n   14              for (int j = i+1; j < s.size(); j++)\n   15              {\n   16:                 if (letter[s[j]])\n   17                      break;\n   18                  else\n   19                  {\n   20:                     letter[s[j]] = 1;\n   21                      len++;\n   22                  }\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Valid Parentheses.cpp:\n   14          for (int i = 0; i < s.size(); i++)\n   15          {\n   16:             if (s[i] == '(')\n   17              {\n   18                  if (left_index == -1)\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   17          else                    \n   18          {\n   19:             int value = m_map[key]->value;\n   20              erase_key(key);\n   21              insert_to_head(key, value);\n   ..\n   52      void erase_key(int key)    \n   53      {\n   54:         list<cache_entry>::iterator it = m_map[key];\n   55          m_LRU_cache.erase(it);\n   56      }\n   ..\n   59          cache_entry cache(key, value);\n   60          m_LRU_cache.insert(m_LRU_cache.begin(), cache);\n   61:         m_map[key] = m_LRU_cache.begin();\n   62      }\n   63  };\n\n/Users/Sean/Sean/Interview/Leetcode/Max Points on a Line.cpp:\n   19          {\n   20              int duplicate;\n   21:             //the initial value of duplicate is 1 because point[i] itself should be counted.\n   22              duplicate = 1;\n   23              slope.clear();\n   24              //case: points only has one point.\n   25:             slope[INT_MIN] = 0;\n   26              for (int j = i+1; j < points.size(); j++)\n   27              {\n   28:                 if (points[i].x == points[j].x && points[i].y == points[j].y)\n   29                  {\n   30                      duplicate++;\n   ..\n   32                  }\n   33  \n   34:                 if (points[i].x == points[j].x)\n   35:                     slope[INT_MAX]++;\n   36                  else\n   37                  {\n   38:                     float curr_slope = (float)(points[i].y - points[j].y) / (float)(points[i].x - points[j].x);\n   39:                     slope[curr_slope]++;\n   40                  }\n   41              }\n   ..\n   43              for (;it != slope.end(); it++)\n   44              {\n   45:                 //count the duplicate number of points[i]\n   46                  max_num = max(max_num, it->second+duplicate);\n   47              }\n\n/Users/Sean/Sean/Interview/Leetcode/Maximum Product Subarray.cpp:\n    2  class Solution {\n    3  public:\n    4:     int maxProduct(int A[], int n) {\n    5          int min_temp;\n    6          int max_temp ;\n    .\n   10              return 0;\n   11          else if (n == 1)\n   12:             return A[0];\n   13  \n   14:         min_temp = A[0];\n   15:         max_temp = A[0];\n   16:         max_product = A[0];\n   17  \n   18          for (int i = 1; i < n; i++)\n   19          {\n   20:             int a = min_temp*A[i];\n   21:             int b = max_temp*A[i];\n   22  \n   23:             min_temp = min(min(a, b), A[i]);\n   24:             max_temp = max(max(a, b), A[i]);\n   25              if (max_temp > max_product)\n   26                  max_product = max_temp;\n\n/Users/Sean/Sean/Interview/Leetcode/Maximum Subarray.cpp:\n    2  class Solution {\n    3  public:\n    4:     int maxSubArray(int A[], int n) {\n    5          int curr_sum = 0;\n    6          int max_sum = INT_MIN;\n    7          for (int i = 0; i < n; i++)\n    8          {\n    9:             curr_sum += A[i];\n   10  \n   11              if (curr_sum > max_sum)\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   11          \n   12          if (m == 0)\n   13:             return B[k-1];\n   14              \n   15          if (n == 0)\n   16:             return A[k-1];\n   17          \n   18          if (k <= 1)    \n   19:             return MIN(A[0], B[0]);\n   20              \n   21:         if (A[half_m] >= B[half_n])\n   22          {\n   23:             //half A[]: A[0] to A[half_m-1]\n   24:             //half B[]: B[0] to B[half_n]\n   25              if (half_m + half_n + 1 >= k)\n   26                  return findMedian(A, half_m, B, n, k);\n   ..\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41              return findMedian(A, m, B, n, (m + n)/2 + 1);\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Intervals.cpp:\n   48          vector<Interval>res;\n   49          for (int i = 0; i < intervals.size(); i++)\n   50:             insert(res, intervals[i]);\n   51          return res;\n   52      }\n\n/Users/Sean/Sean/Interview/Leetcode/Merge k Sorted Lists.cpp:\n   25              for (i = 0, min_index = -1, all_empty = 1; i < lists.size(); i++)\n   26              {\n   27:                 if (lists[i])                       \n   28                      all_empty = 0;\n   29                  else\n   ..\n   32                  if (min_index == -1)\n   33                      min_index = i;\n   34:                 else if (lists[i]->val < lists[min_index]->val)\n   35                      min_index = i;\n   36              }\n   ..\n   39                  break;\n   40                  \n   41:             next = lists[min_index]->next;\n   42              \n   43              if (!head)\n   44:                 head = tail = lists[min_index];\n   45              else\n   46:                 tail->next = lists[min_index];\n   47              \n   48:             tail = lists[min_index];\n   49              tail->next = NULL;    \n   50:             lists[min_index] = next;\n   51          }      \n   52          return head;\n\n/Users/Sean/Sean/Interview/Leetcode/Merge Sorted Array.cpp:\n    2  class Solution {\n    3  public:\n    4:     void merge(int A[], int m, int B[], int n) {\n    5          \n    6          int end = m + n - 1;\n    .\n    9          for (i = m-1, j = n-1; (i >= 0 && j >= 0);)\n   10          {\n   11:             if (A[i] >= B[j])\n   12              {\n   13:                 A[end--] = A[i];\n   14                  i--;\n   15              }\n   16              else\n   17              {\n   18:                 A[end--] = B[j];\n   19                  j--;\n   20              }\n   ..\n   22              \n   23          while (j >= 0)\n   24:             A[end--] = B[j--];\n   25      }\n   26  };\n\n/Users/Sean/Sean/Interview/Leetcode/MergeSort.c:\n    1: void mergeSort(int numbers[], int temp[], int array_size)\n    2  {\n    3    m_sort(numbers, temp, 0, array_size - 1);\n    .\n    5   \n    6   \n    7: void m_sort(int numbers[], int temp[], int left, int right)\n    8  {\n    9    int mid;\n   ..\n   19  }\n   20   \n   21: void merge(int numbers[], int temp[], int left, int mid, int right)\n   22  {\n   23    int i, left_end, num_elements, tmp_pos;\n   ..\n   29    while ((left <= left_end) && (mid <= right))\n   30    {\n   31:     if (numbers[left] <= numbers[mid])\n   32      {\n   33:       temp[tmp_pos] = numbers[left];\n   34        tmp_pos = tmp_pos + 1;\n   35        left = left +1;\n   ..\n   37      else\n   38      {\n   39:       temp[tmp_pos] = numbers[mid];\n   40        tmp_pos = tmp_pos + 1;\n   41        mid = mid + 1;\n   ..\n   45    while (left <= left_end)\n   46    {\n   47:     temp[tmp_pos] = numbers[left];\n   48      left = left + 1;\n   49      tmp_pos = tmp_pos + 1;\n   ..\n   51    while (mid <= right)\n   52    {\n   53:     temp[tmp_pos] = numbers[mid];\n   54      mid = mid + 1;\n   55      tmp_pos = tmp_pos + 1;\n   ..\n   58    for (i=0; i <= num_elements; i++)\n   59    {\n   60:     numbers[right] = temp[right];\n   61      right = right - 1;\n   62    }\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Path Sum.cpp:\n    8              return 0;\n    9  \n   10:         n = grid[0].size();\n   11  \n   12          for (int i = 1; i < n; i++)\n   13:             grid[0][i] += grid[0][i-1];\n   14  \n   15          for (int i = 1; i < m; i++)\n   16:             grid[i][0] += grid[i-1][0];\n   17  \n   18          for (int i = 1; i < m; i++)\n   19              for (int j = 1; j < n; j++)\n   20              {\n   21:                 grid[i][j] += std::min(grid[i][j-1], grid[i-1][j]);\n   22              }\n   23  \n   24:         return grid[m-1][n-1];\n   25      }\n   26  };\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Window Substring.cpp:\n    8      string minWindow(string S, string T) {\n    9  \n   10:         int T_table[256] = {0};\n   11:         int S_table[256] = {0};\n   12          int match_num = 0;\n   13          int min_len = -1;\n   ..\n   18  \n   19          for (int i = 0; i < T.size(); i++)\n   20:             T_table[T[i]]++;\n   21  \n   22          for (right = 0, left = 0; right < S.size(); right++)\n   ..\n   25              if (match_num != T.size())\n   26              {\n   27:                 if (S_table[S[right]] < T_table[S[right]])\n   28                      match_num++;\n   29  \n   30:                 S_table[S[right]]++;\n   31              }\n   32  \n   ..\n   35              {\n   36                  //drop the chararcter which exists in S but not in T, i. e. increase left to reduce the length between (left, right).\n   37:                 while (S_table[S[left]] > T_table[S[left]])\n   38                  {\n   39:                          S_table[S[left]]--;\n   40                           left++;\n   41                  }\n   ..\n   48  \n   49                  //increase left to find the next possible solution.\n   50:                 S_table[S[left]]--;\n   51                  match_num--;\n   52                  left++;\n\n/Users/Sean/Sean/Interview/Leetcode/Multiply Strings.cpp:\n   14          for (int i = 0; i < total_digits-1; i++)\n   15          {     \n   16:             int sum = remain[i];\n   17  \n   18              /*\n   19:                 res[0] = num1[0]*num2[0]\n   20:                 res[1] = num1[1]*num2[0] + num1[0]*num2[1]\n   21:                 res[2] = num1[2]*num2[0] + num1[1]*num2[1] + num1[0]*num2[2]\n   22              */\n   23              for (int j = i; j >= 0; j--)\n   ..\n   26                  if (j < num1.size() && 0 <= num2_index && num2_index < num2.size())\n   27                  {\n   28:                     sum += (num1[j]-'0')*(num2[num2_index]-'0');\n   29                  }\n   30              }\n   31              res.push_back(sum%10 + '0');\n   32:             remain[i+1] = sum / 10;\n   33          }\n   34:         if (remain[total_digits-1])\n   35:             res.push_back(remain[total_digits-1]+'0');\n   36              \n   37          reverse(res.begin(), res.end());\n   38:         if (res[0] == '0')\n   39          {                        \n   40              res.clear();\n\n/Users/Sean/Sean/Interview/Leetcode/N-Queens II.cpp:\n    7          for (int i = 0; i < one_sol.size(); i++)\n    8          {\n    9:             if (col == one_sol[i] || (row-i) == abs(one_sol[i]-col))\n   10                  return 0;\n   11          }\n\n/Users/Sean/Sean/Interview/Leetcode/N-Queens.cpp:\n    1  //http://yucoding.blogspot.tw/2013/01/leetcode-question-59-n-queens.html\n    2: //one_sol[i] = j,  means put a queen at (row, col) = (i, j)\n    3  class Solution {\n    4  public:\n    .\n    8          for (int i = 0; i < one_sol.size(); i++)\n    9          {\n   10:             if (col == one_sol[i] || (row-i) == abs(one_sol[i]-col))\n   11                  return 0;\n   12          }\n   ..\n   43          {\n   44              one_answer.clear();\n   45:             for (int j = 0; j < res[i].size(); j++)\n   46              {\n   47                  string str(n, '.');\n   48:                 str[res[i][j]] = 'Q';\n   49                  one_answer.push_back(str);\n   50              }\n\n/Users/Sean/Sean/Interview/Leetcode/Next Permutation.cpp:\n   14          for (int i = size - 2; i >= 0; i--)\n   15          {\n   16:             if (num[i] < num[i+1])\n   17              {\n   18                  partition_idx = i;\n   ..\n   26              for (int i = size - 1; i >= 0; i--)\n   27              {\n   28:                 if (num[i] > num[partition_idx])\n   29                  {\n   30                      change_idx = i;\n   ..\n   37          if (partition_idx != -1 && change_idx != -1)\n   38          {\n   39:             temp = num[partition_idx];\n   40:             num[partition_idx] = num[change_idx];\n   41:             num[change_idx] = temp;\n   42          }\n   43          \n   ..\n   45          for (int i = partition_idx + 1, j = size -1; i < j; i++, j--)\n   46          {\n   47:             temp   = num[i];\n   48:             num[i] = num[j];\n   49:             num[j] = temp;\n   50          }\n   51      }\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning II.cpp:\n    6          int len = s.size();\n    7          vector<int>min_cut(len+1, 0);\n    8:         bool P[len+1][len+1];\n    9          \n   10          for (int i = 0; i <= len; i++)\n   11:             min_cut[i] = len - i;\n   12      \n   13          for (int i = 0; i < len; i++ )\n   14              for (int j = 0; j < len; j++)                    \n   15:                 P[i][j] = false;\n   16          \n   17          for (int i = len-1; i >= 0; i--)\n   18              for (int j = i; j < len; j++)\n   19              {\n   20:                 if (s[i] == s[j] && (j - i <= 2 || P[i+1][j-1]))\n   21                  {\n   22:                     P[i][j] = true;\n   23:                     min_cut[i] = min(min_cut[i], min_cut[j+1]+1);\n   24                  }\n   25              }\n   26                          \n   27:         return min_cut[0]-1;\n   28      } \n   29  };\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n    7          while (start < end)\n    8          {\n    9:             if (s[start] != s[end])\n   10                  return false;\n   11              start++, end--;\n\n/Users/Sean/Sean/Interview/Leetcode/Pascal's Triangle II.cpp:\n   17              for (int j = i; j > 0 ; j--)\n   18              {\n   19:                 res[j] = res[j] + res[j-1];\n   20              }\n   21              res.push_back(1);\n\n/Users/Sean/Sean/Interview/Leetcode/Pascal's Triangle.cpp:\n   12                      one_sol.push_back(1);\n   13                  else\n   14:                     one_sol.push_back(res[res.size()-1][j]+res[res.size()-1][j-1]);\n   15              }\n   16              res.push_back(one_sol);\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   15          for (int i = 0; i < num.size(); i++)\n   16          {\n   17:             if (selected[i] || duplicate.find(num[i]) != duplicate.end())\n   18                  continue;\n   19                  \n   20:             duplicate[num[i]] = 1;\n   21:             selected[i] = 1;\n   22:             one_sol.push_back(num[i]);\n   23              do_permute(num, res, one_sol, selected);\n   24              one_sol.pop_back();\n   25:             selected[i] = 0;\n   26          }\n   27          return;\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations.cpp:\n   12          for (int i = 0; i < num.size(); i++)\n   13          {\n   14:             if (selected[i])\n   15                  continue;\n   16:             selected[i] = 1;\n   17:             one_sol.push_back(num[i]);\n   18              do_permute(num, res, one_sol, selected);\n   19              one_sol.pop_back();\n   20:             selected[i] = 0;\n   21          }\n   22          return;\n\n/Users/Sean/Sean/Interview/Leetcode/Plus One.cpp:\n   10          for (int i = digits.size() - 1; i >= 0; i--)\n   11          {\n   12:             int sum = digits[i] + carry;\n   13              \n   14              res.insert(res.begin(), 1, sum%10);\n\n/Users/Sean/Sean/Interview/Leetcode/Quicksort.c:\n    5      if (left >= right) { return; }\n    6  \n    7:     pivot = data[left];\n    8  \n    9      i = left + 1;\n   ..\n   14          while (i <= right)\n   15          {\n   16:             if (data[i] > pivot)\n   17              {\n   18                  break;\n   ..\n   24          while (j > left)\n   25          {\n   26:             if (data[j] < pivot)\n   27              {\n   28                  break;\n   ..\n   34          if (i > j) { break; }\n   35  \n   36:         swap(&data[i], &data[j]);\n   37      }\n   38  \n   39:     swap(&data[left], &data[j]);\n   40  \n   41      quicksort(data, left, j - 1);\n\n/Users/Sean/Sean/Interview/Leetcode/Regular Expression Matching.cpp:\n   19              return false;\n   20          \n   21:         while (s[i] && p[j])\n   22          {\n   23              //current match\n   24:             if (s[i] == p[j] || p[j] == '.')                    \n   25              {\n   26:                 if (p[j+1] == '*')\n   27                  {\n   28                      //do not match the current '*'\n   ..\n   42              else\n   43              {\n   44:                 if (p[j+1] == '*')\n   45                  {\n   46                      //do not match the current '*'\n   ..\n   56          \n   57          //skip the last \".*\" to EOS\n   58:         while (p[j] && p[j+1] == '*')\n   59              j += 2;\n   60          \n   61:         if (!s[i] && !p[j])\n   62              return true;\n   63          else\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array II.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeDuplicates(int A[], int n) {\n    4          int repeat, num = 0;\n    5          for (int i = 0; i < n; i++)\n    6          {\n    7:             if (i == 0 || A[i] != A[i-1])\n    8              {\n    9:                 A[num++] = A[i];\n   10                  repeat = 1;\n   11              }              \n   ..\n   14                  if (repeat == 1)\n   15                  {\n   16:                     A[num++] = A[i];\n   17                      repeat = 2;\n   18                  }\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeDuplicates(int A[], int n) {\n    4          int num = 0;\n    5          for (int i = 0; i < n; i++)\n    6          {\n    7:             if (i == 0 || A[i] != A[i-1])\n    8              {\n    9:                 A[num++] = A[i];\n   10              }                \n   11          }\n\n/Users/Sean/Sean/Interview/Leetcode/Remove Element.cpp:\n    1  class Solution {\n    2  public:\n    3:     int removeElement(int A[], int n, int elem) {\n    4          \n    5          int num = 0;\n    .\n    7          {\n    8              //only keep the non-elem elements\n    9:             if (A[i] != elem)\n   10:                 A[num++] = A[i];                \n   11          }\n   12          return num;\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Words in a String.cpp:\n    9          {\n   10              char temp;\n   11:             temp = s[i];\n   12:             s[i] = s[j];\n   13:             s[j] = temp;\n   14          }\n   15      }\n   ..\n   37          for (int i = 0; i < s.size(); i++)\n   38          {\n   39:             if (s[i] != ' ')\n   40              {\n   41                  string str;\n   42  \n   43                  start = i;\n   44:                 while (s[i] != ' ' && i < s.size())\n   45                      i++;\n   46  \n   ..\n   50  \n   51                  for (int k = 0; k < str.size();)\n   52:                     s[write_pos++] = str[k++];\n   53:                 s[write_pos++] = ' ';\n   54              }\n   55          }\n\n/Users/Sean/Sean/Interview/Leetcode/Search a 2D Matrix.cpp:\n    9              return false;\n   10  \n   11:         if (target < matrix[0][0])\n   12              return false;\n   13  \n   ..\n   15          {\n   16              mid = (left + right) >> 1;\n   17:             if (matrix[mid][0] == target)\n   18                  return true;\n   19:             else if (matrix[mid][0] < target)\n   20                  left = mid + 1;\n   21              else\n   ..\n   25          row = right;\n   26          left = 0;\n   27:         right = matrix[row].size() - 1;\n   28  \n   29          while (left <= right)\n   30          {\n   31              mid = (left + right) >> 1;\n   32:             if (matrix[row][mid] == target)\n   33                  return true;\n   34:             else if (matrix[row][mid] < target)\n   35                  left = mid + 1;\n   36              else\n\n/Users/Sean/Sean/Interview/Leetcode/Search for a Range.cpp:\n    4  public:\n    5  \n    6:     int search_index(int A[], int left, int right, int target)\n    7      {\n    8          int mid = (left + right) >> 1;\n    .\n   10          if (left > right)\n   11              return -1;\n   12:         if (A[mid] == target)\n   13              return mid;\n   14:         else if (A[mid] > target)\n   15              return search_index(A, left, mid-1, target);\n   16          else\n   ..\n   18      }\n   19  \n   20:     vector<int> searchRange(int A[], int n, int target) {\n   21  \n   22          int index;\n   ..\n   29          if (index != -1)\n   30          {\n   31:             for (first_idx = index; first_idx >= 1 && A[first_idx-1] == target; first_idx--)\n   32                  ;\n   33  \n   34:             for (last_idx = index; last_idx < n-1 && A[last_idx+1] == target; last_idx++)\n   35                  ;\n   36  \n   ..\n   48  class Solution {\n   49  public:\n   50:     vector<int> searchRange(int A[], int n, int target) {\n   51  \n   52          int left = 0, right = n-1;\n   ..\n   59              int mid = (left + right) >> 1;\n   60  \n   61:             if (A[mid] == target)\n   62              {\n   63:                 for (first_idx = mid; first_idx >= 1 && A[first_idx-1] == target; first_idx--)\n   64                      ;\n   65  \n   66:                 for (last_idx = mid; last_idx < n-1 && A[last_idx+1] == target; last_idx++)\n   67                      ;\n   68                  break;\n   69              }\n   70:             else if (A[mid] > target)\n   71                  right = mid - 1;\n   72              else\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array II.cpp:\n    2  public:\n    3  \n    4:     bool search(int A[], int n, int target) {\n    5          \n    6          int left = 0, right = n-1;\n    .\n   14              mid = (left + right) >> 1;\n   15              \n   16:             if (A[mid] == target)\n   17                  return true;\n   18:             if (A[left] == target)\n   19                  return true;\n   20:             if (A[right] == target)\n   21                  return true;\n   22             \n   23              //skip the duplicate number. only add this \"equal condition\" as compared to Search in Rotated Sorted Array\n   24:             if (A[mid] == A[left])\n   25              {\n   26                  left++;\n   27              }\n   28:             //consider A[mid] in the left_region or right_region\n   29:             else if (A[mid] > A[left])\n   30              {\n   31                  //consider target in the ascending region or not\n   32:                 if (A[left] < target && target < A[mid])\n   33                      right = mid - 1;\n   34                  else\n   ..\n   38              {\n   39                  //consider target in the ascending region or not\n   40:                 if (A[mid] < target && target < A[right])\n   41                      left = mid + 1;\n   42                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array.cpp:\n    2  public:\n    3  \n    4:     int search(int A[], int n, int target) {\n    5          \n    6          int left = 0, right = n-1;\n    .\n   14              mid = (left + right) >> 1;\n   15              \n   16:             if (A[mid] == target)\n   17                  return mid;\n   18:             if (A[left] == target)\n   19                  return left;\n   20:             if (A[right] == target)\n   21                  return right;\n   22             \n   23:             //consider A[mid] in the left_region or right_region\n   24:             if (A[mid] >= A[left])\n   25              {\n   26                  //consider target in the ascending region or not\n   27:                 if (A[left] < target && target < A[mid])\n   28                      right = mid - 1;\n   29                  else\n   ..\n   33              {\n   34                  //consider target in the ascending region or not\n   35:                 if (A[mid] < target && target < A[right])\n   36                      left = mid + 1;\n   37                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Search Insert Position.cpp:\n    2  class Solution {\n    3  public:\n    4:     int searchInsert(int A[], int n, int target) {\n    5          int left = 0, right = n - 1;\n    6  \n    .\n    9              int mid = (left + right) >> 1;\n   10  \n   11:             if (A[mid] == target)\n   12                  return mid;\n   13:             else if (A[mid] < target)\n   14                  left = mid + 1;\n   15              else\n\n/Users/Sean/Sean/Interview/Leetcode/Set Matrix Zeroes Total.cpp:\n    6          int first_col_zero = 0;\n    7          int row = matrix.size();\n    8:         int col = matrix[0].size();\n    9  \n   10          //store each row/col zero information in the first row/col.\n   11          for (int i = 0; i < col; i++)\n   12:             if (matrix[0][i] == 0)\n   13                  first_row_zero = 1;\n   14  \n   15          for (int i = 0; i < row; i++)\n   16:             if (matrix[i][0] == 0)\n   17                  first_col_zero = 1;\n   18  \n   ..\n   20              for (int j = 0; j < col; j++)\n   21              {\n   22:                 if (matrix[i][j] == 0)\n   23                  {\n   24:                     matrix[i][0] = 0;\n   25:                     matrix[0][j] = 0;\n   26                  }\n   27              }\n   ..\n   30              for (int j = 1; j < col; j++)\n   31              {\n   32:                 if (matrix[i][0] == 0 || matrix[0][j] == 0)\n   33:                     matrix[i][j] = 0;\n   34              }\n   35  \n   ..\n   37          {\n   38              for (int i = 0; i < col; i++)\n   39:                 matrix[0][i] = 0;\n   40          }\n   41  \n   ..\n   43          {\n   44              for (int i = 0; i < row; i++)\n   45:                 matrix[i][0] = 0;\n   46          }\n   47      }\n\n/Users/Sean/Sean/Interview/Leetcode/Single Number II.cpp:\n    9  class Solution {\n   10  public:\n   11:     int singleNumber(int A[], int n) {\n   12          int num = 0;\n   13          for (int i = 0; i < 32; i++)\n   ..\n   16              for (int j = 0; j < n; j++)\n   17              {\n   18:                 bit += (A[j] >> i) & 1;\n   19              }\n   20              num += (bit % 3) << i;\n\n/Users/Sean/Sean/Interview/Leetcode/Single Number.cpp:\n    1  class Solution {\n    2  public:\n    3:     int singleNumber(int A[], int n) {\n    4          int num = 0;\n    5          for (int i = 0; i < n; i++)\n    6:             num ^= A[i];\n    7          return num;            \n    8      }\n\n/Users/Sean/Sean/Interview/Leetcode/Sort Colors.cpp:\n   13          *b = temp;                                                                                                     \n   14      }                                                                                                                  \n   15:     void sortColors(int A[], int n) {                                                                                  \n   16                                                                                                                         \n   17          int red_idx = 0, blue_idx = n - 1;                                                                             \n   ..\n   22          while (i <= blue_idx)                                                                                          \n   23          {                                                                                                              \n   24:             if (A[i] == 0)                                                                                             \n   25              {                                                                                                          \n   26:                 swap(&A[i], &A[red_idx]);                                                                              \n   27                  red_idx++;                                                                                             \n   28:                 i++; // i can do i++ because afte swap, A[i] must be 1.                                                \n   29              }                                                                                                          \n   30:             else if (A[i] == 2)                                                                                        \n   31              {                                                                                                          \n   32:                 swap(&A[i], &A[blue_idx]);                                                                             \n   33:                 blue_idx--; // i cannot do i++ because after swap, A[i] may be 0 then A[i] should be swap again.       \n   34              }                                                                                                          \n   35              else                                                                                                       \n\n/Users/Sean/Sean/Interview/Leetcode/String to Integer (atoi).cpp:\n    7          int negative = 0;\n    8          \n    9:         for (int i = 0; str[i]; i++)\n   10          {\n   11              if (start)\n   12              {\n   13:                 if ('0' <= str[i] && str[i] <= '9')\n   14                  {\n   15:                     res = res*10 + str[i] - '0';\n   16                      if (negative && res - 1 > INT_MAX)\n   17                          return INT_MIN;\n   ..\n   24              else\n   25              {\n   26:                 if (str[i] == ' ')\n   27                      continue;\n   28:                 else if (str[i] == '-')\n   29                  {\n   30                      negative = 1;\n   31                      start = 1;\n   32                  }\n   33:                 else if (str[i] == '+')\n   34                  {\n   35                      start = 1;\n   36                  }\n   37:                 else if ('0' <= str[i] && str[i] <= '9')\n   38                  {\n   39                      start = 1;\n   40:                     res = res*10 + str[i] - '0';\n   41                  }\n   42                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Subsets II.cpp:\n    6          for (int i = start; i < S.size(); i++)\n    7          {\n    8:             one_comb.push_back(S[i]);\n    9              res.push_back(one_comb);\n   10              do_combine(S, one_comb, res, i+1);\n   11              one_comb.pop_back();\n   12              \n   13:             while (i < S.size() - 1 && S[i] == S[i+1])\n   14                  i++;\n   15          }\n\n/Users/Sean/Sean/Interview/Leetcode/Subsets.cpp:\n    8          for (int i = start; i < S.size(); i++)\n    9          {\n   10:             one_comb.push_back(S[i]);\n   11              res.push_back(one_comb);\n   12              do_combine(S, res, one_comb, i+1);\n   ..\n   44          for (int i = start; i < S.size(); i++)\n   45          {\n   46:             one_comb.push_back(S[i]);\n   47              if (one_comb.size() == num)\n   48              {\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n   12          if (!L_num) return res;\n   13          \n   14:         each_size = L[0].size();\n   15          \n   16          //create map table for each stirng in L\n   17          for (int i = 0; i < L_num; i++)       \n   18:             L_table[L[i]]++;\n   19                     \n   20  \n   21          //create map table for each stirng in L. \n   22:         //L[i] may be repeating so we should use addition to record the corresponding count.\n   23          for (i = 0; i < (int)S.size() - (each_size*L_num-1); i++)            \n   24          {\n   ..\n   32                  else\n   33                  {\n   34:                     match_count[substr]++;\n   35:                     if (match_count[substr] > L_table[substr])\n   36                          break;\n   37                  }\n\n/Users/Sean/Sean/Interview/Leetcode/Surrounded Regions.cpp:\n    9          //check up: ROW 0 has been checked. So, no need to check the \"up\" direction for ROW 1.\n   10          //So, start from ROW 2.\n   11:         if (start_row >= 2 && board[start_row-1][start_col] == 'O')\n   12          {\n   13:             board[start_row-1][start_col] = '#';\n   14              dfs(board, start_row-1, start_col, row, col);\n   15          }\n   ..\n   17          //check down: ROW row-1  has been checked. So, no need to check the \"down\" direction for ROW row-2.\n   18          //So, start from ROW row-3.\n   19:         if (start_row <= row-3 && board[start_row+1][start_col] == 'O')\n   20          {\n   21:             board[start_row+1][start_col] = '#';\n   22              dfs(board, start_row+1, start_col, row, col);\n   23          }\n   ..\n   25          //check left: COL 0  has been checked. So, no need to check the \"left\" direction for COL 1.\n   26          //So, start from COL 2.\n   27:         if (start_col >= 2 && board[start_row][start_col-1] == 'O')\n   28          {\n   29:             board[start_row][start_col-1] = '#';\n   30              dfs(board, start_row, start_col-1, row, col);\n   31          }\n   ..\n   33          //check right: COL col-1  has been checked. So, no need to check the \"right\" direction for COL col-2.\n   34          //So, start from COL col-3.\n   35:         if (start_col <= col-3 && board[start_row][start_col+1] == 'O')\n   36          {\n   37:             board[start_row][start_col+1] = '#';\n   38              dfs(board, start_row, start_col+1, row, col);\n   39          }\n   ..\n   48          if (row <= 2)\n   49              return;\n   50:         col = board[0].size();\n   51          if (col <= 2)\n   52              return;\n   ..\n   55          for (int i = 0; i < col; i++)\n   56          {\n   57:             if (board[0][i] == 'O')\n   58              {\n   59:                 board[0][i] = '#';\n   60                  dfs(board, 0, i, row, col);\n   61              }\n   ..\n   65          for (int i = 0; i < col; i++)\n   66          {\n   67:             if (board[row-1][i] == 'O')\n   68              {\n   69:                 board[row-1][i] = '#';\n   70                  dfs(board, row-1, i, row, col);\n   71              }\n   ..\n   75          for (int i = 1; i < row-1; i++)\n   76          {\n   77:             if (board[i][0] == 'O')\n   78              {\n   79:                 board[i][0] = '#';\n   80                  dfs(board, i, 0, row, col);\n   81              }\n   ..\n   85          for (int i = 1; i < row-1; i++)\n   86          {\n   87:             if (board[i][col-1] == 'O')\n   88              {\n   89:                 board[i][col-1] = '#';\n   90                  dfs(board, i, col-1, row, col);\n   91              }\n   ..\n   95              for (int j = 0; j < col; j++)\n   96              {\n   97:                 if (board[i][j] == 'O')\n   98:                     board[i][j] = 'X';\n   99:                 else if (board[i][j] == '#')\n  100:                     board[i][j] = 'O';\n  101              }\n  102      }\n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    1: //The area for each A[i]                                                               \n    2: //1. find the max height of the left of A[i], call it A_left_max[i]                    \n    3: //2. find the max height of the right of A[i], call it A_right_max[i]                  \n    4: //3. area of A[i] = (min(A_left_max[i], A_right_max[i]) - A[i])*1                      \n    5  #define MIN(a, b) ((a < b) ? (a) : (b))                                                \n    6  class Solution {                                                                       \n    7  public:                                                                                \n    8:     int trap(int A[], int n) {                                                         \n    9          int total  = 0;                                                                \n   10:         int *left  = new int[n];                                                       \n   11:         int *right = new int[n];                                                       \n   12          int max, area;                                                                 \n   13                                                                                         \n   14          if (n == 0) return 0;                                                          \n   15                                                                                         \n   16:         for (int i = 0, max = A[0]; i < n; i++)                                        \n   17          {                                                                              \n   18:             if (max < A[i])                                                            \n   19:                 max = A[i];                                                            \n   20:             left[i] = max;                                                             \n   21          }                                                                              \n   22                                                                                         \n   23:         for (int i = n-1, max = A[n-1]; i >= 0; i--)                                   \n   24          {                                                                              \n   25:             if (max < A[i])                                                            \n   26:                 max = A[i];                                                            \n   27:             right[i] = max;                                                            \n   28                                                                                         \n   29:             //Once left[i] and right[i] are all obtained, we can calculate area of A[i]\n   30:             area = MIN(left[i], right[i]) - A[i];                                      \n   31              if (area > 0)                                                              \n   32                  total += area;                                                         \n\n/Users/Sean/Sean/Interview/Leetcode/Triangle.cpp:\n    8  \n    9          for (int i = triangle.size()-2; i >= 0; i--)\n   10:             for (int j = 0; j < triangle[i].size(); j++)\n   11              {\n   12:                 triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);\n   13              }\n   14:         return triangle.empty() ? 0 : triangle[0][0];\n   15      }\n   16  };\n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   24          for(int i =0; i< numbers.size(); i++)  \n   25          {  \n   26:              elements.push_back(Node(numbers[i], i));  \n   27          }  \n   28          \n   ..\n   31          for (int i = 0, j = numbers.size()-1; i < j;)\n   32          {\n   33:             int sum = elements[i].val + elements[j].val;     \n   34              if (sum == target)\n   35              {\n   36:                 if (elements[i].index < elements[j].index)\n   37                  {\n   38:                     res.push_back(elements[i].index+1);\n   39:                     res.push_back(elements[j].index+1);                \n   40                  }\n   41                  else\n   42                  {\n   43:                     res.push_back(elements[j].index+1);\n   44:                     res.push_back(elements[i].index+1);                \n   45                  }\n   46                  break;\n   ..\n   67          \n   68          for (i = 0; i < numbers.size(); i++)\n   69:             hash_table[numbers[i]] = i;\n   70              \n   71          for (i = 0; i < numbers.size(); i++)                        \n   72          {\n   73:             int diff = target - numbers[i];\n   74:             if (hash_table.find(diff) != hash_table.end() && hash_table[diff] != i)\n   75              {\n   76                  res.push_back(i+1);\n   77:                 res.push_back(hash_table[diff]+1);\n   78                  break;\n   79              }\n\n/Users/Sean/Sean/Interview/Leetcode/Unique Binary Search Trees II.cpp:\n   31                  {\n   32                      TreeNode *root = new TreeNode(i);\n   33:                     root->left = left[j];\n   34:                     root->right = right[k];\n   35                      res.push_back(root);\n   36                  }\n\n/Users/Sean/Sean/Interview/Leetcode/Unique Paths II.cpp:\n    3      int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\n    4          int row = obstacleGrid.size();\n    5:         int col = obstacleGrid[0].size();\n    6          vector<int>count (col, 0);\n    7  \n    .\n    9              return 0;\n   10  \n   11:         count[0] = !obstacleGrid[0][0];\n   12  \n   13          for (int i = 0; i < row; i++)\n   14              for (int j = 0; j < col; j++)\n   15              {\n   16:                 //reset current count[j] to zero when encountering obstacle.\n   17:                 if (obstacleGrid[i][j] == 1)\n   18:                     count[j] = 0;\n   19                  else\n   20                  {\n   21                      if (j > 0)\n   22:                         count[j] += count[j-1];\n   23                  }\n   24              }\n   25:         return count[col-1];\n   26      }\n   27  };\n\n/Users/Sean/Sean/Interview/Leetcode/Unique Paths.cpp:\n    5          vector<int> count(n, 0);\n    6          \n    7:         count[0] = 1;\n    8          \n    9          for (int i = 0; i < m; i++)\n   10              for (int j = 1; j < n; j++)\n   11:                 count[j] += count[j-1];\n   12:         return count[n-1];                \n   13      }\n   14  };\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Number.cpp:\n   21  \n   22  \n   23:         for (i = 0; str[i]; pre = str[i], i++)\n   24          {\n   25:             if (isdigit(str[i]))\n   26              {\n   27                  num_flag = 1;\n   ..\n   36                  if (i && (pre == '.'))\n   37  				{\n   38: 					if (str[i] == 'e' && num_flag)\n   39  					{\n   40  					    scientific_flag++;\n   ..\n   47  				    return false;\n   48  \n   49:                 if (str[i] == ' ')\n   50                      return false;\n   51: 				if (str[i] == '-' || str[i] == '+' )\n   52  				{\n   53: 				    if ((isdigit(str[i+1]) || str[i+1] == '.') && !num_flag)\n   54  				        continue;\n   55  				    return false;\n   56  				}\n   57:                 if (str[i] == '.')\n   58                  {\n   59                      if (float_flag)\n   ..\n   64                  }\n   65  \n   66:                 if (str[i] == 'e' && !scientific_flag)\n   67                  {\n   68                      if (!num_flag)\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Palindrome.cpp:\n    8          for (int i = 0, j = s.size()-1; i <= j; i++, j--)\n    9          {\n   10:             while (!isalnum(s[i]) && i <= j)\n   11                  i++;\n   12:             while (!isalnum(s[j]) && i <= j)\n   13                  j--;\n   14  \n   15              if (i > j) break;\n   16  \n   17:             if (tolower(s[i]) != tolower(s[j]))\n   18                  return false;\n   19          }\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Parentheses.cpp:\n    6          for (int i = 0; i < s.size(); i++)\n    7          {\n    8:             if (s[i] == '{' || s[i] == '[' || s[i] == '(')\n    9:                 stk.push(s[i]);\n   10:             else if ((s[i] == '}' && stk.size() > 0 && stk.top() == '{')\n   11:                      || (s[i] == ']' && stk.size() > 0 && stk.top() == '[')\n   12:                      || (s[i] == ')' && stk.size() > 0 && stk.top() == '('))\n   13                  stk.pop();\n   14              else\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Sudoku.cpp:\n   10              {\n   11                  int row, col;\n   12:                 if (board[i][j] != '.' && ++check[0][board[i][j]-'1'] > 1) return false;\n   13:                 if (board[j][i] != '.' && ++check[1][board[j][i]-'1'] > 1) return false;\n   14  \n   15                  row = j/3 + 3*(i/3);\n   16                  col = j%3 + 3*(i%3);\n   17:                 if (board[row][col] != '.' && ++check[2][board[row][col]-'1'] > 1) return false;\n   18              }\n   19  \n   20              for (int k = 0; k < 3; k++)\n   21:                 check[k].assign(9, 0);\n   22          }\n   23          return true;\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp:\n    1  //http://fisherlei.blogspot.tw/2013/11/leetcode-wordbreak-ii-solution.html\n    2  //like combination or permuation solution using recursive.\n    3: //need add short cut: possible[i]: 1: there exists solution from index i to s.size()\n    4  //                                 0: no solution from index i to s.size()\n    5  class Solution {\n    .\n   17          {\n   18              string str = s.substr(start, i-start+1);\n   19:             //if s[0] to s[i] is matched, then do recursive on remaining sub string.\n   20:             if (dict.find(str) != dict.end() && possible[i+1])\n   21              {\n   22                  int pre_size = res.size();\n   ..\n   32                  //no new solution inserted\n   33                  if (pre_size == res.size())\n   34:                     possible[i+1] = 0;\n   35              }\n   36          }\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break.cpp:\n    7          vector<bool> hit(len, false);\n    8          \n    9:         hit[0] = true;\n   10          \n   11          for (int i = 1; i < len; i++)\n   12              for (int k = 0; k < i ; k++)\n   13              {\n   14:                 hit[i] = hit[k] && (dict.find(s2.substr(k+1, i-k)) != dict.end());\n   15:                 if (hit[i]) break;\n   16              }\n   17:         return hit[len-1];            \n   18      }\n   19  };\n\n/Users/Sean/Sean/Interview/Leetcode/Word Ladder.cpp:\n    8  \n    9          words.push(start);\n   10:         distance_map[start] = 1;\n   11          dict.erase(start);\n   12  \n   ..\n   15              string str = words.front();\n   16              words.pop();\n   17:             distance = distance_map[str];\n   18  \n   19              for (int i = 0; i < str.size(); i++)\n   20              {\n   21                  //backup to restore\n   22:                 char org = str[i];\n   23                  for (char c = 'a'; c <= 'z'; c++)\n   24                  {\n   25:                     if (str[i] == c)\n   26                          continue;\n   27  \n   28:                     str[i] = c;\n   29  \n   30                      if (str == end)\n   ..\n   34                      {\n   35                          words.push(str);\n   36:                         distance_map[str] = distance+1;\n   37                          //important!! To avoid dupilcate str inserted into queue<string>words.\n   38                          //Remove the hit str in the dictionary.\n   ..\n   40                      }\n   41                  }\n   42:                 str[i] = org;\n   43              }\n   44          }\n\n/Users/Sean/Sean/Interview/Leetcode/Word Search.cpp:\n   18          if (str.size()==0){return true;}\n   19          else{\n   20:             if ((i>0)&&(board[i-1][j]==str[0])&&(mask[i-1][j]==false)){\n   21:                 mask[i-1][j]=true;\n   22                  if (search(board,i-1,j,str.substr(1),mask)){\n   23                      return true;\n   24                  }\n   25:                 mask[i-1][j]=false;\n   26              }\n   27:             if ((i<board.size()-1)&&(board[i+1][j]==str[0])&&(mask[i+1][j]==false)){\n   28:                 mask[i+1][j]=true;\n   29                  if (search(board,i+1,j,str.substr(1),mask)){\n   30                      return true;\n   31                  }\n   32:                 mask[i+1][j]=false;\n   33              }\n   34:             if ((j>0)&&(board[i][j-1]==str[0])&&(mask[i][j-1]==false)){\n   35:                 mask[i][j-1]=true;\n   36                  if (search(board,i,j-1,str.substr(1),mask)){\n   37                      return true;\n   38                  }\n   39:                 mask[i][j-1]=false;\n   40              }\n   41:             if ((j<board[0].size()-1)&&(board[i][j+1]==str[0])&&(mask[i][j+1]==false)){\n   42:                 mask[i][j+1]=true;\n   43                  if (search(board,i,j+1,str.substr(1),mask)){\n   44                      return true;\n   45                  }\n   46:                 mask[i][j+1]=false;\n   47              }\n   48          }\n   ..\n   56               \n   57          for (int i=0;i<board.size();i++){\n   58:             for (int j=0;j<board[0].size();j++){\n   59:                 if (word[0]==board[i][j]){\n   60                      if (word.size()==1) {return true;}\n   61                      else{\n   62:                         vector<vector<bool> > mask(board.size(),vector<bool>(board[0].size(),false));\n   63:                         mask[i][j]=true;\n   64                          if (search(board,i,j,word.substr(1),mask)){\n   65                              return true;\n\n/Users/Sean/Sean/Interview/Leetcode/ZigZag Conversion.cpp:\n   15          for (int i = 0; i < nRows && i < s.size(); i++)\n   16          {\n   17:             res.append(1, s[i]);\n   18              j = i;\n   19              k = 1;\n   ..\n   34  \n   35                  if (j < s.size())\n   36:                     res.append(1, s[j]);\n   37                  else\n   38                      break;\n\n/Users/Sean/Downloads/ac.cpp:\n    5          if(row <= 1)\n    6              return;\n    7:         int col = board[0].size();\n    8          if(col <= 1)\n    9              return;\n   ..\n   13          for(int i=0;i<col;i++)\n   14          {\n   15:             if(board[0][i] == 'O')\n   16              {\n   17:                 board[0][i] = '#';\n   18                  dfs(board, 0, i, row, col);\n   19              }\n   ..\n   22          for(int i=0;i<col;i++)\n   23          {\n   24:             if(board[row-1][i] == 'O')\n   25              {\n   26:                 board[row-1][i] = '#';\n   27                  dfs(board, row-1, i, row, col);\n   28              }\n   ..\n   31          for(int i=1;i<row-1;i++)\n   32          {\n   33:             if(board[i][0] == 'O')\n   34              {\n   35:                 board[i][0] = '#';\n   36                  dfs(board, i, 0, row, col);\n   37              }\n   ..\n   40          for(int i=1;i<row-1;i++)\n   41          {\n   42:             if(board[i][col-1] == 'O')\n   43              {\n   44:                 board[i][col-1] = '#';\n   45                  dfs(board, i, col-1, row, col);\n   46              }\n   ..\n   51              for(int j=0;j<col;j++)\n   52              {\n   53:                 if(board[i][j] == 'O')\n   54:                     board[i][j] = 'X';\n   55:                 else if(board[i][j] == '#')\n   56:                     board[i][j] = 'O';\n   57              }\n   58      }\n   ..\n   60      void dfs(vector<vector<char>> &board, int i, int j, int row, int col)\n   61      {\n   62:         if(i > 0 && board[i-1][j] == 'O')\n   63          {\n   64:             board[i-1][j] = '#';\n   65              dfs(board, i-1, j, row, col);\n   66          }\n   67:         if(i < row-2 && board[i+1][j] == 'O')   \n   68          {\n   69:             board[i+1][j] = '#';\n   70              dfs(board, i+1, j, row, col);\n   71          }\n   72:         if(j > 0 && board[i][j-1] == 'O')\n   73          {\n   74:             board[i][j-1] = '#';\n   75              dfs(board, i, j-1, row, col);\n   76          }\n   77:         if(j < col-2 && board[i][j+1] == 'O')\n   78          {\n   79:             board[i][j+1] = '#';\n   80              dfs(board, i, j+1, row, col);\n   81          }\n\n<untitled 4048>:\n    9  vector<int>table;\n   10  \n   11: table[0].assign(table[0].size(), 0);\n\n856 matches across 104 files\n\n\nSearching 155 files for \"genNum\"\n\n/Users/Sean/Sean/Interview/Leetcode/Generate N-digit number.cpp:\n   12  }\n   13  \n   14: void genNum(vector<char> &num, int index, int n)\n   15  {\n   16      for (int i = 0; i < 10; i++)\n   ..\n   20              printNum(num);\n   21          else\n   22:             genNum(num, index+1, n);\n   23      }\n   24  }\n   ..\n   28      int n = 3;\n   29      vector<char> num(n, '0');\n   30:     genNum(num, 0, n);\n   31  \n   32  }\n\n3 matches in 1 file\n\n\nSearching 155 files for \"treeNode\"\n\n/Users/Sean/Sean/Interview/Leetcode/Balanced Binary Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   13      \n   14      //-1: not balanced. otherwise: the depth\n   15:     int getDepth(TreeNode *root)\n   16      {\n   17          int left, right;\n   ..\n   31      }\n   32      \n   33:     bool isBalanced(TreeNode *root) {\n   34          return (getDepth(root) == -1) ? (false) : (true);\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Inorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     vector<int> inorderTraversal(TreeNode *root) {\n   14          vector<int>left, right;\n   15  \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal II.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   14      {\n   15          if (!root) return -1;\n   ..\n   28      }\n   29  \n   30:     vector<vector<int> > levelOrderBottom(TreeNode *root) {\n   31          vector<vector<int> >result, reverse;\n   32          \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   13      {\n   14          if (!root) return -1;\n   ..\n   27      }\n   28  \n   29:     vector<vector<int> > levelOrder(TreeNode *root) {\n   30          vector<vector<int> >res;\n   31          res.clear();\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Maximum Path Sum.cpp:\n    2  /**\n    3   * Definition for binary tree\n    4:  * struct TreeNode {\n    5   *     int val;\n    6:  *     TreeNode *left;\n    7:  *     TreeNode *right;\n    8:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    9   * };\n   10   */\n   ..\n   14      //1. return value: the max value whose ending point is root. This return value can be used by the parent of current root.\n   15      //2. max_val is current max value.\n   16:     int computeMax(TreeNode *root, int &max_val)\n   17      {\n   18          int max_left, max_right;\n   ..\n   46      }\n   47  \n   48:     int maxPathSum(TreeNode *root)\n   49      {\n   50          int max_val = INT_MIN;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Postorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     vector<int> postorderTraversal(TreeNode *root) {\n   15:         stack<TreeNode*> s;\n   16:         TreeNode *top_node, *popped = 0;\n   17          vector<int>res;\n   18  \n   ..\n   54  public:\n   55  \n   56:     vector<int> postorderTraversal(TreeNode *root) {\n   57          vector<int>left, right;\n   58          int i;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Preorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     vector<int> preorderTraversal(TreeNode *root) {\n   15  \n   16:         stack<TreeNode*> s;\n   17:         TreeNode *top_node;\n   18          vector<int>res;\n   19  \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Zigzag Level Order Traversal.cpp:\n    2  /**\n    3   * Definition for binary tree\n    4:  * struct TreeNode {\n    5   *     int val;\n    6:  *     TreeNode *left;\n    7:  *     TreeNode *right;\n    8:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    9   * };\n   10   */\n   ..\n   12  public:\n   13  \n   14:     vector<vector<int> > zigzagLevelOrder(TreeNode *root) {\n   15          vector<vector<int> >res;\n   16          vector<int>one_sol;\n   17          //use stack to store the next level node,\n   18          //such that ordering of the next level is reverse to that of the current level.\n   19:         stack<TreeNode *>next_stk, curr_stk;\n   20          int right_to_left = 1;\n   21  \n   ..\n   27          while (!curr_stk.empty())\n   28          {\n   29:             TreeNode *top = curr_stk.top();\n   30              one_sol.push_back(top->val);\n   31  \n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Inorder and Postorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     TreeNode *genBST(vector<int> &inorder, int in_start, int in_end, vector<int> &postorder, int post_start, int post_end)\n   13      {\n   14:         TreeNode *root, *left, *right;\n   15          int root_val;\n   16          int root_pos;\n   ..\n   25  \n   26          root_val = postorder[post_end];\n   27:         root = new TreeNode(root_val);\n   28  \n   29          //base condition\n   ..\n   42      }\n   43  \n   44:     TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\n   45          if (inorder.size() == 0 || postorder.size() == 0)\n   46              return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Preorder and Inorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12      //find the root position first. Then generate left/right tree recursively.\n   13:     TreeNode *genBST(vector<int> &preorder, int pre_start, int pre_end, vector<int> &inorder, int in_start, int in_end)\n   14      {\n   15:         TreeNode *root, *left, *right;\n   16          int root_val;\n   17          int root_pos;\n   ..\n   23  \n   24          root_val = preorder[pre_start];\n   25:         root = new TreeNode(root_val);\n   26          //base condition\n   27          if (pre_start == pre_end)\n   ..\n   41      }\n   42  \n   43:     TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n   44          if (preorder.size() == 0 || inorder.size() == 0)\n   45              return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted Array to Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12      //note: the first param should use \"&\" (called by reference),\n   13      // if not using \"&\" (i. e. call by value) will cause memory limit exceeding\n   14:     TreeNode *buildBST(vector<int> &num, int start, int end)\n   15      {\n   16:         TreeNode *left, *right, *parent;\n   17          int mid = (start + end) >> 1;\n   18  \n   ..\n   21  \n   22          left = buildBST(num, start, mid-1);\n   23:         parent = new TreeNode(num[mid]);\n   24          parent->left = left;\n   25          right = buildBST(num, mid+1, end);\n   ..\n   28      }\n   29  \n   30:     TreeNode *sortedArrayToBST(vector<int> &num) {\n   31          return buildBST(num, 0, num.size()-1);\n   32      }\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted List to Binary Search Tree.cpp:\n    9  /**\n   10   * Definition for binary tree\n   11:  * struct TreeNode {\n   12   *     int val;\n   13:  *     TreeNode *left;\n   14:  *     TreeNode *right;\n   15:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n   16   * };\n   17   */\n   18  class Solution {\n   19  public:\n   20:     TreeNode *buildBST(ListNode *&head, int start, int end)\n   21      {\n   22:         TreeNode *left, *right, *parent;\n   23          int mid;\n   24          \n   ..\n   31          left = buildBST(head, start, mid-1);\n   32          \n   33:         parent = new TreeNode(head->val);\n   34          parent->left = left;\n   35          \n   ..\n   42      }\n   43      \n   44:     TreeNode *sortedListToBST(ListNode *head) {\n   45          \n   46          ListNode *p = head;\n\n/Users/Sean/Sean/Interview/Leetcode/Flatten Binary Tree to Linked List.cpp:\n    4  class Solution {\n    5  public:\n    6:     void build(TreeNode *root, TreeNode *&tmp)\n    7      {\n    8          if(root)\n    .\n   16          }\n   17      }\n   18:     void flatten(TreeNode *root) {\n   19          // Start typing your C/C++ solution below\n   20          // DO NOT write int main() function\n   21:         TreeNode *tmp=NULL;\n   22          build(root, tmp);\n   23  \n   ..\n   29  \n   30      //leaf: the last node in preorder after do_flatten\n   31:     void do_flatten(TreeNode *&root, TreeNode *&leaf)\n   32      {\n   33:         TreeNode *left_leaf, *right_leaf;\n   34  \n   35          if (!root)\n   ..\n   62  \n   63  \n   64:     void flatten(TreeNode *root) {\n   65:         TreeNode *leaf;\n   66          do_flatten(root, leaf);\n   67      }\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Maximum Depth of Binary Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     int maxDepth(TreeNode *root) {\n   13          \n   14          int left_depth, right_depth;\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Depth of Binary Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  class Solution {\n   12  public:\n   13:     int minDepth(TreeNode *root) {\n   14  \n   15          int left_min, right_min;\n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   30      }\n   31      \n   32:     vector<vector<int> > pathSum(TreeNode *root, int sum) {\n   33          vector<vector<int> >res;\n   34          vector<int>one_sol;\n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool hasPathSum(TreeNode *root, int sum) {\n   13          \n   14          bool left, right;\n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   ..\n   36      }\n   37      \n   38:     void recoverTree(TreeNode *root) {\n   39          \n   40          int temp;\n   41          \n   42:         TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43          find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n\n/Users/Sean/Sean/Interview/Leetcode/Same Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool isSameTree(TreeNode *p, TreeNode *q) {\n   13          \n   14          if (!p && !q)\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   29      }\n   30      \n   31:     int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33          findNumber(root, one_num, sum);\n\n/Users/Sean/Sean/Interview/Leetcode/Symmetric Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool isSymmetricTree(TreeNode *left_root, TreeNode *right_root)\n   13      {\n   14          if (!left_root && !right_root)\n   ..\n   27      }\n   28  \n   29:     bool isSymmetric(TreeNode *root) {\n   30  \n   31          if (!root) return true;\n\n/Users/Sean/Sean/Interview/Leetcode/Unique Binary Search Trees II.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int genBST(vector<TreeNode *> &res, int start, int end)\n   14      {\n   15:         vector<TreeNode *>left, right;\n   16  \n   17          if (start > end)\n   ..\n   30                  for (int k = 0; k < right.size(); k++)\n   31                  {\n   32:                     TreeNode *root = new TreeNode(i);\n   33                      root->left = left[j];\n   34                      root->right = right[k];\n   ..\n   39      }\n   40  \n   41:     vector<TreeNode *> generateTrees(int n) {\n   42:         vector<TreeNode *>res;\n   43          genBST(res, 1, n);\n   44          return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     bool verifyBST(TreeNode *root, TreeNode *&pre_node)\n   15      {\n   16          if (!root) return true;\n   ..\n   31      }\n   32  \n   33:     bool isValidBST(TreeNode *root) {\n   34:         TreeNode *pre_node = 0;\n   35          return verifyBST(root, pre_node);\n   36      }\n\n<untitled 4032>:\n    1: struct TreeNode\n    2  {\n    3      int val;\n    4:     TreeNode *left;\n    5:     TreeNode *right;\n    6:     TreeNode (int x): val(x), left(NULL), right(NULL) {}\n    7  \n    8  };\n\n165 matches across 25 files\n\n\nSearching 157 files for \"getdepth\"\n\n/Users/Sean/Sean/Interview/Leetcode/Balanced Binary Tree.cpp:\n   13      \n   14      //-1: not balanced. otherwise: the depth\n   15:     int getDepth(TreeNode *root)\n   16      {\n   17          int left, right;\n   ..\n   19          if (!root) return 0;\n   20          \n   21:         left = getDepth(root->left);\n   22:         right = getDepth(root->right);\n   23          \n   24          if (left == -1 || right == -1)\n   ..\n   32      \n   33      bool isBalanced(TreeNode *root) {\n   34:         return (getDepth(root) == -1) ? (false) : (true);\n   35      }\n   36  };\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n<untitled 315>:\n    1  \n    2: dep_left = getDepth(root->left)\n    3: dep_right = getDepth(root->right)\n    4  \n    5  if (isSymmeTree(root->left) && isSymmeTree(root->right) && dep_left-dep_right <= 1)\n\n7 matches across 3 files\n\n\nSearching 159 files for \"treeNode\"\n\n/Users/Sean/Sean/Interview/Leetcode/Balanced Binary Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   13      \n   14      //-1: not balanced. otherwise: the depth\n   15:     int getDepth(TreeNode *root)\n   16      {\n   17          int left, right;\n   ..\n   31      }\n   32      \n   33:     bool isBalanced(TreeNode *root) {\n   34          return (getDepth(root) == -1) ? (false) : (true);\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Inorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     vector<int> inorderTraversal(TreeNode *root) {\n   14          vector<int>left, right;\n   15  \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal II.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   14      {\n   15          if (!root) return -1;\n   ..\n   28      }\n   29  \n   30:     vector<vector<int> > levelOrderBottom(TreeNode *root) {\n   31          vector<vector<int> >result, reverse;\n   32          \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   13      {\n   14          if (!root) return -1;\n   ..\n   27      }\n   28  \n   29:     vector<vector<int> > levelOrder(TreeNode *root) {\n   30          vector<vector<int> >res;\n   31          res.clear();\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Maximum Path Sum.cpp:\n    2  /**\n    3   * Definition for binary tree\n    4:  * struct TreeNode {\n    5   *     int val;\n    6:  *     TreeNode *left;\n    7:  *     TreeNode *right;\n    8:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    9   * };\n   10   */\n   ..\n   14      //1. return value: the max value whose ending point is root. This return value can be used by the parent of current root.\n   15      //2. max_val is current max value.\n   16:     int computeMax(TreeNode *root, int &max_val)\n   17      {\n   18          int max_left, max_right;\n   ..\n   46      }\n   47  \n   48:     int maxPathSum(TreeNode *root)\n   49      {\n   50          int max_val = INT_MIN;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Postorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     vector<int> postorderTraversal(TreeNode *root) {\n   15:         stack<TreeNode*> s;\n   16:         TreeNode *top_node, *popped = 0;\n   17          vector<int>res;\n   18  \n   ..\n   54  public:\n   55  \n   56:     vector<int> postorderTraversal(TreeNode *root) {\n   57          vector<int>left, right;\n   58          int i;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Preorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     vector<int> preorderTraversal(TreeNode *root) {\n   15  \n   16:         stack<TreeNode*> s;\n   17:         TreeNode *top_node;\n   18          vector<int>res;\n   19  \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Zigzag Level Order Traversal.cpp:\n    2  /**\n    3   * Definition for binary tree\n    4:  * struct TreeNode {\n    5   *     int val;\n    6:  *     TreeNode *left;\n    7:  *     TreeNode *right;\n    8:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    9   * };\n   10   */\n   ..\n   12  public:\n   13  \n   14:     vector<vector<int> > zigzagLevelOrder(TreeNode *root) {\n   15          vector<vector<int> >res;\n   16          vector<int>one_sol;\n   17          //use stack to store the next level node,\n   18          //such that ordering of the next level is reverse to that of the current level.\n   19:         stack<TreeNode *>next_stk, curr_stk;\n   20          int right_to_left = 1;\n   21  \n   ..\n   27          while (!curr_stk.empty())\n   28          {\n   29:             TreeNode *top = curr_stk.top();\n   30              one_sol.push_back(top->val);\n   31  \n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Inorder and Postorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     TreeNode *genBST(vector<int> &inorder, int in_start, int in_end, vector<int> &postorder, int post_start, int post_end)\n   13      {\n   14:         TreeNode *root, *left, *right;\n   15          int root_val;\n   16          int root_pos;\n   ..\n   25  \n   26          root_val = postorder[post_end];\n   27:         root = new TreeNode(root_val);\n   28  \n   29          //base condition\n   ..\n   42      }\n   43  \n   44:     TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\n   45          if (inorder.size() == 0 || postorder.size() == 0)\n   46              return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Preorder and Inorder Traversal.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12      //find the root position first. Then generate left/right tree recursively.\n   13:     TreeNode *genBST(vector<int> &preorder, int pre_start, int pre_end, vector<int> &inorder, int in_start, int in_end)\n   14      {\n   15:         TreeNode *root, *left, *right;\n   16          int root_val;\n   17          int root_pos;\n   ..\n   23  \n   24          root_val = preorder[pre_start];\n   25:         root = new TreeNode(root_val);\n   26          //base condition\n   27          if (pre_start == pre_end)\n   ..\n   41      }\n   42  \n   43:     TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n   44          if (preorder.size() == 0 || inorder.size() == 0)\n   45              return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted Array to Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12      //note: the first param should use \"&\" (called by reference),\n   13      // if not using \"&\" (i. e. call by value) will cause memory limit exceeding\n   14:     TreeNode *buildBST(vector<int> &num, int start, int end)\n   15      {\n   16:         TreeNode *left, *right, *parent;\n   17          int mid = (start + end) >> 1;\n   18  \n   ..\n   21  \n   22          left = buildBST(num, start, mid-1);\n   23:         parent = new TreeNode(num[mid]);\n   24          parent->left = left;\n   25          right = buildBST(num, mid+1, end);\n   ..\n   28      }\n   29  \n   30:     TreeNode *sortedArrayToBST(vector<int> &num) {\n   31          return buildBST(num, 0, num.size()-1);\n   32      }\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted List to Binary Search Tree.cpp:\n    9  /**\n   10   * Definition for binary tree\n   11:  * struct TreeNode {\n   12   *     int val;\n   13:  *     TreeNode *left;\n   14:  *     TreeNode *right;\n   15:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n   16   * };\n   17   */\n   18  class Solution {\n   19  public:\n   20:     TreeNode *buildBST(ListNode *&head, int start, int end)\n   21      {\n   22:         TreeNode *left, *right, *parent;\n   23          int mid;\n   24          \n   ..\n   31          left = buildBST(head, start, mid-1);\n   32          \n   33:         parent = new TreeNode(head->val);\n   34          parent->left = left;\n   35          \n   ..\n   42      }\n   43      \n   44:     TreeNode *sortedListToBST(ListNode *head) {\n   45          \n   46          ListNode *p = head;\n\n/Users/Sean/Sean/Interview/Leetcode/Flatten Binary Tree to Linked List.cpp:\n    4  class Solution {\n    5  public:\n    6:     void build(TreeNode *root, TreeNode *&tmp)\n    7      {\n    8          if(root)\n    .\n   16          }\n   17      }\n   18:     void flatten(TreeNode *root) {\n   19          // Start typing your C/C++ solution below\n   20          // DO NOT write int main() function\n   21:         TreeNode *tmp=NULL;\n   22          build(root, tmp);\n   23  \n   ..\n   29  \n   30      //leaf: the last node in preorder after do_flatten\n   31:     void do_flatten(TreeNode *&root, TreeNode *&leaf)\n   32      {\n   33:         TreeNode *left_leaf, *right_leaf;\n   34  \n   35          if (!root)\n   ..\n   62  \n   63  \n   64:     void flatten(TreeNode *root) {\n   65:         TreeNode *leaf;\n   66          do_flatten(root, leaf);\n   67      }\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Maximum Depth of Binary Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     int maxDepth(TreeNode *root) {\n   13          \n   14          int left_depth, right_depth;\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Depth of Binary Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  class Solution {\n   12  public:\n   13:     int minDepth(TreeNode *root) {\n   14  \n   15          int left_min, right_min;\n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   30      }\n   31      \n   32:     vector<vector<int> > pathSum(TreeNode *root, int sum) {\n   33          vector<vector<int> >res;\n   34          vector<int>one_sol;\n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool hasPathSum(TreeNode *root, int sum) {\n   13          \n   14          bool left, right;\n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   ..\n   36      }\n   37      \n   38:     void recoverTree(TreeNode *root) {\n   39          \n   40          int temp;\n   41          \n   42:         TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43          find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n\n/Users/Sean/Sean/Interview/Leetcode/Same Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool isSameTree(TreeNode *p, TreeNode *q) {\n   13          \n   14          if (!p && !q)\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   29      }\n   30      \n   31:     int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33          findNumber(root, one_num, sum);\n\n/Users/Sean/Sean/Interview/Leetcode/Symmetric Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool isSymmetricTree(TreeNode *left_root, TreeNode *right_root)\n   13      {\n   14          if (!left_root && !right_root)\n   ..\n   27      }\n   28  \n   29:     bool isSymmetric(TreeNode *root) {\n   30  \n   31          if (!root) return true;\n\n/Users/Sean/Sean/Interview/Leetcode/Unique Binary Search Trees II.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int genBST(vector<TreeNode *> &res, int start, int end)\n   14      {\n   15:         vector<TreeNode *>left, right;\n   16  \n   17          if (start > end)\n   ..\n   30                  for (int k = 0; k < right.size(); k++)\n   31                  {\n   32:                     TreeNode *root = new TreeNode(i);\n   33                      root->left = left[j];\n   34                      root->right = right[k];\n   ..\n   39      }\n   40  \n   41:     vector<TreeNode *> generateTrees(int n) {\n   42:         vector<TreeNode *>res;\n   43          genBST(res, 1, n);\n   44          return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n    1  /**\n    2   * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     bool verifyBST(TreeNode *root, TreeNode *&pre_node)\n   15      {\n   16          if (!root) return true;\n   ..\n   31      }\n   32  \n   33:     bool isValidBST(TreeNode *root) {\n   34:         TreeNode *pre_node = 0;\n   35          return verifyBST(root, pre_node);\n   36      }\n\n<untitled 121>:\n    1: struct TreeNode\n    2  {\n    3      int val;\n    4:     TreeNode *left;\n    5:     TreeNode *right;\n    6:     TreeNode (int x): val(x), left(NULL), right(NULL) {}\n    7  \n    8  };\n\n165 matches across 25 files\n\n\nSearching 160 files for \"find\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n   13              sort(s.begin(), s.end());\n   14              \n   15:             if (anagram.find(s) == anagram.end())\n   16              {\n   17                  anagram[s] = i;\n\n/Users/Sean/Sean/Interview/Leetcode/Clone Graph.cpp:\n   33              {\n   34                  UndirectedGraphNode *neighbor = curr_node->neighbors[i];\n   35:                 if (node_map.find(neighbor) == node_map.end())\n   36                  {\n   37                      UndirectedGraphNode *new_node = new UndirectedGraphNode(neighbor->label);\n   ..\n   55          if(!node)return node;\n   56          ///if this node is already created then just return the reference of the new node created earlier\n   57:         if(created.find(node)!=created.end())return created[node];\n   58          ///otherwise create a new node and mark corresponding node in original graph created.\n   59          UndirectedGraphNode * t=new UndirectedGraphNode(node->label);\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Inorder and Postorder Traversal.cpp:\n   18  \n   19          //similar concept with \"Construct Binary Tree from Preorder and Inorder Traversal\"\n   20:         //1. Find root position in Inorder.\n   21          //2. Decide the left tree number and genBST in left/right subtree recursively.\n   22          //base condition\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Preorder and Inorder Traversal.cpp:\n   10  class Solution {\n   11  public:\n   12:     //find the root position first. Then generate left/right tree recursively.\n   13      TreeNode *genBST(vector<int> &preorder, int pre_start, int pre_end, vector<int> &inorder, int in_start, int in_end)\n   14      {\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array II.cpp:\n    1  class Solution {\n    2  public:\n    3:     int findMin(vector<int> &num) {\n    4          int left = 0;\n    5          int right = num.size()-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int findMin(vector<int> &num) {\n    4  \n    5          int left = 0, right = num.size()-1;\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   24              //half B[]: B[0] to B[half_n]\n   25              if (half_m + half_n + 1 >= k)\n   26:                 return findMedian(A, half_m, B, n, k);\n   27              else\n   28:                 return findMedian(A, m, B+half_n+1, n-(half_n+1), k-(half_n+1));\n   29          }\n   30          else\n   31          {\n   32              if (half_m + half_n + 1 >= k)\n   33:                 return findMedian(A, m, B, half_n, k);\n   34              else\n   35:                 return findMedian(A+half_m+1, m-(half_m+1), B, n, k-(half_m+1));               \n   36          }\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41:             return findMedian(A, m, B, n, (m + n)/2 + 1);\n   42          else\n   43:             return (findMedian(A, m, B, n, (m + n)/2) + findMedian(A, m, B, n, (m + n)/2 + 1)) / 2;\n   44      }\n   45  };\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Window Substring.cpp:\n    1: //use two pointers (left, right) to find the match region.\n    2  //1. advance right index to collect enough char.\n    3  //2. advance left index to shrink the (left, right) region.\n    4: //3. adnvace left index and right index to find the next possible solutoin.\n    5  //4. repeat step1-step3\n    6  class Solution {\n    .\n   47                  }\n   48  \n   49:                 //increase left to find the next possible solution.\n   50                  S_table[S[left]]--;\n   51                  match_num--;\n\n/Users/Sean/Sean/Interview/Leetcode/Next Permutation.cpp:\n   11              return;\n   12          \n   13:         //from right to left, find the first descending index            \n   14          for (int i = size - 2; i >= 0; i--)\n   15          {\n   ..\n   21          }\n   22          \n   23:         //from right to left, find the first number larger than the partition number            \n   24          if (partition_idx != -1)\n   25          {\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n   14      }\n   15  \n   16:     void findPalindrome(string s, int start, vector<string> &one_sol, vector<vector<string> > &res)\n   17      {\n   18          if (start == s.size())\n   ..\n   23              {\n   24                  one_sol.push_back(s.substr(start, i-start+1));\n   25:                 findPalindrome(s, i+1, one_sol, res);\n   26                  one_sol.pop_back();\n   27              }\n   ..\n   32          vector<string>one_sol;\n   33          vector<vector<string> >res;\n   34:         findPalindrome(s, 0, one_sol, res);\n   35          return res;\n   36      }\n\n/Users/Sean/Sean/Interview/Leetcode/Partition List.cpp:\n    1: //find the first element greater than or equal to x, call it pivot, then move every smaller element to the left of the pivot.\n    2  class Solution {\n    3  public:        \n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   25          \n   26          one_sol.push_back(root->val);\n   27:         findPathSum(root->left, sum-root->val, res, one_sol);\n   28:         findPathSum(root->right, sum-root->val, res, one_sol);        \n   29          one_sol.pop_back();                    \n   30      }\n   ..\n   34          vector<int>one_sol;\n   35          \n   36:         findPathSum(root, sum, res, one_sol);\n   37          return res;\n   38      }\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   15          for (int i = 0; i < num.size(); i++)\n   16          {\n   17:             if (selected[i] || duplicate.find(num[i]) != duplicate.end())\n   18                  continue;\n   19                  \n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   16              return -1;\n   17          \n   18:         find_err_node(root->left, pre_node, large_err, small_err);\n   19          \n   20          if (pre_node && pre_node->val > root->val)\n   ..\n   32          pre_node = root;\n   33          \n   34:         find_err_node(root->right, pre_node, large_err, small_err);\n   35          return 0;                    \n   36      }\n   ..\n   41          \n   42          TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43:         find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n   45          if (!root)\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Words in a String.cpp:\n   19          size_t left, right;\n   20          string delimiter = \" \\f\\n\\r\\t\\v\";\n   21:         left = s.find_first_not_of(delimiter);\n   22:         right  = s.find_last_not_of(delimiter);\n   23  \n   24          if (left == string::npos || right == string::npos)\n\n/Users/Sean/Sean/Interview/Leetcode/Rotate List.cpp:\n   19          if (!head) return head;\n   20          \n   21:         //find total number\n   22          while (temp)\n   23          {\n   ..\n   31          if (k == 0) return head;\n   32          \n   33:         //find new head (target)\n   34          for (i = 0, target = head; i < num - k; i++)\n   35          {\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    1  class Solution {\n    2  public:\n    3:     vector<int> findSubstring(string S, vector<string> &L) {\n    4          \n    5          vector<int> res;\n    .\n   28              {\n   29                  string substr = S.substr(i+j*each_size, each_size);\n   30:                 if (L_table.find(substr) == L_table.end())                        \n   31                      break;\n   32                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   24              sum += one_num;\n   25              \n   26:         findNumber(root->left, one_num, sum);\n   27:         findNumber(root->right, one_num, sum);\n   28          return;\n   29      }\n   ..\n   31      int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33:         findNumber(root, one_num, sum);\n   34          return sum;\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    1  //The area for each A[i]                                                               \n    2: //1. find the max height of the left of A[i], call it A_left_max[i]                    \n    3: //2. find the max height of the right of A[i], call it A_right_max[i]                  \n    4  //3. area of A[i] = (min(A_left_max[i], A_right_max[i]) - A[i])*1                      \n    5  #define MIN(a, b) ((a < b) ? (a) : (b))                                                \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   72          {\n   73              int diff = target - numbers[i];\n   74:             if (hash_table.find(diff) != hash_table.end() && hash_table[diff] != i)\n   75              {\n   76                  res.push_back(i+1);\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Number.cpp:\n   11  \n   12  		//trim space\n   13: 		size_t end_pos = str.find_last_not_of(\" \\t\\n\");\n   14  \n   15  		if (end_pos != string::npos)\n   16  			str = str.substr(0, end_pos + 1);\n   17  \n   18: 		size_t start_pos = str.find_first_not_of(\" \\t\\n\");\n   19  		if (start_pos != string::npos)\n   20  			str = str.substr(start_pos);\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp:\n   18              string str = s.substr(start, i-start+1);\n   19              //if s[0] to s[i] is matched, then do recursive on remaining sub string.\n   20:             if (dict.find(str) != dict.end() && possible[i+1])\n   21              {\n   22                  int pre_size = res.size();\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break.cpp:\n   12              for (int k = 0; k < i ; k++)\n   13              {\n   14:                 hit[i] = hit[k] && (dict.find(s2.substr(k+1, i-k)) != dict.end());\n   15                  if (hit[i]) break;\n   16              }\n\n/Users/Sean/Sean/Interview/Leetcode/Word Ladder.cpp:\n   31                          return distance+1;\n   32  \n   33:                     if (dict.find(str) != dict.end())\n   34                      {\n   35                          words.push(str);\n\n/Users/Sean/Sean/Interview/Leetcode/Word Search.cpp:\n    3  Analysis:\n    4  The idea of this question is as follows:\n    5: (1) Find the 1st element of the word in the board.\n    6  (2) For each position found where the 1st element lies, recursively do:\n    7             (i) Search the around cell to see if the next element exists. (4 directions: (i-1,j),(i+1,j),(i,j-1),(i,j+1) )\n\n<untitled 138>:\n    6  vector\n    7  \n    8: hash.find(i) != hash.end()\n    9  vector<int>table;\n   10  \n\n<untitled 352>:\n    2  if (root->val == val)\n    3      return root;\n    4: left =  findLCA(root->left, val);\n    5  if (left && right)\n    6      return root;\n\n97 matches across 30 files\n\n\nSearching 160 files for \"map\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n    6      vector<string> anagrams(vector<string> &strs) {\n    7          vector<string>res;\n    8:         map<string, int>anagram;\n    9          \n   10          for (int i = 0; i < strs.size(); i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Clone Graph.cpp:\n   13      UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\n   14          queue<UndirectedGraphNode *>visit;\n   15:         map<UndirectedGraphNode *, UndirectedGraphNode *>node_map;\n   16          UndirectedGraphNode *root = NULL;\n   17  \n   ..\n   20          visit.push(node);\n   21  \n   22:         root = node_map[node] = new UndirectedGraphNode(node->label);\n   23  \n   24          while(!visit.empty())\n   ..\n   33              {\n   34                  UndirectedGraphNode *neighbor = curr_node->neighbors[i];\n   35:                 if (node_map.find(neighbor) == node_map.end())\n   36                  {\n   37                      UndirectedGraphNode *new_node = new UndirectedGraphNode(neighbor->label);\n   38:                     node_map[neighbor] = new_node;\n   39                      visit.push(neighbor);\n   40                  }\n   41                  //store duplicate neighbor to duplicate curr_node\n   42:                 node_map[curr_node]->neighbors.push_back(node_map[neighbor]);\n   43              }\n   44          }\n   ..\n   49  class Solution {\n   50  public:\n   51:     unordered_map<UndirectedGraphNode *,UndirectedGraphNode *> created;\n   52:     ///although it takes O(n) space but it is the efficent way to search available in C++11...for C++4.8 use map...\n   53      UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\n   54          //not required ..only to be in safe side\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Consecutive Sequence.cpp:\n    3  public:\n    4      int longestConsecutive(vector<int> &num) {\n    5:         map<int, int>hash_table;\n    6          int count;\n    7          int max_count = 0;\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   18          {\n   19:             int value = m_map[key]->value;\n   20              erase_key(key);\n   21              insert_to_head(key, value);\n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n   31              {\n   32                  //remove the least-used one (the last element)\n   33:                 m_map.erase(m_LRU_cache.back().key);\n   34                  m_LRU_cache.pop_back();\n   35              }\n   ..\n   44      //we should use list instead of vector for 2 reasons.\n   45      //1. vector is continuous memory, insert() will reuslt in re-allocate a whole new memory (bad performance)\n   46:     //2. memory re-allocate will cause the original key-value stored in m_map invalid.\n   47:     map<int, list<cache_entry>::iterator>m_map;\n   48      int m_capacity;\n   49      list<cache_entry>m_LRU_cache;\n   ..\n   52      void erase_key(int key)    \n   53      {\n   54:         list<cache_entry>::iterator it = m_map[key];\n   55          m_LRU_cache.erase(it);\n   56      }\n   ..\n   59          cache_entry cache(key, value);\n   60          m_LRU_cache.insert(m_LRU_cache.begin(), cache);\n   61:         m_map[key] = m_LRU_cache.begin();\n   62      }\n   63  };\n\n/Users/Sean/Sean/Interview/Leetcode/Max Points on a Line.cpp:\n   14      int maxPoints(vector<Point> &points) {\n   15          int max_num = 0;\n   16:         map<float, int>slope;\n   17  \n   18          for (int i = 0; i < points.size(); i++)\n   ..\n   40                  }\n   41              }\n   42:             map<float, int>::iterator it = slope.begin();\n   43              for (;it != slope.end(); it++)\n   44              {\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n    1: //add map<int, int>duplicate to record duplicate num at the same position.\n    2  class Solution {\n    3  public:\n    .\n    5      void do_permute(vector<int> &num, vector<vector<int> > &res, vector<int> &one_sol, vector<int> &selected)\n    6      {\n    7:         map<int, int>duplicate;        \n    8          \n    9          if (one_sol.size() == num.size())\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    4          \n    5          vector<int> res;\n    6:         map<string, int>L_table;        \n    7:         map<string, int>match_count;        \n    8          int L_num = L.size();\n    9          int each_size;\n   ..\n   14          each_size = L[0].size();\n   15          \n   16:         //create map table for each stirng in L\n   17          for (int i = 0; i < L_num; i++)       \n   18              L_table[L[i]]++;\n   19                     \n   20  \n   21:         //create map table for each stirng in L. \n   22          //L[i] may be repeating so we should use addition to record the corresponding count.\n   23          for (i = 0; i < (int)S.size() - (each_size*L_num-1); i++)            \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   54      }\n   55  };\n   56: #else //hash map solution\n   57: #include <map>\n   58  class Solution {\n   59  public:\n   60      vector<int> twoSum(vector<int> &numbers, int target) {\n   61          \n   62:         map<int, int>hash_table;\n   63          int i;\n   64          vector<int>res;\n\n/Users/Sean/Sean/Interview/Leetcode/Word Ladder.cpp:\n    3  public:\n    4      int ladderLength(string start, string end, unordered_set<string> &dict) {\n    5:         map<string, int>distance_map;\n    6          queue<string>words;\n    7          int distance;\n    8  \n    9          words.push(start);\n   10:         distance_map[start] = 1;\n   11          dict.erase(start);\n   12  \n   ..\n   15              string str = words.front();\n   16              words.pop();\n   17:             distance = distance_map[str];\n   18  \n   19              for (int i = 0; i < str.size(); i++)\n   ..\n   34                      {\n   35                          words.push(str);\n   36:                         distance_map[str] = distance+1;\n   37                          //important!! To avoid dupilcate str inserted into queue<string>words.\n   38                          //Remove the hit str in the dictionary.\n\n<untitled 138>:\n    1  stack<int>\n    2: map<int, string>\n    3  vector<>\n    4  \n    5: map<int, int>hashtable\n    6  vector\n    7  \n\n44 matches across 13 files\n\n\nSearching 160 files for \"validBST\"\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n   31      }\n   32  \n   33:     bool isValidBST(TreeNode *root) {\n   34          TreeNode *pre_node = 0;\n   35          return verifyBST(root, pre_node);\n\n2 matches across 2 files\n\n\nSearching 160 files for \"validBST\"\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n   31      }\n   32  \n   33:     bool isValidBST(TreeNode *root) {\n   34          TreeNode *pre_node = 0;\n   35          return verifyBST(root, pre_node);\n\n2 matches across 2 files\n\n\nSearching 162 files for \"ispalindrome\"\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Number.cpp:\n    1  class Solution {\n    2  public:\n    3:     bool isPalindrome(int x) {\n    4          \n    5          int digits = 0;\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n    3  public:\n    4  \n    5:     bool isPalindrome(string s, int start, int end)\n    6      {\n    7          while (start < end)\n    .\n   20          for (int i = start; i < s.size(); i++)\n   21          {\n   22:             if (isPalindrome(s, start, i))\n   23              {\n   24                  one_sol.push_back(s.substr(start, i-start+1));\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Palindrome.cpp:\n    2  class Solution {\n    3  public:\n    4:     bool isPalindrome(string s) {\n    5  \n    6          if (s.size() <= 1) return true;\n\n7 matches across 4 files\n\n\nSearching 163 files for \"isbst\"\n\n0 matches across 0 files\n\n\nSearching 163 files for \"verifyBST\"\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n   12  class Solution {\n   13  public:\n   14:     bool verifyBST(TreeNode *root, TreeNode *&pre_node)\n   15      {\n   16          if (!root) return true;\n   17  \n   18:         if (!verifyBST(root->left, pre_node))\n   19              return false;\n   20  \n   ..\n   25          pre_node = root;\n   26  \n   27:         if (!verifyBST(root->right, pre_node))\n   28              return false;\n   29  \n   ..\n   33      bool isValidBST(TreeNode *root) {\n   34          TreeNode *pre_node = 0;\n   35:         return verifyBST(root, pre_node);\n   36      }\n   37  };\n\n5 matches across 2 files\n\n\nSearching 166 files for \"find\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n   13              sort(s.begin(), s.end());\n   14              \n   15:             if (anagram.find(s) == anagram.end())\n   16              {\n   17                  anagram[s] = i;\n\n/Users/Sean/Sean/Interview/Leetcode/Clone Graph.cpp:\n   33              {\n   34                  UndirectedGraphNode *neighbor = curr_node->neighbors[i];\n   35:                 if (node_map.find(neighbor) == node_map.end())\n   36                  {\n   37                      UndirectedGraphNode *new_node = new UndirectedGraphNode(neighbor->label);\n   ..\n   55          if(!node)return node;\n   56          ///if this node is already created then just return the reference of the new node created earlier\n   57:         if(created.find(node)!=created.end())return created[node];\n   58          ///otherwise create a new node and mark corresponding node in original graph created.\n   59          UndirectedGraphNode * t=new UndirectedGraphNode(node->label);\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Inorder and Postorder Traversal.cpp:\n   18  \n   19          //similar concept with \"Construct Binary Tree from Preorder and Inorder Traversal\"\n   20:         //1. Find root position in Inorder.\n   21          //2. Decide the left tree number and genBST in left/right subtree recursively.\n   22          //base condition\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Preorder and Inorder Traversal.cpp:\n   10  class Solution {\n   11  public:\n   12:     //find the root position first. Then generate left/right tree recursively.\n   13      TreeNode *genBST(vector<int> &preorder, int pre_start, int pre_end, vector<int> &inorder, int in_start, int in_end)\n   14      {\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array II.cpp:\n    1  class Solution {\n    2  public:\n    3:     int findMin(vector<int> &num) {\n    4          int left = 0;\n    5          int right = num.size()-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Find Minimum in Rotated Sorted Array.cpp:\n    1  class Solution {\n    2  public:\n    3:     int findMin(vector<int> &num) {\n    4  \n    5          int left = 0, right = num.size()-1;\n\n/Users/Sean/Sean/Interview/Leetcode/Find Peak Element.cpp:\n    2  class Solution {\n    3  public:\n    4:     int findPeakElement(const vector<int> &num) {\n    5          int n = num.size();\n    6          int left, right;\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n\n/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp:\n    3  public:\n    4  \n    5:     double findMedian(int A[], int m, int B[], int n, int k)\n    6      {\n    7          int half_m = m >> 1, half_n = n >> 1;\n    .\n   24              //half B[]: B[0] to B[half_n]\n   25              if (half_m + half_n + 1 >= k)\n   26:                 return findMedian(A, half_m, B, n, k);\n   27              else\n   28:                 return findMedian(A, m, B+half_n+1, n-(half_n+1), k-(half_n+1));\n   29          }\n   30          else\n   31          {\n   32              if (half_m + half_n + 1 >= k)\n   33:                 return findMedian(A, m, B, half_n, k);\n   34              else\n   35:                 return findMedian(A+half_m+1, m-(half_m+1), B, n, k-(half_m+1));               \n   36          }\n   37      }\n   38      \n   39:     double findMedianSortedArrays(int A[], int m, int B[], int n) {\n   40          if ((m + n) & 1)\n   41:             return findMedian(A, m, B, n, (m + n)/2 + 1);\n   42          else\n   43:             return (findMedian(A, m, B, n, (m + n)/2) + findMedian(A, m, B, n, (m + n)/2 + 1)) / 2;\n   44      }\n   45  };\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Window Substring.cpp:\n    1: //use two pointers (left, right) to find the match region.\n    2  //1. advance right index to collect enough char.\n    3  //2. advance left index to shrink the (left, right) region.\n    4: //3. adnvace left index and right index to find the next possible solutoin.\n    5  //4. repeat step1-step3\n    6  class Solution {\n    .\n   47                  }\n   48  \n   49:                 //increase left to find the next possible solution.\n   50                  S_table[S[left]]--;\n   51                  match_num--;\n\n/Users/Sean/Sean/Interview/Leetcode/Next Permutation.cpp:\n   11              return;\n   12          \n   13:         //from right to left, find the first descending index            \n   14          for (int i = size - 2; i >= 0; i--)\n   15          {\n   ..\n   21          }\n   22          \n   23:         //from right to left, find the first number larger than the partition number            \n   24          if (partition_idx != -1)\n   25          {\n\n/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp:\n   14      }\n   15  \n   16:     void findPalindrome(string s, int start, vector<string> &one_sol, vector<vector<string> > &res)\n   17      {\n   18          if (start == s.size())\n   ..\n   23              {\n   24                  one_sol.push_back(s.substr(start, i-start+1));\n   25:                 findPalindrome(s, i+1, one_sol, res);\n   26                  one_sol.pop_back();\n   27              }\n   ..\n   32          vector<string>one_sol;\n   33          vector<vector<string> >res;\n   34:         findPalindrome(s, 0, one_sol, res);\n   35          return res;\n   36      }\n\n/Users/Sean/Sean/Interview/Leetcode/Partition List.cpp:\n    1: //find the first element greater than or equal to x, call it pivot, then move every smaller element to the left of the pivot.\n    2  class Solution {\n    3  public:        \n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   25          \n   26          one_sol.push_back(root->val);\n   27:         findPathSum(root->left, sum-root->val, res, one_sol);\n   28:         findPathSum(root->right, sum-root->val, res, one_sol);        \n   29          one_sol.pop_back();                    \n   30      }\n   ..\n   34          vector<int>one_sol;\n   35          \n   36:         findPathSum(root, sum, res, one_sol);\n   37          return res;\n   38      }\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n   15          for (int i = 0; i < num.size(); i++)\n   16          {\n   17:             if (selected[i] || duplicate.find(num[i]) != duplicate.end())\n   18                  continue;\n   19                  \n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   16              return -1;\n   17          \n   18:         find_err_node(root->left, pre_node, large_err, small_err);\n   19          \n   20          if (pre_node && pre_node->val > root->val)\n   ..\n   32          pre_node = root;\n   33          \n   34:         find_err_node(root->right, pre_node, large_err, small_err);\n   35          return 0;                    \n   36      }\n   ..\n   41          \n   42          TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43:         find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n   45          if (!root)\n\n/Users/Sean/Sean/Interview/Leetcode/Reverse Words in a String.cpp:\n   19          size_t left, right;\n   20          string delimiter = \" \\f\\n\\r\\t\\v\";\n   21:         left = s.find_first_not_of(delimiter);\n   22:         right  = s.find_last_not_of(delimiter);\n   23  \n   24          if (left == string::npos || right == string::npos)\n\n/Users/Sean/Sean/Interview/Leetcode/Rotate List.cpp:\n   19          if (!head) return head;\n   20          \n   21:         //find total number\n   22          while (temp)\n   23          {\n   ..\n   31          if (k == 0) return head;\n   32          \n   33:         //find new head (target)\n   34          for (i = 0, target = head; i < num - k; i++)\n   35          {\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    1  class Solution {\n    2  public:\n    3:     vector<int> findSubstring(string S, vector<string> &L) {\n    4          \n    5          vector<int> res;\n    .\n   28              {\n   29                  string substr = S.substr(i+j*each_size, each_size);\n   30:                 if (L_table.find(substr) == L_table.end())                        \n   31                      break;\n   32                  else\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   24              sum += one_num;\n   25              \n   26:         findNumber(root->left, one_num, sum);\n   27:         findNumber(root->right, one_num, sum);\n   28          return;\n   29      }\n   ..\n   31      int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33:         findNumber(root, one_num, sum);\n   34          return sum;\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp:\n    1  //The area for each A[i]                                                               \n    2: //1. find the max height of the left of A[i], call it A_left_max[i]                    \n    3: //2. find the max height of the right of A[i], call it A_right_max[i]                  \n    4  //3. area of A[i] = (min(A_left_max[i], A_right_max[i]) - A[i])*1                      \n    5  #define MIN(a, b) ((a < b) ? (a) : (b))                                                \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   72          {\n   73              int diff = target - numbers[i];\n   74:             if (hash_table.find(diff) != hash_table.end() && hash_table[diff] != i)\n   75              {\n   76                  res.push_back(i+1);\n\n/Users/Sean/Sean/Interview/Leetcode/Valid Number.cpp:\n   11  \n   12  		//trim space\n   13: 		size_t end_pos = str.find_last_not_of(\" \\t\\n\");\n   14  \n   15  		if (end_pos != string::npos)\n   16  			str = str.substr(0, end_pos + 1);\n   17  \n   18: 		size_t start_pos = str.find_first_not_of(\" \\t\\n\");\n   19  		if (start_pos != string::npos)\n   20  			str = str.substr(start_pos);\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp:\n   18              string str = s.substr(start, i-start+1);\n   19              //if s[0] to s[i] is matched, then do recursive on remaining sub string.\n   20:             if (dict.find(str) != dict.end() && possible[i+1])\n   21              {\n   22                  int pre_size = res.size();\n\n/Users/Sean/Sean/Interview/Leetcode/Word Break.cpp:\n   12              for (int k = 0; k < i ; k++)\n   13              {\n   14:                 hit[i] = hit[k] && (dict.find(s2.substr(k+1, i-k)) != dict.end());\n   15                  if (hit[i]) break;\n   16              }\n\n/Users/Sean/Sean/Interview/Leetcode/Word Ladder.cpp:\n   31                          return distance+1;\n   32  \n   33:                     if (dict.find(str) != dict.end())\n   34                      {\n   35                          words.push(str);\n\n/Users/Sean/Sean/Interview/Leetcode/Word Search.cpp:\n    3  Analysis:\n    4  The idea of this question is as follows:\n    5: (1) Find the 1st element of the word in the board.\n    6  (2) For each position found where the 1st element lies, recursively do:\n    7             (i) Search the around cell to see if the next element exists. (4 directions: (i-1,j),(i+1,j),(i,j-1),(i,j+1) )\n\n<untitled 241>:\n    2  if (root->val == val)\n    3      return root;\n    4: left =  findLCA(root->left, val);\n    5  if (left && right)\n    6      return root;\n\n<untitled 294>:\n    6  vector\n    7  \n    8: hash.find(i) != hash.end()\n    9  vector<int>table;\n   10  \n\n<untitled 514>:\n   18    - Search the issue tracker at https://github.com/SublimeLinter/SublimeLinter3/issues\n   19    \n   20:   if you can't find an issue or post for your problem, please submit one in the issue tracker.\n   21    Be sure to put your OS, SublimeLinter version, and **ENTIRE** debug console output in the issue.\n   22    \n\n<untitled 523>:\n    1: n = find(root->left, k, found);\n    2  \n    3  if (n)\n    .\n   15  } \n   16  \n   17: n = find(root->right, k, found);\n   18  \n   19  return n;\n\n101 matches across 33 files\n\n\nSearching 166 files for \"map\"\n\n/Users/Sean/Sean/Interview/Leetcode/Anagrams.cpp:\n    6      vector<string> anagrams(vector<string> &strs) {\n    7          vector<string>res;\n    8:         map<string, int>anagram;\n    9          \n   10          for (int i = 0; i < strs.size(); i++)\n\n/Users/Sean/Sean/Interview/Leetcode/Clone Graph.cpp:\n   13      UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\n   14          queue<UndirectedGraphNode *>visit;\n   15:         map<UndirectedGraphNode *, UndirectedGraphNode *>node_map;\n   16          UndirectedGraphNode *root = NULL;\n   17  \n   ..\n   20          visit.push(node);\n   21  \n   22:         root = node_map[node] = new UndirectedGraphNode(node->label);\n   23  \n   24          while(!visit.empty())\n   ..\n   33              {\n   34                  UndirectedGraphNode *neighbor = curr_node->neighbors[i];\n   35:                 if (node_map.find(neighbor) == node_map.end())\n   36                  {\n   37                      UndirectedGraphNode *new_node = new UndirectedGraphNode(neighbor->label);\n   38:                     node_map[neighbor] = new_node;\n   39                      visit.push(neighbor);\n   40                  }\n   41                  //store duplicate neighbor to duplicate curr_node\n   42:                 node_map[curr_node]->neighbors.push_back(node_map[neighbor]);\n   43              }\n   44          }\n   ..\n   49  class Solution {\n   50  public:\n   51:     unordered_map<UndirectedGraphNode *,UndirectedGraphNode *> created;\n   52:     ///although it takes O(n) space but it is the efficent way to search available in C++11...for C++4.8 use map...\n   53      UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\n   54          //not required ..only to be in safe side\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Consecutive Sequence.cpp:\n    3  public:\n    4      int longestConsecutive(vector<int> &num) {\n    5:         map<int, int>hash_table;\n    6          int count;\n    7          int max_count = 0;\n\n/Users/Sean/Sean/Interview/Leetcode/LRU Cache.cpp:\n   13      \n   14      int get(int key) {\n   15:         if (m_map.find(key) == m_map.end())\n   16              return -1;\n   17          else                    \n   18          {\n   19:             int value = m_map[key]->value;\n   20              erase_key(key);\n   21              insert_to_head(key, value);\n   ..\n   26      void set(int key, int value) {\n   27          \n   28:         if (m_map.find(key) == m_map.end())\n   29          {\n   30              if (m_LRU_cache.size() == m_capacity)\n   31              {\n   32                  //remove the least-used one (the last element)\n   33:                 m_map.erase(m_LRU_cache.back().key);\n   34                  m_LRU_cache.pop_back();\n   35              }\n   ..\n   44      //we should use list instead of vector for 2 reasons.\n   45      //1. vector is continuous memory, insert() will reuslt in re-allocate a whole new memory (bad performance)\n   46:     //2. memory re-allocate will cause the original key-value stored in m_map invalid.\n   47:     map<int, list<cache_entry>::iterator>m_map;\n   48      int m_capacity;\n   49      list<cache_entry>m_LRU_cache;\n   ..\n   52      void erase_key(int key)    \n   53      {\n   54:         list<cache_entry>::iterator it = m_map[key];\n   55          m_LRU_cache.erase(it);\n   56      }\n   ..\n   59          cache_entry cache(key, value);\n   60          m_LRU_cache.insert(m_LRU_cache.begin(), cache);\n   61:         m_map[key] = m_LRU_cache.begin();\n   62      }\n   63  };\n\n/Users/Sean/Sean/Interview/Leetcode/Max Points on a Line.cpp:\n   14      int maxPoints(vector<Point> &points) {\n   15          int max_num = 0;\n   16:         map<float, int>slope;\n   17  \n   18          for (int i = 0; i < points.size(); i++)\n   ..\n   40                  }\n   41              }\n   42:             map<float, int>::iterator it = slope.begin();\n   43              for (;it != slope.end(); it++)\n   44              {\n\n/Users/Sean/Sean/Interview/Leetcode/Permutations II.cpp:\n    1: //add map<int, int>duplicate to record duplicate num at the same position.\n    2  class Solution {\n    3  public:\n    .\n    5      void do_permute(vector<int> &num, vector<vector<int> > &res, vector<int> &one_sol, vector<int> &selected)\n    6      {\n    7:         map<int, int>duplicate;        \n    8          \n    9          if (one_sol.size() == num.size())\n\n/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp:\n    4          \n    5          vector<int> res;\n    6:         map<string, int>L_table;        \n    7:         map<string, int>match_count;        \n    8          int L_num = L.size();\n    9          int each_size;\n   ..\n   14          each_size = L[0].size();\n   15          \n   16:         //create map table for each stirng in L\n   17          for (int i = 0; i < L_num; i++)       \n   18              L_table[L[i]]++;\n   19                     \n   20  \n   21:         //create map table for each stirng in L. \n   22          //L[i] may be repeating so we should use addition to record the corresponding count.\n   23          for (i = 0; i < (int)S.size() - (each_size*L_num-1); i++)            \n\n/Users/Sean/Sean/Interview/Leetcode/Two Sum.cpp:\n   54      }\n   55  };\n   56: #else //hash map solution\n   57: #include <map>\n   58  class Solution {\n   59  public:\n   60      vector<int> twoSum(vector<int> &numbers, int target) {\n   61          \n   62:         map<int, int>hash_table;\n   63          int i;\n   64          vector<int>res;\n\n/Users/Sean/Sean/Interview/Leetcode/Word Ladder.cpp:\n    3  public:\n    4      int ladderLength(string start, string end, unordered_set<string> &dict) {\n    5:         map<string, int>distance_map;\n    6          queue<string>words;\n    7          int distance;\n    8  \n    9          words.push(start);\n   10:         distance_map[start] = 1;\n   11          dict.erase(start);\n   12  \n   ..\n   15              string str = words.front();\n   16              words.pop();\n   17:             distance = distance_map[str];\n   18  \n   19              for (int i = 0; i < str.size(); i++)\n   ..\n   34                      {\n   35                          words.push(str);\n   36:                         distance_map[str] = distance+1;\n   37                          //important!! To avoid dupilcate str inserted into queue<string>words.\n   38                          //Remove the hit str in the dictionary.\n\n<untitled 294>:\n    1  stack<int>\n    2: map<int, string>\n    3  vector<>\n    4  \n    5: map<int, int>hashtable\n    6  vector\n    7  \n\n44 matches across 13 files\n\n\nSearching 170 files for \"tree\"\n\n/Users/Sean/Sean/Interview/Leetcode/Balanced Binary Tree.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   13      \n   14      //-1: not balanced. otherwise: the depth\n   15:     int getDepth(TreeNode *root)\n   16      {\n   17          int left, right;\n   ..\n   31      }\n   32      \n   33:     bool isBalanced(TreeNode *root) {\n   34          return (getDepth(root) == -1) ? (false) : (true);\n   35      }\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Inorder Traversal.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     vector<int> inorderTraversal(TreeNode *root) {\n   14          vector<int>left, right;\n   15  \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal II.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   14      {\n   15          if (!root) return -1;\n   ..\n   28      }\n   29  \n   30:     vector<vector<int> > levelOrderBottom(TreeNode *root) {\n   31          vector<vector<int> >result, reverse;\n   32          \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     int genlevelOrder(TreeNode *root, vector<vector<int> > &list, int level)\n   13      {\n   14          if (!root) return -1;\n   ..\n   27      }\n   28  \n   29:     vector<vector<int> > levelOrder(TreeNode *root) {\n   30          vector<vector<int> >res;\n   31          res.clear();\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Maximum Path Sum.cpp:\n    1: //refer http://yucoding.blogspot.com/2012/12/leetcode-question-13-binary-tree.html\n    2  /**\n    3:  * Definition for binary tree\n    4:  * struct TreeNode {\n    5   *     int val;\n    6:  *     TreeNode *left;\n    7:  *     TreeNode *right;\n    8:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    9   * };\n   10   */\n   ..\n   14      //1. return value: the max value whose ending point is root. This return value can be used by the parent of current root.\n   15      //2. max_val is current max value.\n   16:     int computeMax(TreeNode *root, int &max_val)\n   17      {\n   18          int max_left, max_right;\n   ..\n   33  \n   34          /*\n   35:             For each node(sub tree), there are two status, one is the path ends at\n   36              this node, the other is the path goes through this node.\n   37              In the first case, the path sum is curr_val+max(left_s,right_s).\n   ..\n   46      }\n   47  \n   48:     int maxPathSum(TreeNode *root)\n   49      {\n   50          int max_val = INT_MIN;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Postorder Traversal.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     vector<int> postorderTraversal(TreeNode *root) {\n   15:         stack<TreeNode*> s;\n   16:         TreeNode *top_node, *popped = 0;\n   17          vector<int>res;\n   18  \n   ..\n   54  public:\n   55  \n   56:     vector<int> postorderTraversal(TreeNode *root) {\n   57          vector<int>left, right;\n   58          int i;\n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Preorder Traversal.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     vector<int> preorderTraversal(TreeNode *root) {\n   15  \n   16:         stack<TreeNode*> s;\n   17:         TreeNode *top_node;\n   18          vector<int>res;\n   19  \n\n/Users/Sean/Sean/Interview/Leetcode/Binary Tree Zigzag Level Order Traversal.cpp:\n    1: //refer http://leetcode.com/2010/09/printing-binary-tree-in-zig-zag-level_18.html\n    2  /**\n    3:  * Definition for binary tree\n    4:  * struct TreeNode {\n    5   *     int val;\n    6:  *     TreeNode *left;\n    7:  *     TreeNode *right;\n    8:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    9   * };\n   10   */\n   ..\n   12  public:\n   13  \n   14:     vector<vector<int> > zigzagLevelOrder(TreeNode *root) {\n   15          vector<vector<int> >res;\n   16          vector<int>one_sol;\n   17          //use stack to store the next level node,\n   18          //such that ordering of the next level is reverse to that of the current level.\n   19:         stack<TreeNode *>next_stk, curr_stk;\n   20          int right_to_left = 1;\n   21  \n   ..\n   27          while (!curr_stk.empty())\n   28          {\n   29:             TreeNode *top = curr_stk.top();\n   30              one_sol.push_back(top->val);\n   31  \n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Inorder and Postorder Traversal.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     TreeNode *genBST(vector<int> &inorder, int in_start, int in_end, vector<int> &postorder, int post_start, int post_end)\n   13      {\n   14:         TreeNode *root, *left, *right;\n   15          int root_val;\n   16          int root_pos;\n   17          int left_num;\n   18  \n   19:         //similar concept with \"Construct Binary Tree from Preorder and Inorder Traversal\"\n   20          //1. Find root position in Inorder.\n   21:         //2. Decide the left tree number and genBST in left/right subtree recursively.\n   22          //base condition\n   23          if (in_start > in_end)\n   ..\n   25  \n   26          root_val = postorder[post_end];\n   27:         root = new TreeNode(root_val);\n   28  \n   29          //base condition\n   ..\n   42      }\n   43  \n   44:     TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\n   45          if (inorder.size() == 0 || postorder.size() == 0)\n   46              return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Construct Binary Tree from Preorder and Inorder Traversal.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     //find the root position first. Then generate left/right tree recursively.\n   13:     TreeNode *genBST(vector<int> &preorder, int pre_start, int pre_end, vector<int> &inorder, int in_start, int in_end)\n   14      {\n   15:         TreeNode *root, *left, *right;\n   16          int root_val;\n   17          int root_pos;\n   ..\n   23  \n   24          root_val = preorder[pre_start];\n   25:         root = new TreeNode(root_val);\n   26          //base condition\n   27          if (pre_start == pre_end)\n   ..\n   41      }\n   42  \n   43:     TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {\n   44          if (preorder.size() == 0 || inorder.size() == 0)\n   45              return NULL;\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted Array to Binary Search Tree.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12      //note: the first param should use \"&\" (called by reference),\n   13      // if not using \"&\" (i. e. call by value) will cause memory limit exceeding\n   14:     TreeNode *buildBST(vector<int> &num, int start, int end)\n   15      {\n   16:         TreeNode *left, *right, *parent;\n   17          int mid = (start + end) >> 1;\n   18  \n   ..\n   21  \n   22          left = buildBST(num, start, mid-1);\n   23:         parent = new TreeNode(num[mid]);\n   24          parent->left = left;\n   25          right = buildBST(num, mid+1, end);\n   ..\n   28      }\n   29  \n   30:     TreeNode *sortedArrayToBST(vector<int> &num) {\n   31          return buildBST(num, 0, num.size()-1);\n   32      }\n\n/Users/Sean/Sean/Interview/Leetcode/Convert Sorted List to Binary Search Tree.cpp:\n    8   */\n    9  /**\n   10:  * Definition for binary tree\n   11:  * struct TreeNode {\n   12   *     int val;\n   13:  *     TreeNode *left;\n   14:  *     TreeNode *right;\n   15:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n   16   * };\n   17   */\n   18  class Solution {\n   19  public:\n   20:     TreeNode *buildBST(ListNode *&head, int start, int end)\n   21      {\n   22:         TreeNode *left, *right, *parent;\n   23          int mid;\n   24          \n   ..\n   28          mid = (start + end) >> 1;\n   29          \n   30:         //build left subtree, after finishing, head will move to mid.\n   31          left = buildBST(head, start, mid-1);\n   32          \n   33:         parent = new TreeNode(head->val);\n   34          parent->left = left;\n   35          \n   ..\n   42      }\n   43      \n   44:     TreeNode *sortedListToBST(ListNode *head) {\n   45          \n   46          ListNode *p = head;\n\n/Users/Sean/Sean/Interview/Leetcode/Flatten Binary Tree to Linked List.cpp:\n    1  #if 1\n    2: //advanced solution: http://jane4532.blogspot.tw/2013/07/flatten-binary-tree-to-linked.html\n    3  //tmp is the root node after build()\n    4  class Solution {\n    5  public:\n    6:     void build(TreeNode *root, TreeNode *&tmp)\n    7      {\n    8          if(root)\n    .\n   16          }\n   17      }\n   18:     void flatten(TreeNode *root) {\n   19          // Start typing your C/C++ solution below\n   20          // DO NOT write int main() function\n   21:         TreeNode *tmp=NULL;\n   22          build(root, tmp);\n   23  \n   ..\n   29  \n   30      //leaf: the last node in preorder after do_flatten\n   31:     void do_flatten(TreeNode *&root, TreeNode *&leaf)\n   32      {\n   33:         TreeNode *left_leaf, *right_leaf;\n   34  \n   35          if (!root)\n   ..\n   62  \n   63  \n   64:     void flatten(TreeNode *root) {\n   65:         TreeNode *leaf;\n   66          do_flatten(root, leaf);\n   67      }\n\n~/Sean/Interview/Leetcode/leetcode.IAB:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PR:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n~/Sean/Interview/Leetcode/leetcode.WK3:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Maximum Depth of Binary Tree.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     int maxDepth(TreeNode *root) {\n   13          \n   14          int left_depth, right_depth;\n\n/Users/Sean/Sean/Interview/Leetcode/Minimum Depth of Binary Tree.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  class Solution {\n   12  public:\n   13:     int minDepth(TreeNode *root) {\n   14  \n   15          int left_min, right_min;\n   ..\n   20          right_min = minDepth(root->right);\n   21  \n   22:         //if left_tree does not exist, the min_depth is the min_depth of the right_tree.\n   23          if (left_min == 0)\n   24              return right_min + 1;\n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum II.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12      \n   13:     void findPathSum(TreeNode *root, int sum, vector<vector<int> > &res, vector<int> &one_sol)\n   14      {\n   15          if (!root)\n   ..\n   30      }\n   31      \n   32:     vector<vector<int> > pathSum(TreeNode *root, int sum) {\n   33          vector<vector<int> >res;\n   34          vector<int>one_sol;\n\n/Users/Sean/Sean/Interview/Leetcode/Path Sum.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool hasPathSum(TreeNode *root, int sum) {\n   13          \n   14          bool left, right;\n\n/Users/Sean/Sean/Interview/Leetcode/Populating Next Right Pointers in Each Node II.cpp:\n    2  //2. use BFS concept.\n    3  /**\n    4:  * Definition for binary tree with next pointer.\n    5:  * struct TreeLinkNode {\n    6   *  int val;\n    7:  *  TreeLinkNode *left, *right, *next;\n    8:  *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}\n    9   * };\n   10   */\n   ..\n   12  public:\n   13  \n   14:     void connect(TreeLinkNode *root) {\n   15          \n   16:         TreeLinkNode *curr = root, *pre = 0, *next = 0;\n   17          \n   18          while (curr)\n\n/Users/Sean/Sean/Interview/Leetcode/Populating Next Right Pointers in Each Node.cpp:\n    1  /**\n    2:  * Definition for binary tree with next pointer.\n    3:  * struct TreeLinkNode {\n    4   *  int val;\n    5:  *  TreeLinkNode *left, *right, *next;\n    6:  *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}\n    7   * };\n    8   */\n    9  class Solution {\n   10  public:\n   11:     void connect(TreeLinkNode *root) {\n   12          \n   13          if (!root)\n\n/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int find_err_node(TreeNode *root, TreeNode *&pre_node, TreeNode *&large_err, TreeNode *&small_err)\n   14      {\n   15          if (!root)\n   ..\n   36      }\n   37      \n   38:     void recoverTree(TreeNode *root) {\n   39          \n   40          int temp;\n   41          \n   42:         TreeNode *large_err_node = 0, *small_err_node = 0, *pre_node = 0;\n   43          find_err_node(root, pre_node, large_err_node, small_err_node);\n   44  \n\n/Users/Sean/Sean/Interview/Leetcode/Same Tree.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool isSameTree(TreeNode *p, TreeNode *q) {\n   13          \n   14          if (!p && !q)\n   ..\n   18              return false;\n   19  \n   20:         if (isSameTree(p->left, q->left) \n   21:             && isSameTree(p->right, q->right)\n   22              && p->val == q->val)            \n   23              return true;\n\n/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     void findNumber(TreeNode *root, int one_num, int &sum)\n   14      {\n   15          if (!root)\n   ..\n   29      }\n   30      \n   31:     int sumNumbers(TreeNode *root) {\n   32          int one_num = 0, sum = 0;\n   33          findNumber(root, one_num, sum);\n\n/Users/Sean/Sean/Interview/Leetcode/Symmetric Tree.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   10  class Solution {\n   11  public:\n   12:     bool isSymmetricTree(TreeNode *left_root, TreeNode *right_root)\n   13      {\n   14          if (!left_root && !right_root)\n   ..\n   19  \n   20          if (left_root->val == right_root->val\n   21:             && isSymmetricTree(left_root->left, right_root->right)\n   22:             && isSymmetricTree(right_root->left, left_root->right))\n   23              return true;\n   24  \n   ..\n   27      }\n   28  \n   29:     bool isSymmetric(TreeNode *root) {\n   30  \n   31          if (!root) return true;\n   32          else\n   33:             return isSymmetricTree(root->left, root->right);\n   34      }\n   35  };\n\n/Users/Sean/Sean/Interview/Leetcode/Unique Binary Search Trees II.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   11  public:\n   12  \n   13:     int genBST(vector<TreeNode *> &res, int start, int end)\n   14      {\n   15:         vector<TreeNode *>left, right;\n   16  \n   17          if (start > end)\n   ..\n   30                  for (int k = 0; k < right.size(); k++)\n   31                  {\n   32:                     TreeNode *root = new TreeNode(i);\n   33                      root->left = left[j];\n   34                      root->right = right[k];\n   ..\n   39      }\n   40  \n   41:     vector<TreeNode *> generateTrees(int n) {\n   42:         vector<TreeNode *>res;\n   43          genBST(res, 1, n);\n   44          return res;\n\n/Users/Sean/Sean/Interview/Leetcode/Unique Binary Search Trees.cpp:\n    1  class Solution {\n    2  public:\n    3:     int numTrees(int n) {\n    4  \n    5          int total = 0;\n    .\n   12          for (int i = 1; i <= n; i++)\n   13          {\n   14:             //left subtree (1,2.. i-1), i-1 number\n   15:             int left_num = numTrees(i-1);\n   16:             //right subtree (i+1, i+2,...n), n-1 number\n   17:             int right_num = numTrees(n-i);\n   18              total += left_num*right_num;\n   19          }\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n    1  /**\n    2:  * Definition for binary tree\n    3:  * struct TreeNode {\n    4   *     int val;\n    5:  *     TreeNode *left;\n    6:  *     TreeNode *right;\n    7:  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n    8   * };\n    9   */\n   ..\n   12  class Solution {\n   13  public:\n   14:     bool verifyBST(TreeNode *root, TreeNode *&pre_node)\n   15      {\n   16          if (!root) return true;\n   ..\n   31      }\n   32  \n   33:     bool isValidBST(TreeNode *root) {\n   34:         TreeNode *pre_node = 0;\n   35          return verifyBST(root, pre_node);\n   36      }\n\n<untitled 242>:\n    3  dep_right = getDepth(root->right)\n    4  \n    5: if (isSymmeTree(root->left) && isSymmeTree(root->right) && dep_left-dep_right <= 1)\n\n<untitled 272>:\n    1: struct TreeNode\n    2  {\n    3      int val;\n    4:     TreeNode *left;\n    5:     TreeNode *right;\n    6:     TreeNode (int x): val(x), left(NULL), right(NULL) {}\n    7  \n    8  };\n\n280 matches across 32 files\n\n\nSearching 172 files for \"longestConsecutive\"\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Longest Consecutive Sequence.cpp:\n    2  class Solution {\n    3  public:\n    4:     int longestConsecutive(vector<int> &num) {\n    5          map<int, int>hash_table;\n    6          int count;\n\n2 matches across 2 files\n\n\nSearching 173 files for \"strtok\"\n\n/Users/Sean/Sean/Interview/Leetcode/Compare Version Numbers.cpp:\n   14          strcpy (str2, version2.c_str());\n   15  \n   16:         token1 = strtok(str1, \".\");\n   17          while (token1)\n   18          {\n   19              num1.push_back(atoi(token1));\n   20:             token1 = strtok(NULL, \".\");\n   21          }\n   22  \n   23:         token2 = strtok(str2, \".\");\n   24          while (token2)\n   25          {\n   26              num2.push_back(atoi(token2));\n   27:             token2 = strtok(NULL, \".\");\n   28          }\n   29  \n\n4 matches in 1 file\n\n\nSearching 173 files for \"hop\"\n\n0 matches across 0 files\n\n\nSearching 191 files for \"verifybst\"\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n   12  class Solution {\n   13  public:\n   14:     bool verifyBST(TreeNode *root, TreeNode *&pre_node)\n   15      {\n   16          if (!root) return true;\n   17  \n   18:         if (!verifyBST(root->left, pre_node))\n   19              return false;\n   20  \n   ..\n   25          pre_node = root;\n   26  \n   27:         if (!verifyBST(root->right, pre_node))\n   28              return false;\n   29  \n   ..\n   33      bool isValidBST(TreeNode *root) {\n   34          TreeNode *pre_node = 0;\n   35:         return verifyBST(root, pre_node);\n   36      }\n   37  };\n\n5 matches across 2 files\n\n\nSearching 191 files for \"verifybst\"\n\n~/Sean/Interview/Leetcode/leetcode.PS:\n    <binary>\n\n/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp:\n   12  class Solution {\n   13  public:\n   14:     bool verifyBST(TreeNode *root, TreeNode *&pre_node)\n   15      {\n   16          if (!root) return true;\n   17  \n   18:         if (!verifyBST(root->left, pre_node))\n   19              return false;\n   20  \n   ..\n   25          pre_node = root;\n   26  \n   27:         if (!verifyBST(root->right, pre_node))\n   28              return false;\n   29  \n   ..\n   33      bool isValidBST(TreeNode *root) {\n   34          TreeNode *pre_node = 0;\n   35:         return verifyBST(root, pre_node);\n   36      }\n   37  };\n\n5 matches across 2 files\n",
			"settings":
			{
				"buffer_size": 322462,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "Compare Version Numbers.cpp",
			"settings":
			{
				"buffer_size": 1798,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "class Solution {\npublic:\n    string fractionToDecimal(int numerator, int denominator) {\n        string res;\n        int n = numerator;\n        int d = denominator;\n        int r;\n        map<int, in\n        \n        res += to_string(n/d);\n        r = n % d;\n        if (r == 0)\n            return res;\n            \n        res += \".\"\n        \n        while (r)\n        {\n            \n        }\n    }\n};",
			"settings":
			{
				"buffer_size": 402,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Binary Search Tree Iterator.cpp",
			"settings":
			{
				"buffer_size": 1324,
				"line_ending": "Unix",
				"name": "//Inorder iterative solution"
			}
		},
		{
			"file": "Factorial Trailing Zeroes.cpp",
			"settings":
			{
				"buffer_size": 423,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Fraction to Recurring Decimal.cpp",
			"settings":
			{
				"buffer_size": 1074,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Palindrome Number.cpp",
			"settings":
			{
				"buffer_size": 691,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Palindrome Partitioning.cpp",
			"settings":
			{
				"buffer_size": 939,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Validate Binary Search Tree.cpp",
			"settings":
			{
				"buffer_size": 870,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "n = find(root->left, k, found);\n\nif (n)\n    return n;\n\nif (root->val == k)\n    found = 1;\n\nif (root->val > k)\n{\n    if (found)\n        return root;\n    else\n        return 0;\n} \n\nn = find(root->right, k, found);\n\nreturn n;\n",
			"settings":
			{
				"buffer_size": 223,
				"line_ending": "Unix",
				"name": "n = find(root->left, k, found);"
			}
		},
		{
			"contents": "\nif (root->val == val)\n    return root;\nleft =  findLCA(root->left, val);\nif (left && right)\n    return root;\nreturn (left) ? (left) : (right)",
			"settings":
			{
				"buffer_size": 142,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "\ndep_left = getDepth(root->left)\ndep_right = getDepth(root->right)\n\nif (isSymmeTree(root->left) && isSymmeTree(root->right) && dep_left-dep_right <= 1)",
			"settings":
			{
				"buffer_size": 151,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Balanced Binary Tree.cpp",
			"settings":
			{
				"buffer_size": 805,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Infix to Postfix.cpp",
			"settings":
			{
				"buffer_size": 92,
				"line_ending": "Unix",
				"name": "http://www.c4learn.com/data-structure/algorithm-fo"
			}
		},
		{
			"file": "Add Two Numbers.cpp",
			"settings":
			{
				"buffer_size": 1300,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Generate N-digit number.cpp",
			"settings":
			{
				"buffer_size": 585,
				"line_ending": "Unix",
				"name": "void printNum(vector<char> &num)"
			}
		},
		{
			"file": "Maximum Subarray.cpp",
			"settings":
			{
				"buffer_size": 408,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Big Integer.cpp",
			"settings":
			{
				"buffer_size": 1791,
				"line_ending": "Unix",
				"name": "vector<int> covertToBigInt(string str)"
			}
		},
		{
			"file": "LRU Cache.cpp",
			"settings":
			{
				"buffer_size": 1727,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Search a 2D Matrix.cpp",
			"settings":
			{
				"buffer_size": 976,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Trapping Rain Water.cpp",
			"settings":
			{
				"buffer_size": 3431,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Flatten Binary Tree to Linked List.cpp",
			"settings":
			{
				"buffer_size": 1537,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Unique Paths II.cpp",
			"settings":
			{
				"buffer_size": 740,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Unique Paths.cpp",
			"settings":
			{
				"buffer_size": 376,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Single Number.cpp",
			"settings":
			{
				"buffer_size": 186,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Single Number II.cpp",
			"settings":
			{
				"buffer_size": 946,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Longest Consecutive Sequence.cpp",
			"settings":
			{
				"buffer_size": 1016,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Next Permutation.cpp",
			"settings":
			{
				"buffer_size": 1410,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Permutations II.cpp",
			"settings":
			{
				"buffer_size": 1065,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Two Sum.cpp",
			"settings":
			{
				"buffer_size": 2262,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Combination Sum II.cpp",
			"settings":
			{
				"buffer_size": 1392,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Longest Substring Without Repeating Characters.cpp",
			"settings":
			{
				"buffer_size": 687,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Construct Binary Tree from Inorder and Postorder Traversal.cpp",
			"settings":
			{
				"buffer_size": 1622,
				"line_ending": "Unix",
				"name": "/**"
			}
		},
		{
			"file": "Clone Graph.cpp",
			"settings":
			{
				"buffer_size": 2459,
				"line_ending": "Unix",
				"name": "//refer http://fisherlei.blogspot.com/2013/12/leet"
			}
		},
		{
			"file": "Find Minimum in Rotated Sorted Array II.cpp",
			"settings":
			{
				"buffer_size": 655,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Excel Sheet Column Number.cpp",
			"settings":
			{
				"buffer_size": 198,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Maximum Depth of Binary Tree.cpp",
			"settings":
			{
				"buffer_size": 585,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Intersection of Two Linked Lists.cpp",
			"settings":
			{
				"buffer_size": 1059,
				"line_ending": "Unix",
				"name": "/**"
			}
		},
		{
			"file": "Word Ladder.cpp",
			"settings":
			{
				"buffer_size": 1369,
				"line_ending": "Unix",
				"name": "// http://www.programcreek.com/2012/12/leetcode-wo"
			}
		},
		{
			"contents": "class Solution {\npublic:\n    void solve(vector<vector<char>> &board) {\n        int row = board.size();\n        if(row <= 1)\n            return;\n        int col = board[0].size();\n        if(col <= 1)\n            return;\n		\n        //从最外面的一圈进行dfs\n        //top一行\n        for(int i=0;i<col;i++)\n        {\n            if(board[0][i] == 'O')\n            {\n                board[0][i] = '#';\n                dfs(board, 0, i, row, col);\n            }\n        }\n        // bottom一行\n        for(int i=0;i<col;i++)\n        {\n            if(board[row-1][i] == 'O')\n            {\n                board[row-1][i] = '#';\n                dfs(board, row-1, i, row, col);\n            }\n        }\n        //left一列\n        for(int i=1;i<row-1;i++)\n        {\n            if(board[i][0] == 'O')\n            {\n                board[i][0] = '#';\n                dfs(board, i, 0, row, col);\n            }\n        }\n        // right一列\n        for(int i=1;i<row-1;i++)\n        {\n            if(board[i][col-1] == 'O')\n            {\n                board[i][col-1] = '#';\n                dfs(board, i, col-1, row, col);\n            }\n        }\n\n        //将'O'变为'X'，将'#'恢复回'O'\n        for(int i=0;i<row;i++)\n            for(int j=0;j<col;j++)\n            {\n                if(board[i][j] == 'O')\n                    board[i][j] = 'X';\n                else if(board[i][j] == '#')\n                    board[i][j] = 'O';\n            }\n    }\n\n    void dfs(vector<vector<char>> &board, int i, int j, int row, int col)\n    {\n        if(i > 0 && board[i-1][j] == 'O')\n        {\n            board[i-1][j] = '#';\n            dfs(board, i-1, j, row, col);\n        }\n        if(i < row-2 && board[i+1][j] == 'O')   \n        {\n            board[i+1][j] = '#';\n            dfs(board, i+1, j, row, col);\n        }\n        if(j > 0 && board[i][j-1] == 'O')\n        {\n            board[i][j-1] = '#';\n            dfs(board, i, j-1, row, col);\n        }\n        if(j < col-2 && board[i][j+1] == 'O')\n        {\n            board[i][j+1] = '#';\n            dfs(board, i, j+1, row, col);\n        }\n    }\n};",
			"file": "/Users/Sean/Downloads/ac.cpp",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 2059,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Surrounded Regions.cpp",
			"settings":
			{
				"buffer_size": 3415,
				"line_ending": "Unix",
				"name": "//http://blog.csdn.net/ojshilu/article/details/226"
			}
		},
		{
			"file": "Jump Game.cpp",
			"settings":
			{
				"buffer_size": 511,
				"line_ending": "Unix",
				"name": "// http://fisherlei.blogspot.com/2012/12/leetcode-"
			}
		},
		{
			"file": "Permutations.cpp",
			"settings":
			{
				"buffer_size": 833,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Valid Sudoku.cpp",
			"settings":
			{
				"buffer_size": 815,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Combinations.cpp",
			"settings":
			{
				"buffer_size": 627,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Sort List.cpp",
			"settings":
			{
				"buffer_size": 3287,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Decode Ways.cpp",
			"settings":
			{
				"buffer_size": 1113,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "struct TreeNode\n{\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode (int x): val(x), left(NULL), right(NULL) {}\n\n};",
			"settings":
			{
				"buffer_size": 132,
				"line_ending": "Unix",
				"name": "struct TreeNode"
			}
		},
		{
			"file": "Quicksort.c",
			"settings":
			{
				"buffer_size": 750,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Search Insert Position.cpp",
			"settings":
			{
				"buffer_size": 500,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Search in Rotated Sorted Array.cpp",
			"settings":
			{
				"buffer_size": 1173,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Divide Two Integers.cpp",
			"settings":
			{
				"buffer_size": 1095,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Sean/Sean/Interview/codility/NumberSolitaire.cpp",
			"settings":
			{
				"buffer_size": 460,
				"line_ending": "Unix",
				"name": "#include <limits.h>"
			}
		},
		{
			"file": "Median of Two Sorted Arrays.cpp",
			"settings":
			{
				"buffer_size": 1300,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "0....  3\n      -3\n      -2\n0 1 1 1 1 1 0 -1 -2 -3 -4\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 ",
			"settings":
			{
				"buffer_size": 85,
				"line_ending": "Unix",
				"name": "0....  3"
			}
		},
		{
			"file": "Longest Palindromic Substring.cpp",
			"settings":
			{
				"buffer_size": 1105,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Search for a Range.cpp",
			"settings":
			{
				"buffer_size": 1879,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Find Minimum in Rotated Sorted Array.cpp",
			"settings":
			{
				"buffer_size": 651,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Max Points on a Line.cpp",
			"settings":
			{
				"buffer_size": 1601,
				"line_ending": "Windows"
			}
		},
		{
			"file": "3Sum Closest.cpp",
			"settings":
			{
				"buffer_size": 1147,
				"line_ending": "Windows"
			}
		},
		{
			"file": "4Sum.cpp",
			"settings":
			{
				"buffer_size": 1927,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Candy.cpp",
			"settings":
			{
				"buffer_size": 1435,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Binary Tree Level Order Traversal II.cpp",
			"settings":
			{
				"buffer_size": 1072,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Binary Tree Maximum Path Sum.cpp",
			"settings":
			{
				"buffer_size": 1669,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Add Binary.cpp",
			"settings":
			{
				"buffer_size": 732,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode *p, TreeNode *q) {\n        \n        if (!p && !q)\n            return true;\n        \n        if (!p || !q)\n            return false;\n\n        if (isSameTree(p->left, q->left) \n            && isSameTree(p->right, q->right)\n            && p->val == q->val)            \n            return true;\n        else\n            return false;\n    }\n",
			"file": "Same Tree.cpp",
			"file_size": 580,
			"file_write_time": 130350510570000000,
			"settings":
			{
				"buffer_size": 578,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Container With Most Water.cpp",
			"settings":
			{
				"buffer_size": 608,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Anagrams.cpp",
			"settings":
			{
				"buffer_size": 980,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Construct Binary Tree from Preorder and Inorder Traversal.cpp",
			"settings":
			{
				"buffer_size": 1471,
				"line_ending": "Unix",
				"name": "/**"
			}
		},
		{
			"file": "3Sum.cpp",
			"settings":
			{
				"buffer_size": 1498,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "stack<int>\nmap<int, string>\nvector<>\n\nmap<int, int>hashtable\nvector\n\nhash.find(i) != hash.end()\nvector<int>table;\n\ntable[0].assign(table[0].size(), 0);",
			"settings":
			{
				"buffer_size": 151,
				"line_ending": "Unix",
				"name": "stack<int>"
			}
		},
		{
			"file": "Pow(x, n).cpp",
			"settings":
			{
				"buffer_size": 392,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Unique Binary Search Trees.cpp",
			"settings":
			{
				"buffer_size": 508,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Unique Binary Search Trees II.cpp",
			"settings":
			{
				"buffer_size": 1091,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Regular Expression Matching.cpp",
			"settings":
			{
				"buffer_size": 1598,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "middle initial",
			"settings":
			{
				"buffer_size": 14,
				"line_ending": "Unix",
				"name": "middle initial"
			}
		},
		{
			"file": "Binary Tree Level Order Traversal.cpp",
			"settings":
			{
				"buffer_size": 859,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "a\na*",
			"settings":
			{
				"buffer_size": 4,
				"line_ending": "Unix",
				"name": "a"
			}
		},
		{
			"file": "Gas Station.cpp",
			"settings":
			{
				"buffer_size": 938,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Best Time to Buy and Sell Stock.cpp",
			"settings":
			{
				"buffer_size": 404,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Path Sum.cpp",
			"settings":
			{
				"buffer_size": 552,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Path Sum II.cpp",
			"settings":
			{
				"buffer_size": 1037,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Maximum Product Subarray.cpp",
			"settings":
			{
				"buffer_size": 704,
				"line_ending": "Unix",
				"name": "//refer http://blog.csdn.net/worldwindjp/article/d"
			}
		},
		{
			"file": "Longest Common Prefix.cpp",
			"settings":
			{
				"buffer_size": 576,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Set Matrix Zeroes Total.cpp",
			"settings":
			{
				"buffer_size": 1300,
				"line_ending": "Unix",
				"name": "//refer http://fisherlei.blogspot.com/2013/01/leet"
			}
		},
		{
			"file": "Length of Last Word.cpp",
			"settings":
			{
				"buffer_size": 440,
				"line_ending": "Unix",
				"name": "class Solution {"
			}
		},
		{
			"file": "Binary Tree Inorder Traversal.cpp",
			"settings":
			{
				"buffer_size": 607,
				"line_ending": "Unix",
				"name": "/**"
			}
		},
		{
			"file": "Count and Say.cpp",
			"settings":
			{
				"buffer_size": 814,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Climbing Stairs.cpp",
			"settings":
			{
				"buffer_size": 428,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Best Time to Buy and Sell Stock II.cpp",
			"settings":
			{
				"buffer_size": 419,
				"line_ending": "Unix",
				"name": "//refer http://blog.unieagle.net/2012/12/04/leetco"
			}
		},
		{
			"file": "Valid Number.cpp",
			"settings":
			{
				"buffer_size": 1930,
				"line_ending": "Windows"
			}
		},
		{
			"file": "Valid Palindrome.cpp",
			"settings":
			{
				"buffer_size": 469,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Subsets.cpp",
			"settings":
			{
				"buffer_size": 1595,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 467.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/Users/Sean/Sean/Interview/Leetcode"
	],
	"file_history":
	[
		"/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Pascal's Triangle.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Palindrome Partitioning II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Binary Tree Postorder Traversal.cpp",
		"/Users/Sean/Downloads/Cooking the Books.cpp",
		"/Users/Sean/Sean/Interview/Apple/20141212/scale_image/bmp_lib/bmplib/readbmp.h",
		"/Users/Sean/Sean/Interview/Apple/20141212/scale_image/bmp_lib/bmplib/readbmp.c",
		"/Users/Sean/Sean/Interview/Leetcode/Remove Element.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Partition List.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/leetcode.IAB",
		"/Users/Sean/Sean/CMU/course/18-645_How to Write Fast Code/link.txt",
		"/Users/Sean/Sean/Interview/Leetcode/Plus One.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Unique Paths.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Unique Paths II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Recover Binary Search Tree.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/leetcode.PO",
		"/Users/Sean/Sean/Interview/Leetcode/String to Integer (atoi).cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Swap Nodes in Pairs.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Best Time to Buy and Sell Stock.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Binary Tree Level Order Traversal.cpp",
		"/Users/Sean/Sean/Movie/temp/name.txt",
		"/Users/Sean/Sean/Interview/Leetcode/Minimum Window Substring.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/leetcode.sublime-project",
		"/Users/Sean/Sean/Interview/Leetcode/Sum Root to Leaf Numbers.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Minimum Path Sum.cpp",
		"/Users/Sean/Sean/Interview/codility/TieRopes.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Excel Sheet Column Title.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Compare Version Numbers.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Valid Parentheses.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Reverse Linked List II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Substring with Concatenation of All Words.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Triangle.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Reverse Words in a String.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Container With Most Water.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Letter Combinations of a Phone Number.cpp",
		"/Users/Sean/Sean/Interview/Microsoft/20141209_onsite.txt",
		"/Users/Sean/Sean/Interview/Microsoft/20141209_onsite2.txt",
		"/Users/Sean/Sean/Interview/Leetcode/Longest Valid Parentheses.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/leetcode.SearchResults",
		"/Users/Sean/Sean/Interview/Leetcode/Merge k Sorted Lists.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Evaluate Reverse Polish Notation.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Median of Two Sorted Arrays.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted List II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted List.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Find Peak Element.cpp",
		"/Users/Sean/Sean/Interview/Google/201412/20141204-1.txt",
		"/Users/Sean/Sean/Interview/Google/201412/20141204-2.txt",
		"/Users/Sean/Sean/Interview/Leetcode/Maximum Depth of Binary Tree.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Insert Interval.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Divide Two Integers.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Decode Ways.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Populating Next Right Pointers in Each Node II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/leetcode.PRI",
		"/Users/Sean/Downloads/org.cpp",
		"/Users/Sean/Sean/Interview/Nvidia/20141126.txt",
		"/Users/Sean/Sean/Interview/Leetcode/Maximum Subarray.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Binary Tree Zigzag Level Order Traversal.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Length of Last Word.py",
		"/Users/Sean/Sean/Interview/eBook/link.txt",
		"/Users/Sean/Sean/Interview/Snapchat/code.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Longest Common Prefix.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Sqrt(x).cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Pow(x, n).cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Path Sum.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Palindrome Number.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Sort Colors.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Insertion Sort List.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Valid Sudoku.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Validate Binary Search Tree.cpp",
		"/Users/Sean/Sean/Interview/Nvidia/201410/Yu Huan Hsu.txt",
		"/Users/Sean/Sean/Interview/Facebook/20141023.txt",
		"/Users/Sean/Sean/Interview/Leetcode/Next Permutation.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Add Two Numbers.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Word Break II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Balanced Binary Tree.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Subsets II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Search a 2D Matrix.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Search for a Range.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Remove Duplicates from Sorted Array II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Regular Expression Matching.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/N-Queens.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Remove Nth Node From End of List.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Search in Rotated Sorted Array.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Linked List Cycle.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Reverse Integer.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Trapping Rain Water.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Merge Intervals.cpp",
		"/Users/Sean/Sean/CMU/course/15-619_Cloud Computing/Project/Project3/3.1_Files vs Databases/link.txt",
		"/Users/Sean/Sean/Tool_Mac/link.txt",
		"/Users/Sean/Sean/CMU/course/15-619_Cloud Computing/Project/Project2/2.2_Junior System Architect at the MSB/project2.2_python/auto_scaling_group.py",
		"/Users/Sean/Sean/Interview/Leetcode/Permutations.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Populating Next Right Pointers in Each Node.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Longest Consecutive Sequence.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Combination Sum II.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Combination Sum.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Combinations.cpp",
		"/Users/Sean/Sean/Interview/Leetcode/Candy.cpp",
		"/Users/Sean/Sean/CMU/course/18-655_Service Oriented Computing/Homework/Lab2/Lab2_shenghow/TravelInfo/src/org/me/QueryInfoServlet.java",
		"/Users/Sean/Sean/CMU/course/18-655_Service Oriented Computing/Homework/Lab2/Lab2_shenghow/TravelInfo/src/org/me/FlightInfo.java",
		"/Users/Sean/Sean/CMU/course/18-655_Service Oriented Computing/Homework/Lab2/Lab2_shenghow/TravelInfo/src/org/me/Lab2.sublime-project",
		"/Users/Sean/Sean/CMU/course/18-655_Service Oriented Computing/Homework/Lab2/Lab2_shenghow/TravelInfo/src/org/me/Lab2.sublime-workspace",
		"/Users/Sean/Sean/CMU/course/18-655_Service Oriented Computing/Homework/Lab2/Lab2_shenghow/TravelInfo/WebContent/queryTravelInfo/result.jsp",
		"/Users/Sean/Sean/CMU/course/18-655_Service Oriented Computing/Homework/Lab2/Lab2_shenghow/TravelInfo/WebContent/WEB-INF/web.xml",
		"/Volumes/Untitled/CMU/course/15-513_Introduction to Computer Systems/Homework/malloclab/malloclab_win32/malloclab_win32/mdriver.c",
		"/Users/Sean/Library/Application Support/Sublime Text 3/Packages/User/Preferences.sublime-settings"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"verifybst",
			"hop",
			"strtok",
			"longestConsecutive",
			"next per",
			"tree",
			"map",
			"find",
			"verifyBST",
			"isbst",
			"ispalindrome",
			"validBST",
			"map",
			"find",
			"lower_bound",
			"treeNode",
			"getdepth",
			"treeNode",
			"genNum",
			"[",
			"[]",
			"list",
			"treenode",
			"find",
			"[]",
			"map",
			"m_map",
			"find",
			"end",
			"map",
			"stack<",
			"popped",
			"pop_back",
			"int a[]",
			"map",
			"stack",
			"listNode",
			"find",
			"end()",
			"pop_back",
			"map"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 34,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Pascal's Triangle II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 516,
						"regions":
						{
						},
						"selection":
						[
							[
								436,
								436
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 19,
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Min Stack.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 574,
						"regions":
						{
						},
						"selection":
						[
							[
								357,
								357
							]
						],
						"settings":
						{
							"auto_name": "class MinStack {",
							"function_name_status_row": 14,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 57,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "Is Stack Pop Order.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 634,
						"regions":
						{
						},
						"selection":
						[
							[
								371,
								371
							]
						],
						"settings":
						{
							"auto_name": "bool isPopOrder(vector<int>pushOrder, vector<int>p",
							"function_name_status_row": 17,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 83,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "Copy List with Random Pointer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1379,
						"regions":
						{
						},
						"selection":
						[
							[
								2,
								82
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 114,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "Binary Tree Preorder Traversal.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 775,
						"regions":
						{
						},
						"selection":
						[
							[
								299,
								299
							]
						],
						"settings":
						{
							"function_name_status_row": 15,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 110,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "Populating Next Right Pointers in Each Node.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 727,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "Reorder List.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1382,
						"regions":
						{
						},
						"selection":
						[
							[
								1008,
								1008
							]
						],
						"settings":
						{
							"auto_name": "/**",
							"function_name_status_row": 42,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 71,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "N-Queens.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1499,
						"regions":
						{
						},
						"selection":
						[
							[
								766,
								766
							]
						],
						"settings":
						{
							"function_name_status_row": 26,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 58,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "N-Queens II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1001,
						"regions":
						{
						},
						"selection":
						[
							[
								670,
								670
							]
						],
						"settings":
						{
							"function_name_status_row": 25,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 141.0,
						"zoom_level": 1.0
					},
					"stack_index": 21,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "Populating Next Right Pointers in Each Node II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1328,
						"regions":
						{
						},
						"selection":
						[
							[
								14,
								85
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "Remove Nth Node From End of List.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 682,
						"regions":
						{
						},
						"selection":
						[
							[
								288,
								288
							]
						],
						"settings":
						{
							"function_name_status_row": 10,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 116,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "First Missing Positive.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 735,
						"regions":
						{
						},
						"selection":
						[
							[
								596,
								596
							]
						],
						"settings":
						{
							"function_name_status_row": 20,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 70,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "partition.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 430,
						"regions":
						{
						},
						"selection":
						[
							[
								53,
								53
							]
						],
						"settings":
						{
							"auto_name": "void partition(vector<int> &data, int start, int e",
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 69,
					"type": "text"
				},
				{
					"buffer": 13,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 866,
						"regions":
						{
						},
						"selection":
						[
							[
								866,
								866
							]
						],
						"settings":
						{
							"function_name_status_row": 24,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"word_wrap": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 68,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "Combination Sum.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1121,
						"regions":
						{
						},
						"selection":
						[
							[
								266,
								266
							]
						],
						"settings":
						{
							"function_name_status_row": 9,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 59,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "Convert Sorted Array to Binary Search Tree.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 881,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 67,
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "Convert Sorted List to Binary Search Tree.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1189,
						"regions":
						{
						},
						"selection":
						[
							[
								597,
								597
							]
						],
						"settings":
						{
							"function_name_status_row": 27,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 66,
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "MergeSort.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1201,
						"regions":
						{
						},
						"selection":
						[
							[
								1151,
								1156
							]
						],
						"settings":
						{
							"function_name_status_row": 59,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 56,
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "Rotate List.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 933,
						"regions":
						{
						},
						"selection":
						[
							[
								256,
								256
							]
						],
						"settings":
						{
							"function_name_status_row": 13,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 92,
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "Search in Rotated Sorted Array II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1390,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 91,
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "Reverse Integer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 387,
						"regions":
						{
						},
						"selection":
						[
							[
								374,
								377
							]
						],
						"settings":
						{
							"function_name_status_row": 13,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "Reverse Words in a String.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2201,
						"regions":
						{
						},
						"selection":
						[
							[
								465,
								481
							]
						],
						"settings":
						{
							"function_name_status_row": 21,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 26,
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "Largest Number.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 517,
						"regions":
						{
						},
						"selection":
						[
							[
								163,
								163
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 7,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 25,
					"type": "text"
				},
				{
					"buffer": 23,
					"file": "Merge Sorted Array.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 526,
						"regions":
						{
						},
						"selection":
						[
							[
								426,
								426
							]
						],
						"settings":
						{
							"function_name_status_row": 18,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 65,
					"type": "text"
				},
				{
					"buffer": 24,
					"file": "Merge Two Sorted Lists.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1430,
						"regions":
						{
						},
						"selection":
						[
							[
								976,
								976
							]
						],
						"settings":
						{
							"function_name_status_row": 46,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 55,
					"type": "text"
				},
				{
					"buffer": 25,
					"file": "Merge k Sorted Lists.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1451,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 396.0,
						"zoom_level": 1.0
					},
					"stack_index": 19,
					"type": "text"
				},
				{
					"buffer": 26,
					"file": "Merge Intervals.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1283,
						"regions":
						{
						},
						"selection":
						[
							[
								441,
								441
							]
						],
						"settings":
						{
							"function_name_status_row": 18,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 117,
					"type": "text"
				},
				{
					"buffer": 27,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 322462,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										178,
										183
									],
									[
										366,
										371
									],
									[
										619,
										624
									],
									[
										834,
										839
									],
									[
										912,
										917
									],
									[
										1149,
										1154
									],
									[
										1177,
										1182
									],
									[
										1217,
										1222
									],
									[
										1441,
										1446
									],
									[
										1726,
										1731
									],
									[
										2020,
										2025
									],
									[
										2230,
										2235
									],
									[
										2593,
										2598
									],
									[
										2756,
										2761
									],
									[
										2941,
										2946
									],
									[
										3208,
										3213
									],
									[
										3434,
										3439
									],
									[
										3700,
										3705
									],
									[
										3750,
										3755
									],
									[
										3972,
										3977
									],
									[
										4256,
										4261
									],
									[
										4462,
										4467
									],
									[
										4676,
										4681
									],
									[
										4842,
										4847
									],
									[
										5148,
										5153
									],
									[
										5373,
										5378
									],
									[
										5602,
										5607
									],
									[
										5952,
										5957
									],
									[
										6251,
										6256
									],
									[
										6518,
										6526
									],
									[
										6566,
										6574
									],
									[
										6596,
										6604
									],
									[
										6713,
										6721
									],
									[
										6730,
										6738
									],
									[
										6784,
										6792
									],
									[
										6802,
										6810
									],
									[
										6827,
										6835
									],
									[
										6943,
										6951
									],
									[
										6967,
										6975
									],
									[
										6981,
										6989
									],
									[
										7070,
										7078
									],
									[
										7324,
										7332
									],
									[
										7372,
										7380
									],
									[
										7402,
										7410
									],
									[
										7541,
										7549
									],
									[
										7707,
										7715
									],
									[
										7756,
										7764
									],
									[
										7987,
										7995
									],
									[
										8043,
										8051
									],
									[
										8088,
										8096
									],
									[
										8224,
										8232
									],
									[
										8255,
										8263
									],
									[
										8310,
										8318
									],
									[
										8354,
										8362
									],
									[
										8390,
										8398
									],
									[
										8529,
										8537
									],
									[
										8560,
										8568
									],
									[
										8808,
										8816
									],
									[
										8856,
										8864
									],
									[
										8886,
										8894
									],
									[
										9000,
										9008
									],
									[
										9028,
										9036
									],
									[
										9061,
										9069
									],
									[
										9099,
										9107
									],
									[
										9381,
										9389
									],
									[
										9429,
										9437
									],
									[
										9459,
										9467
									],
									[
										9573,
										9581
									],
									[
										9595,
										9603
									],
									[
										9636,
										9644
									],
									[
										9876,
										9884
									],
									[
										9924,
										9932
									],
									[
										9954,
										9962
									],
									[
										10082,
										10090
									],
									[
										10115,
										10123
									],
									[
										10349,
										10357
									],
									[
										10397,
										10405
									],
									[
										10427,
										10435
									],
									[
										10547,
										10555
									],
									[
										10576,
										10584
									],
									[
										10664,
										10672
									],
									[
										10902,
										10910
									],
									[
										10950,
										10958
									],
									[
										10980,
										10988
									],
									[
										11094,
										11102
									],
									[
										11118,
										11126
									],
									[
										11132,
										11140
									],
									[
										11163,
										11171
									],
									[
										11201,
										11209
									],
									[
										11349,
										11357
									],
									[
										11541,
										11549
									],
									[
										11561,
										11569
									],
									[
										11619,
										11627
									],
									[
										11838,
										11846
									],
									[
										12095,
										12103
									],
									[
										12143,
										12151
									],
									[
										12173,
										12181
									],
									[
										12287,
										12295
									],
									[
										12314,
										12322
									],
									[
										12347,
										12355
									],
									[
										12590,
										12598
									],
									[
										12638,
										12646
									],
									[
										12668,
										12676
									],
									[
										12782,
										12790
									],
									[
										12809,
										12817
									],
									[
										12842,
										12850
									],
									[
										13041,
										13049
									],
									[
										13068,
										13076
									],
									[
										13132,
										13140
									],
									[
										13376,
										13384
									],
									[
										13424,
										13432
									],
									[
										13454,
										13462
									],
									[
										13583,
										13591
									],
									[
										13637,
										13645
									],
									[
										13759,
										13767
									],
									[
										13792,
										13800
									],
									[
										14026,
										14034
									],
									[
										14080,
										14088
									],
									[
										14123,
										14131
									],
									[
										14218,
										14226
									],
									[
										14243,
										14251
									],
									[
										14290,
										14298
									],
									[
										14327,
										14335
									],
									[
										14532,
										14540
									],
									[
										14580,
										14588
									],
									[
										14610,
										14618
									],
									[
										14730,
										14738
									],
									[
										14752,
										14760
									],
									[
										14808,
										14816
									],
									[
										14862,
										14870
									],
									[
										15071,
										15079
									],
									[
										15119,
										15127
									],
									[
										15149,
										15157
									],
									[
										15253,
										15261
									],
									[
										15269,
										15277
									],
									[
										15286,
										15294
									],
									[
										15329,
										15337
									],
									[
										15381,
										15389
									],
									[
										15481,
										15489
									],
									[
										15501,
										15509
									],
									[
										15555,
										15563
									],
									[
										15687,
										15695
									],
									[
										15921,
										15929
									],
									[
										15940,
										15948
									],
									[
										16009,
										16017
									],
									[
										16197,
										16205
									],
									[
										16245,
										16253
									],
									[
										16275,
										16283
									],
									[
										16389,
										16397
									],
									[
										16409,
										16417
									],
									[
										16442,
										16450
									],
									[
										16597,
										16605
									],
									[
										16645,
										16653
									],
									[
										16675,
										16683
									],
									[
										16789,
										16797
									],
									[
										16809,
										16817
									],
									[
										16850,
										16858
									],
									[
										16910,
										16918
									],
									[
										17200,
										17205
									],
									[
										17320,
										17325
									],
									[
										17545,
										17550
									],
									[
										17672,
										17677
									],
									[
										17909,
										17914
									],
									[
										18069,
										18074
									],
									[
										18281,
										18286
									],
									[
										18401,
										18406
									],
									[
										18491,
										18496
									],
									[
										18635,
										18640
									],
									[
										18834,
										18839
									],
									[
										19000,
										19005
									],
									[
										19250,
										19255
									],
									[
										19292,
										19297
									],
									[
										19358,
										19363
									],
									[
										19435,
										19440
									],
									[
										19565,
										19570
									],
									[
										19736,
										19741
									],
									[
										19921,
										19926
									],
									[
										20214,
										20217
									],
									[
										20624,
										20627
									],
									[
										20824,
										20827
									],
									[
										20843,
										20846
									],
									[
										20974,
										20977
									],
									[
										21158,
										21161
									],
									[
										21177,
										21180
									],
									[
										21378,
										21381
									],
									[
										21751,
										21754
									],
									[
										21775,
										21778
									],
									[
										21814,
										21817
									],
									[
										21995,
										21998
									],
									[
										22188,
										22191
									],
									[
										22405,
										22408
									],
									[
										22569,
										22572
									],
									[
										22757,
										22760
									],
									[
										23016,
										23019
									],
									[
										23260,
										23263
									],
									[
										23308,
										23311
									],
									[
										23498,
										23501
									],
									[
										23678,
										23681
									],
									[
										23989,
										23992
									],
									[
										24019,
										24022
									],
									[
										24160,
										24163
									],
									[
										24442,
										24449
									],
									[
										24612,
										24619
									],
									[
										24789,
										24796
									],
									[
										25042,
										25049
									],
									[
										25280,
										25287
									],
									[
										25526,
										25533
									],
									[
										25740,
										25747
									],
									[
										25924,
										25931
									],
									[
										26087,
										26094
									],
									[
										26231,
										26238
									],
									[
										26433,
										26440
									],
									[
										26639,
										26646
									],
									[
										26859,
										26866
									],
									[
										27067,
										27074
									],
									[
										27252,
										27259
									],
									[
										27676,
										27683
									],
									[
										28302,
										28309
									],
									[
										28849,
										28857
									],
									[
										29178,
										29186
									],
									[
										29401,
										29409
									],
									[
										29663,
										29671
									],
									[
										29859,
										29867
									],
									[
										30118,
										30126
									],
									[
										30357,
										30365
									],
									[
										30593,
										30601
									],
									[
										30871,
										30879
									],
									[
										31094,
										31102
									],
									[
										31326,
										31334
									],
									[
										31574,
										31582
									],
									[
										31827,
										31835
									],
									[
										32071,
										32079
									],
									[
										32341,
										32349
									],
									[
										32490,
										32498
									],
									[
										32643,
										32651
									],
									[
										32912,
										32918
									],
									[
										33166,
										33172
									],
									[
										33390,
										33396
									],
									[
										33550,
										33556
									],
									[
										33795,
										33801
									],
									[
										33980,
										33986
									],
									[
										34079,
										34085
									],
									[
										34347,
										34350
									],
									[
										34757,
										34760
									],
									[
										34957,
										34960
									],
									[
										34976,
										34979
									],
									[
										35107,
										35110
									],
									[
										35291,
										35294
									],
									[
										35310,
										35313
									],
									[
										35511,
										35514
									],
									[
										35884,
										35887
									],
									[
										35908,
										35911
									],
									[
										35947,
										35950
									],
									[
										36128,
										36131
									],
									[
										36321,
										36324
									],
									[
										36536,
										36539
									],
									[
										36692,
										36695
									],
									[
										36880,
										36883
									],
									[
										37139,
										37142
									],
									[
										37383,
										37386
									],
									[
										37431,
										37434
									],
									[
										37621,
										37624
									],
									[
										37801,
										37804
									],
									[
										38112,
										38115
									],
									[
										38142,
										38145
									],
									[
										38283,
										38286
									],
									[
										38402,
										38405
									],
									[
										38641,
										38644
									],
									[
										38829,
										38832
									],
									[
										39082,
										39085
									],
									[
										39297,
										39300
									],
									[
										39375,
										39378
									],
									[
										39586,
										39589
									],
									[
										39885,
										39888
									],
									[
										40223,
										40226
									],
									[
										40251,
										40254
									],
									[
										40291,
										40294
									],
									[
										40372,
										40375
									],
									[
										40539,
										40542
									],
									[
										40824,
										40827
									],
									[
										41119,
										41122
									],
									[
										41255,
										41258
									],
									[
										41372,
										41375
									],
									[
										41745,
										41748
									],
									[
										41845,
										41848
									],
									[
										41891,
										41894
									],
									[
										42070,
										42073
									],
									[
										42329,
										42332
									],
									[
										42462,
										42465
									],
									[
										42545,
										42548
									],
									[
										42750,
										42753
									],
									[
										42967,
										42970
									],
									[
										43007,
										43010
									],
									[
										43157,
										43160
									],
									[
										43189,
										43192
									],
									[
										43380,
										43383
									],
									[
										43567,
										43570
									],
									[
										43578,
										43581
									],
									[
										43689,
										43692
									],
									[
										43871,
										43874
									],
									[
										43921,
										43924
									],
									[
										43945,
										43948
									],
									[
										44100,
										44103
									],
									[
										44341,
										44344
									],
									[
										44410,
										44413
									],
									[
										44565,
										44568
									],
									[
										44738,
										44741
									],
									[
										44911,
										44914
									],
									[
										44970,
										44973
									],
									[
										45156,
										45159
									],
									[
										45378,
										45381
									],
									[
										45390,
										45393
									],
									[
										45594,
										45597
									],
									[
										45618,
										45621
									],
									[
										45627,
										45630
									],
									[
										45764,
										45767
									],
									[
										45806,
										45809
									],
									[
										45865,
										45868
									],
									[
										46025,
										46028
									],
									[
										46076,
										46079
									],
									[
										46170,
										46173
									],
									[
										46406,
										46409
									],
									[
										46430,
										46433
									],
									[
										46439,
										46442
									],
									[
										46962,
										46965
									],
									[
										47150,
										47153
									],
									[
										47356,
										47359
									],
									[
										47652,
										47655
									],
									[
										47866,
										47869
									],
									[
										48051,
										48054
									],
									[
										48318,
										48321
									],
									[
										48546,
										48549
									],
									[
										48588,
										48591
									],
									[
										48647,
										48650
									],
									[
										48756,
										48759
									],
									[
										48816,
										48819
									],
									[
										48996,
										48999
									],
									[
										49215,
										49218
									],
									[
										49240,
										49243
									],
									[
										49249,
										49252
									],
									[
										49466,
										49469
									],
									[
										49613,
										49616
									],
									[
										49747,
										49750
									],
									[
										49888,
										49891
									],
									[
										50083,
										50086
									],
									[
										50134,
										50137
									],
									[
										50255,
										50258
									],
									[
										50391,
										50394
									],
									[
										50638,
										50641
									],
									[
										50688,
										50691
									],
									[
										50910,
										50913
									],
									[
										51151,
										51154
									],
									[
										51387,
										51390
									],
									[
										51435,
										51438
									],
									[
										51494,
										51497
									],
									[
										51565,
										51568
									],
									[
										51818,
										51821
									],
									[
										52030,
										52033
									],
									[
										52295,
										52298
									],
									[
										52411,
										52414
									],
									[
										52467,
										52470
									],
									[
										52624,
										52627
									],
									[
										52824,
										52827
									],
									[
										53055,
										53058
									],
									[
										53371,
										53374
									],
									[
										53602,
										53605
									],
									[
										53951,
										53954
									],
									[
										54594,
										54597
									],
									[
										54643,
										54646
									],
									[
										55027,
										55030
									],
									[
										55188,
										55191
									],
									[
										55257,
										55260
									],
									[
										55424,
										55427
									],
									[
										55501,
										55504
									],
									[
										55677,
										55680
									],
									[
										55891,
										55894
									],
									[
										56057,
										56060
									],
									[
										56161,
										56164
									],
									[
										56406,
										56409
									],
									[
										56592,
										56595
									],
									[
										56730,
										56733
									],
									[
										56959,
										56962
									],
									[
										57212,
										57215
									],
									[
										57311,
										57314
									],
									[
										57444,
										57447
									],
									[
										57621,
										57624
									],
									[
										57847,
										57850
									],
									[
										57909,
										57912
									],
									[
										57964,
										57967
									],
									[
										58192,
										58195
									],
									[
										58502,
										58505
									],
									[
										58801,
										58804
									],
									[
										59169,
										59172
									],
									[
										59523,
										59526
									],
									[
										59678,
										59681
									],
									[
										59974,
										59977
									],
									[
										60384,
										60387
									],
									[
										60584,
										60587
									],
									[
										60603,
										60606
									],
									[
										60734,
										60737
									],
									[
										60918,
										60921
									],
									[
										60937,
										60940
									],
									[
										61138,
										61141
									],
									[
										61511,
										61514
									],
									[
										61535,
										61538
									],
									[
										61574,
										61577
									],
									[
										61755,
										61758
									],
									[
										61948,
										61951
									],
									[
										62163,
										62166
									],
									[
										62319,
										62322
									],
									[
										62507,
										62510
									],
									[
										62766,
										62769
									],
									[
										63010,
										63013
									],
									[
										63058,
										63061
									],
									[
										63248,
										63251
									],
									[
										63428,
										63431
									],
									[
										63739,
										63742
									],
									[
										63769,
										63772
									],
									[
										63910,
										63913
									],
									[
										64012,
										64015
									],
									[
										64057,
										64060
									],
									[
										64294,
										64296
									],
									[
										64538,
										64540
									],
									[
										64785,
										64787
									],
									[
										64801,
										64803
									],
									[
										64978,
										64980
									],
									[
										65029,
										65031
									],
									[
										65239,
										65241
									],
									[
										65255,
										65257
									],
									[
										65492,
										65494
									],
									[
										65508,
										65510
									],
									[
										65656,
										65658
									],
									[
										65668,
										65670
									],
									[
										65802,
										65804
									],
									[
										65814,
										65816
									],
									[
										65919,
										65921
									],
									[
										65931,
										65933
									],
									[
										66180,
										66182
									],
									[
										66426,
										66428
									],
									[
										66640,
										66642
									],
									[
										66824,
										66826
									],
									[
										66987,
										66989
									],
									[
										67131,
										67133
									],
									[
										67333,
										67335
									],
									[
										67539,
										67541
									],
									[
										67759,
										67761
									],
									[
										67967,
										67969
									],
									[
										68180,
										68182
									],
									[
										68604,
										68606
									],
									[
										69230,
										69232
									],
									[
										69698,
										69702
									],
									[
										69917,
										69921
									],
									[
										70230,
										70234
									],
									[
										70415,
										70419
									],
									[
										70626,
										70630
									],
									[
										70876,
										70880
									],
									[
										70962,
										70966
									],
									[
										71153,
										71157
									],
									[
										71239,
										71243
									],
									[
										71372,
										71376
									],
									[
										71487,
										71491
									],
									[
										71573,
										71577
									],
									[
										71609,
										71613
									],
									[
										71786,
										71790
									],
									[
										71982,
										71986
									],
									[
										72151,
										72155
									],
									[
										72402,
										72406
									],
									[
										72590,
										72594
									],
									[
										72817,
										72821
									],
									[
										73079,
										73083
									],
									[
										73283,
										73287
									],
									[
										73425,
										73429
									],
									[
										73693,
										73697
									],
									[
										73900,
										73904
									],
									[
										73969,
										73973
									],
									[
										74172,
										74176
									],
									[
										74425,
										74429
									],
									[
										74622,
										74626
									],
									[
										74817,
										74821
									],
									[
										75019,
										75023
									],
									[
										75255,
										75259
									],
									[
										75528,
										75532
									],
									[
										75584,
										75588
									],
									[
										75813,
										75817
									],
									[
										75955,
										75959
									],
									[
										76201,
										76205
									],
									[
										76431,
										76435
									],
									[
										76654,
										76658
									],
									[
										76819,
										76823
									],
									[
										76872,
										76876
									],
									[
										77053,
										77057
									],
									[
										77294,
										77298
									],
									[
										77389,
										77393
									],
									[
										77814,
										77818
									],
									[
										78050,
										78054
									],
									[
										78207,
										78211
									],
									[
										78550,
										78554
									],
									[
										78833,
										78837
									],
									[
										79068,
										79072
									],
									[
										79374,
										79378
									],
									[
										79637,
										79641
									],
									[
										79856,
										79860
									],
									[
										80169,
										80173
									],
									[
										80354,
										80358
									],
									[
										80565,
										80569
									],
									[
										80815,
										80819
									],
									[
										80901,
										80905
									],
									[
										81092,
										81096
									],
									[
										81178,
										81182
									],
									[
										81311,
										81315
									],
									[
										81426,
										81430
									],
									[
										81512,
										81516
									],
									[
										81548,
										81552
									],
									[
										81725,
										81729
									],
									[
										81921,
										81925
									],
									[
										82090,
										82094
									],
									[
										82341,
										82345
									],
									[
										82529,
										82533
									],
									[
										82756,
										82760
									],
									[
										83018,
										83022
									],
									[
										83222,
										83226
									],
									[
										83364,
										83368
									],
									[
										83632,
										83636
									],
									[
										83839,
										83843
									],
									[
										83908,
										83912
									],
									[
										84111,
										84115
									],
									[
										84364,
										84368
									],
									[
										84561,
										84565
									],
									[
										84756,
										84760
									],
									[
										84958,
										84962
									],
									[
										85194,
										85198
									],
									[
										85467,
										85471
									],
									[
										85523,
										85527
									],
									[
										85752,
										85756
									],
									[
										85894,
										85898
									],
									[
										86140,
										86144
									],
									[
										86370,
										86374
									],
									[
										86593,
										86597
									],
									[
										86758,
										86762
									],
									[
										86811,
										86815
									],
									[
										86992,
										86996
									],
									[
										87233,
										87237
									],
									[
										87328,
										87332
									],
									[
										87753,
										87757
									],
									[
										87989,
										87993
									],
									[
										88146,
										88150
									],
									[
										88489,
										88493
									],
									[
										88772,
										88776
									],
									[
										89007,
										89011
									],
									[
										89389,
										89393
									],
									[
										89537,
										89541
									],
									[
										89687,
										89691
									],
									[
										89855,
										89859
									],
									[
										90039,
										90043
									],
									[
										90302,
										90306
									],
									[
										90521,
										90525
									],
									[
										90834,
										90838
									],
									[
										91019,
										91023
									],
									[
										91230,
										91234
									],
									[
										91480,
										91484
									],
									[
										91566,
										91570
									],
									[
										91757,
										91761
									],
									[
										91843,
										91847
									],
									[
										91976,
										91980
									],
									[
										92091,
										92095
									],
									[
										92177,
										92181
									],
									[
										92213,
										92217
									],
									[
										92390,
										92394
									],
									[
										92586,
										92590
									],
									[
										92755,
										92759
									],
									[
										93006,
										93010
									],
									[
										93194,
										93198
									],
									[
										93421,
										93425
									],
									[
										93683,
										93687
									],
									[
										93887,
										93891
									],
									[
										94029,
										94033
									],
									[
										94297,
										94301
									],
									[
										94504,
										94508
									],
									[
										94573,
										94577
									],
									[
										94776,
										94780
									],
									[
										95029,
										95033
									],
									[
										95226,
										95230
									],
									[
										95421,
										95425
									],
									[
										95623,
										95627
									],
									[
										95859,
										95863
									],
									[
										96132,
										96136
									],
									[
										96188,
										96192
									],
									[
										96417,
										96421
									],
									[
										96559,
										96563
									],
									[
										96805,
										96809
									],
									[
										97035,
										97039
									],
									[
										97258,
										97262
									],
									[
										97423,
										97427
									],
									[
										97476,
										97480
									],
									[
										97657,
										97661
									],
									[
										97898,
										97902
									],
									[
										97993,
										97997
									],
									[
										98418,
										98422
									],
									[
										98654,
										98658
									],
									[
										98811,
										98815
									],
									[
										99154,
										99158
									],
									[
										99437,
										99441
									],
									[
										99672,
										99676
									],
									[
										99979,
										99983
									],
									[
										100242,
										100246
									],
									[
										100461,
										100465
									],
									[
										100774,
										100778
									],
									[
										100959,
										100963
									],
									[
										101170,
										101174
									],
									[
										101420,
										101424
									],
									[
										101506,
										101510
									],
									[
										101697,
										101701
									],
									[
										101783,
										101787
									],
									[
										101916,
										101920
									],
									[
										102031,
										102035
									],
									[
										102117,
										102121
									],
									[
										102153,
										102157
									],
									[
										102330,
										102334
									],
									[
										102526,
										102530
									],
									[
										102695,
										102699
									],
									[
										102946,
										102950
									],
									[
										103134,
										103138
									],
									[
										103361,
										103365
									],
									[
										103623,
										103627
									],
									[
										103827,
										103831
									],
									[
										103969,
										103973
									],
									[
										104237,
										104241
									],
									[
										104444,
										104448
									],
									[
										104513,
										104517
									],
									[
										104716,
										104720
									],
									[
										104969,
										104973
									],
									[
										105166,
										105170
									],
									[
										105361,
										105365
									],
									[
										105563,
										105567
									],
									[
										105799,
										105803
									],
									[
										106072,
										106076
									],
									[
										106128,
										106132
									],
									[
										106357,
										106361
									],
									[
										106499,
										106503
									],
									[
										106745,
										106749
									],
									[
										106975,
										106979
									],
									[
										107198,
										107202
									],
									[
										107363,
										107367
									],
									[
										107416,
										107420
									],
									[
										107597,
										107601
									],
									[
										107838,
										107842
									],
									[
										107933,
										107937
									],
									[
										108358,
										108362
									],
									[
										108594,
										108598
									],
									[
										108751,
										108755
									],
									[
										109094,
										109098
									],
									[
										109377,
										109381
									],
									[
										109612,
										109616
									],
									[
										109919,
										109923
									],
									[
										110167,
										110175
									],
									[
										110215,
										110223
									],
									[
										110245,
										110253
									],
									[
										110276,
										110284
									],
									[
										110447,
										110455
									],
									[
										110566,
										110574
									],
									[
										110799,
										110807
									],
									[
										110847,
										110855
									],
									[
										110877,
										110885
									],
									[
										110908,
										110916
									],
									[
										111054,
										111062
									],
									[
										111263,
										111271
									],
									[
										111311,
										111319
									],
									[
										111341,
										111349
									],
									[
										111372,
										111380
									],
									[
										111507,
										111515
									],
									[
										111688,
										111696
									],
									[
										111915,
										111923
									],
									[
										111963,
										111971
									],
									[
										111993,
										112001
									],
									[
										112024,
										112032
									],
									[
										112169,
										112177
									],
									[
										112344,
										112352
									],
									[
										112566,
										112574
									],
									[
										112614,
										112622
									],
									[
										112644,
										112652
									],
									[
										112675,
										112683
									],
									[
										112963,
										112971
									],
									[
										113099,
										113107
									],
									[
										113305,
										113313
									],
									[
										113353,
										113361
									],
									[
										113383,
										113391
									],
									[
										113414,
										113422
									],
									[
										113578,
										113586
									],
									[
										113617,
										113625
									],
									[
										113646,
										113654
									],
									[
										113789,
										113797
									],
									[
										114006,
										114014
									],
									[
										114054,
										114062
									],
									[
										114084,
										114092
									],
									[
										114115,
										114123
									],
									[
										114278,
										114286
									],
									[
										114325,
										114333
									],
									[
										114354,
										114362
									],
									[
										114561,
										114569
									],
									[
										114609,
										114617
									],
									[
										114639,
										114647
									],
									[
										114670,
										114678
									],
									[
										114825,
										114833
									],
									[
										115091,
										115099
									],
									[
										115251,
										115259
									],
									[
										115505,
										115513
									],
									[
										115553,
										115561
									],
									[
										115583,
										115591
									],
									[
										115614,
										115622
									],
									[
										115741,
										115749
									],
									[
										115888,
										115896
									],
									[
										116064,
										116072
									],
									[
										116162,
										116170
									],
									[
										116492,
										116500
									],
									[
										116540,
										116548
									],
									[
										116570,
										116578
									],
									[
										116601,
										116609
									],
									[
										116796,
										116804
									],
									[
										116940,
										116948
									],
									[
										117116,
										117124
									],
									[
										117247,
										117255
									],
									[
										117560,
										117568
									],
									[
										117608,
										117616
									],
									[
										117638,
										117646
									],
									[
										117669,
										117677
									],
									[
										117923,
										117931
									],
									[
										118008,
										118016
									],
									[
										118187,
										118195
									],
									[
										118331,
										118339
									],
									[
										118594,
										118602
									],
									[
										118642,
										118650
									],
									[
										118672,
										118680
									],
									[
										118703,
										118711
									],
									[
										118830,
										118838
									],
									[
										118914,
										118922
									],
									[
										119089,
										119097
									],
									[
										119204,
										119212
									],
									[
										119437,
										119445
									],
									[
										119453,
										119461
									],
									[
										119566,
										119574
									],
									[
										119707,
										119715
									],
									[
										119871,
										119879
									],
									[
										119888,
										119896
									],
									[
										119933,
										119941
									],
									[
										120047,
										120055
									],
									[
										120080,
										120088
									],
									[
										120338,
										120346
									],
									[
										120386,
										120394
									],
									[
										120416,
										120424
									],
									[
										120447,
										120455
									],
									[
										120587,
										120595
									],
									[
										120801,
										120809
									],
									[
										120849,
										120857
									],
									[
										120879,
										120887
									],
									[
										120910,
										120918
									],
									[
										121056,
										121064
									],
									[
										121241,
										121249
									],
									[
										121289,
										121297
									],
									[
										121319,
										121327
									],
									[
										121350,
										121358
									],
									[
										121488,
										121496
									],
									[
										121672,
										121680
									],
									[
										121890,
										121898
									],
									[
										121938,
										121946
									],
									[
										121968,
										121976
									],
									[
										121999,
										122007
									],
									[
										122142,
										122150
									],
									[
										122352,
										122360
									],
									[
										122400,
										122408
									],
									[
										122430,
										122438
									],
									[
										122461,
										122469
									],
									[
										122596,
										122604
									],
									[
										122612,
										122620
									],
									[
										122633,
										122641
									],
									[
										122655,
										122663
									],
									[
										122775,
										122783
									],
									[
										122865,
										122873
									],
									[
										123134,
										123142
									],
									[
										123182,
										123190
									],
									[
										123212,
										123220
									],
									[
										123243,
										123251
									],
									[
										123386,
										123394
									],
									[
										123399,
										123407
									],
									[
										123591,
										123599
									],
									[
										123639,
										123647
									],
									[
										123669,
										123677
									],
									[
										123700,
										123708
									],
									[
										123833,
										123841
									],
									[
										123968,
										123976
									],
									[
										124196,
										124204
									],
									[
										124244,
										124252
									],
									[
										124274,
										124282
									],
									[
										124305,
										124313
									],
									[
										124453,
										124461
									],
									[
										124474,
										124482
									],
									[
										124610,
										124618
									],
									[
										124812,
										124820
									],
									[
										124860,
										124868
									],
									[
										124890,
										124898
									],
									[
										124921,
										124929
									],
									[
										125056,
										125064
									],
									[
										125129,
										125137
									],
									[
										125313,
										125321
									],
									[
										125334,
										125342
									],
									[
										125492,
										125500
									],
									[
										125549,
										125557
									],
									[
										125761,
										125769
									],
									[
										125809,
										125817
									],
									[
										125839,
										125847
									],
									[
										125870,
										125878
									],
									[
										126018,
										126026
									],
									[
										126034,
										126042
									],
									[
										126161,
										126169
									],
									[
										126194,
										126202
									],
									[
										126312,
										126320
									],
									[
										126361,
										126369
									],
									[
										126388,
										126396
									],
									[
										126416,
										126424
									],
									[
										126657,
										126661
									],
									[
										126680,
										126684
									],
									[
										126728,
										126732
									],
									[
										126758,
										126762
									],
									[
										126875,
										126879
									],
									[
										126892,
										126896
									],
									[
										126946,
										126950
									],
									[
										126964,
										126968
									],
									[
										126989,
										126993
									],
									[
										127105,
										127109
									],
									[
										127129,
										127133
									],
									[
										127143,
										127147
									],
									[
										127232,
										127236
									],
									[
										127498,
										127502
									],
									[
										127609,
										127613
									],
									[
										127739,
										127743
									],
									[
										127811,
										127815
									],
									[
										127886,
										127890
									],
									[
										127944,
										127948
									],
									[
										128188,
										128192
									],
									[
										128299,
										128303
									],
									[
										128429,
										128433
									],
									[
										128501,
										128505
									],
									[
										128576,
										128580
									],
									[
										128634,
										128638
									],
									[
										128830,
										128834
									],
									[
										128853,
										128857
									],
									[
										128901,
										128905
									],
									[
										128931,
										128935
									],
									[
										129070,
										129074
									],
									[
										129226,
										129230
									],
									[
										129236,
										129240
									],
									[
										129285,
										129289
									],
									[
										129475,
										129479
									],
									[
										129621,
										129625
									],
									[
										129672,
										129676
									],
									[
										129728,
										129732
									],
									[
										129773,
										129777
									],
									[
										129909,
										129913
									],
									[
										129929,
										129933
									],
									[
										129940,
										129944
									],
									[
										129987,
										129991
									],
									[
										130031,
										130035
									],
									[
										130067,
										130071
									],
									[
										130199,
										130203
									],
									[
										130230,
										130234
									],
									[
										130455,
										130459
									],
									[
										130478,
										130482
									],
									[
										130526,
										130530
									],
									[
										130556,
										130560
									],
									[
										130670,
										130674
									],
									[
										130693,
										130697
									],
									[
										130698,
										130702
									],
									[
										130731,
										130735
									],
									[
										130769,
										130773
									],
									[
										131035,
										131039
									],
									[
										131092,
										131096
									],
									[
										131115,
										131119
									],
									[
										131163,
										131167
									],
									[
										131193,
										131197
									],
									[
										131307,
										131311
									],
									[
										131337,
										131341
									],
									[
										131354,
										131358
									],
									[
										131429,
										131433
									],
									[
										131931,
										131935
									],
									[
										131974,
										131978
									],
									[
										132403,
										132407
									],
									[
										132426,
										132430
									],
									[
										132474,
										132478
									],
									[
										132504,
										132508
									],
									[
										132618,
										132622
									],
									[
										132640,
										132644
									],
									[
										132681,
										132685
									],
									[
										132898,
										132902
									],
									[
										132921,
										132925
									],
									[
										132969,
										132973
									],
									[
										132999,
										133003
									],
									[
										133127,
										133131
									],
									[
										133160,
										133164
									],
									[
										133361,
										133365
									],
									[
										133631,
										133635
									],
									[
										133704,
										133708
									],
									[
										133821,
										133825
									],
									[
										134030,
										134034
									],
									[
										134053,
										134057
									],
									[
										134101,
										134105
									],
									[
										134131,
										134135
									],
									[
										134283,
										134287
									],
									[
										134355,
										134359
									],
									[
										134371,
										134375
									],
									[
										134384,
										134388
									],
									[
										134397,
										134401
									],
									[
										134472,
										134476
									],
									[
										134607,
										134611
									],
									[
										134786,
										134790
									],
									[
										134853,
										134857
									],
									[
										135080,
										135084
									],
									[
										135096,
										135100
									],
									[
										135268,
										135272
									],
									[
										135379,
										135383
									],
									[
										135457,
										135461
									],
									[
										135521,
										135525
									],
									[
										135600,
										135604
									],
									[
										135791,
										135795
									],
									[
										135814,
										135818
									],
									[
										135862,
										135866
									],
									[
										135892,
										135896
									],
									[
										136006,
										136010
									],
									[
										136024,
										136028
									],
									[
										136030,
										136034
									],
									[
										136044,
										136048
									],
									[
										136075,
										136079
									],
									[
										136113,
										136117
									],
									[
										136261,
										136265
									],
									[
										136453,
										136457
									],
									[
										136473,
										136477
									],
									[
										136531,
										136535
									],
									[
										136750,
										136754
									],
									[
										136984,
										136988
									],
									[
										137007,
										137011
									],
									[
										137055,
										137059
									],
									[
										137085,
										137089
									],
									[
										137199,
										137203
									],
									[
										137226,
										137230
									],
									[
										137259,
										137263
									],
									[
										137479,
										137483
									],
									[
										137502,
										137506
									],
									[
										137550,
										137554
									],
									[
										137580,
										137584
									],
									[
										137694,
										137698
									],
									[
										137721,
										137725
									],
									[
										137754,
										137758
									],
									[
										137953,
										137957
									],
									[
										137980,
										137984
									],
									[
										138044,
										138048
									],
									[
										138265,
										138269
									],
									[
										138288,
										138292
									],
									[
										138336,
										138340
									],
									[
										138366,
										138370
									],
									[
										138495,
										138499
									],
									[
										138549,
										138553
									],
									[
										138666,
										138670
									],
									[
										138671,
										138675
									],
									[
										138704,
										138708
									],
									[
										138912,
										138916
									],
									[
										138957,
										138961
									],
									[
										138962,
										138966
									],
									[
										139016,
										139020
									],
									[
										139059,
										139063
									],
									[
										139154,
										139158
									],
									[
										139179,
										139183
									],
									[
										139226,
										139230
									],
									[
										139263,
										139267
									],
									[
										139394,
										139398
									],
									[
										139557,
										139561
									],
									[
										139580,
										139584
									],
									[
										139628,
										139632
									],
									[
										139658,
										139662
									],
									[
										139778,
										139782
									],
									[
										139800,
										139804
									],
									[
										139856,
										139860
									],
									[
										139910,
										139914
									],
									[
										140096,
										140100
									],
									[
										140119,
										140123
									],
									[
										140167,
										140171
									],
									[
										140197,
										140201
									],
									[
										140301,
										140305
									],
									[
										140317,
										140321
									],
									[
										140334,
										140338
									],
									[
										140377,
										140381
									],
									[
										140429,
										140433
									],
									[
										140529,
										140533
									],
									[
										140549,
										140553
									],
									[
										140603,
										140607
									],
									[
										140735,
										140739
									],
									[
										140969,
										140973
									],
									[
										140983,
										140987
									],
									[
										140988,
										140992
									],
									[
										141057,
										141061
									],
									[
										141182,
										141186
									],
									[
										141397,
										141401
									],
									[
										141420,
										141424
									],
									[
										141468,
										141472
									],
									[
										141498,
										141502
									],
									[
										141612,
										141616
									],
									[
										141632,
										141636
									],
									[
										141665,
										141669
									],
									[
										141858,
										141862
									],
									[
										141881,
										141885
									],
									[
										141929,
										141933
									],
									[
										141959,
										141963
									],
									[
										142073,
										142077
									],
									[
										142093,
										142097
									],
									[
										142134,
										142138
									],
									[
										142194,
										142198
									],
									[
										142472,
										142474
									],
									[
										142720,
										142722
									],
									[
										142889,
										142891
									],
									[
										143044,
										143046
									],
									[
										143335,
										143337
									],
									[
										143592,
										143594
									],
									[
										143794,
										143796
									],
									[
										144005,
										144007
									],
									[
										144021,
										144023
									],
									[
										144198,
										144200
									],
									[
										144249,
										144251
									],
									[
										144459,
										144461
									],
									[
										144475,
										144477
									],
									[
										144712,
										144714
									],
									[
										144728,
										144730
									],
									[
										144876,
										144878
									],
									[
										144888,
										144890
									],
									[
										145022,
										145024
									],
									[
										145034,
										145036
									],
									[
										145139,
										145141
									],
									[
										145151,
										145153
									],
									[
										145400,
										145402
									],
									[
										145646,
										145648
									],
									[
										145860,
										145862
									],
									[
										146044,
										146046
									],
									[
										146207,
										146209
									],
									[
										146351,
										146353
									],
									[
										146553,
										146555
									],
									[
										146759,
										146761
									],
									[
										146979,
										146981
									],
									[
										147187,
										147189
									],
									[
										147400,
										147402
									],
									[
										147824,
										147826
									],
									[
										148450,
										148452
									],
									[
										148933,
										148934
									],
									[
										149057,
										149058
									],
									[
										149066,
										149067
									],
									[
										149260,
										149261
									],
									[
										149410,
										149411
									],
									[
										149420,
										149421
									],
									[
										149659,
										149660
									],
									[
										149704,
										149705
									],
									[
										149713,
										149714
									],
									[
										149838,
										149839
									],
									[
										149897,
										149898
									],
									[
										149956,
										149957
									],
									[
										150209,
										150210
									],
									[
										150219,
										150220
									],
									[
										150277,
										150278
									],
									[
										150287,
										150288
									],
									[
										150492,
										150493
									],
									[
										150502,
										150503
									],
									[
										150733,
										150734
									],
									[
										150742,
										150743
									],
									[
										150751,
										150752
									],
									[
										150760,
										150761
									],
									[
										150897,
										150898
									],
									[
										150960,
										150961
									],
									[
										151023,
										151024
									],
									[
										151106,
										151107
									],
									[
										151399,
										151400
									],
									[
										151409,
										151410
									],
									[
										151471,
										151472
									],
									[
										151481,
										151482
									],
									[
										151706,
										151707
									],
									[
										151716,
										151717
									],
									[
										151865,
										151866
									],
									[
										151875,
										151876
									],
									[
										152093,
										152094
									],
									[
										152149,
										152150
									],
									[
										152454,
										152455
									],
									[
										152632,
										152633
									],
									[
										152845,
										152846
									],
									[
										152925,
										152926
									],
									[
										152933,
										152934
									],
									[
										152974,
										152975
									],
									[
										153050,
										153051
									],
									[
										153284,
										153285
									],
									[
										153296,
										153297
									],
									[
										153364,
										153365
									],
									[
										153376,
										153377
									],
									[
										153596,
										153597
									],
									[
										153654,
										153655
									],
									[
										153688,
										153689
									],
									[
										153756,
										153757
									],
									[
										153974,
										153975
									],
									[
										154043,
										154044
									],
									[
										154200,
										154201
									],
									[
										154228,
										154229
									],
									[
										154329,
										154330
									],
									[
										154445,
										154446
									],
									[
										154548,
										154549
									],
									[
										154778,
										154779
									],
									[
										155085,
										155086
									],
									[
										155267,
										155268
									],
									[
										155598,
										155599
									],
									[
										155688,
										155689
									],
									[
										155703,
										155704
									],
									[
										155754,
										155755
									],
									[
										155897,
										155898
									],
									[
										156026,
										156027
									],
									[
										156039,
										156040
									],
									[
										156111,
										156112
									],
									[
										156177,
										156178
									],
									[
										156190,
										156191
									],
									[
										156262,
										156263
									],
									[
										156321,
										156322
									],
									[
										156335,
										156336
									],
									[
										156470,
										156471
									],
									[
										156483,
										156484
									],
									[
										156499,
										156500
									],
									[
										156513,
										156514
									],
									[
										156688,
										156689
									],
									[
										156855,
										156856
									],
									[
										157107,
										157108
									],
									[
										157343,
										157344
									],
									[
										157544,
										157545
									],
									[
										157585,
										157586
									],
									[
										157858,
										157859
									],
									[
										158066,
										158067
									],
									[
										158265,
										158266
									],
									[
										158503,
										158504
									],
									[
										158551,
										158552
									],
									[
										158767,
										158768
									],
									[
										158982,
										158983
									],
									[
										158999,
										159000
									],
									[
										159237,
										159238
									],
									[
										159285,
										159286
									],
									[
										159411,
										159412
									],
									[
										159649,
										159650
									],
									[
										159832,
										159833
									],
									[
										160107,
										160108
									],
									[
										160315,
										160316
									],
									[
										160544,
										160545
									],
									[
										160558,
										160559
									],
									[
										160756,
										160757
									],
									[
										161004,
										161005
									],
									[
										161232,
										161233
									],
									[
										161260,
										161261
									],
									[
										161410,
										161411
									],
									[
										161574,
										161575
									],
									[
										161705,
										161706
									],
									[
										161769,
										161770
									],
									[
										161777,
										161778
									],
									[
										161973,
										161974
									],
									[
										162024,
										162025
									],
									[
										162201,
										162202
									],
									[
										162272,
										162273
									],
									[
										162280,
										162281
									],
									[
										162522,
										162523
									],
									[
										162578,
										162579
									],
									[
										162634,
										162635
									],
									[
										162690,
										162691
									],
									[
										162756,
										162757
									],
									[
										162829,
										162830
									],
									[
										163064,
										163065
									],
									[
										163076,
										163077
									],
									[
										163118,
										163119
									],
									[
										163160,
										163161
									],
									[
										163171,
										163172
									],
									[
										163247,
										163248
									],
									[
										163258,
										163259
									],
									[
										163378,
										163379
									],
									[
										163391,
										163392
									],
									[
										163468,
										163469
									],
									[
										163482,
										163483
									],
									[
										163588,
										163589
									],
									[
										163825,
										163826
									],
									[
										163837,
										163838
									],
									[
										164059,
										164060
									],
									[
										164079,
										164080
									],
									[
										164133,
										164134
									],
									[
										164145,
										164146
									],
									[
										164187,
										164188
									],
									[
										164221,
										164222
									],
									[
										164233,
										164234
									],
									[
										164360,
										164361
									],
									[
										164623,
										164624
									],
									[
										164631,
										164632
									],
									[
										164642,
										164643
									],
									[
										164665,
										164666
									],
									[
										164703,
										164704
									],
									[
										164823,
										164824
									],
									[
										164959,
										164960
									],
									[
										164976,
										164977
									],
									[
										165004,
										165005
									],
									[
										165006,
										165007
									],
									[
										165017,
										165018
									],
									[
										165048,
										165049
									],
									[
										165061,
										165062
									],
									[
										165075,
										165076
									],
									[
										165077,
										165078
									],
									[
										165088,
										165089
									],
									[
										165143,
										165144
									],
									[
										165149,
										165150
									],
									[
										165151,
										165152
									],
									[
										165284,
										165285
									],
									[
										165512,
										165513
									],
									[
										165521,
										165522
									],
									[
										165531,
										165532
									],
									[
										165649,
										165650
									],
									[
										165690,
										165691
									],
									[
										165912,
										165913
									],
									[
										166015,
										166016
									],
									[
										166136,
										166137
									],
									[
										166288,
										166289
									],
									[
										166517,
										166518
									],
									[
										166745,
										166746
									],
									[
										166758,
										166759
									],
									[
										166938,
										166939
									],
									[
										167128,
										167129
									],
									[
										167172,
										167173
									],
									[
										167188,
										167189
									],
									[
										167209,
										167210
									],
									[
										167256,
										167257
									],
									[
										167984,
										167985
									],
									[
										168077,
										168078
									],
									[
										168170,
										168171
									],
									[
										168263,
										168264
									],
									[
										168553,
										168554
									],
									[
										168800,
										168801
									],
									[
										169016,
										169017
									],
									[
										169255,
										169256
									],
									[
										169396,
										169397
									],
									[
										169461,
										169462
									],
									[
										169542,
										169543
									],
									[
										169549,
										169550
									],
									[
										169824,
										169825
									],
									[
										169884,
										169885
									],
									[
										170035,
										170036
									],
									[
										170053,
										170054
									],
									[
										170056,
										170057
									],
									[
										170067,
										170068
									],
									[
										170070,
										170071
									],
									[
										170172,
										170173
									],
									[
										170175,
										170176
									],
									[
										170405,
										170406
									],
									[
										170409,
										170410
									],
									[
										170543,
										170544
									],
									[
										170686,
										170687
									],
									[
										170750,
										170751
									],
									[
										170889,
										170890
									],
									[
										170962,
										170963
									],
									[
										171026,
										171027
									],
									[
										171262,
										171263
									],
									[
										171268,
										171269
									],
									[
										171439,
										171440
									],
									[
										171442,
										171443
									],
									[
										171616,
										171617
									],
									[
										171624,
										171625
									],
									[
										171680,
										171681
									],
									[
										171683,
										171684
									],
									[
										171889,
										171890
									],
									[
										171894,
										171895
									],
									[
										171913,
										171914
									],
									[
										171921,
										171922
									],
									[
										171989,
										171990
									],
									[
										171992,
										171993
									],
									[
										172241,
										172242
									],
									[
										172385,
										172386
									],
									[
										172387,
										172388
									],
									[
										172535,
										172536
									],
									[
										172537,
										172538
									],
									[
										172663,
										172664
									],
									[
										172665,
										172666
									],
									[
										172893,
										172894
									],
									[
										173116,
										173117
									],
									[
										173323,
										173324
									],
									[
										173516,
										173517
									],
									[
										173752,
										173753
									],
									[
										173928,
										173929
									],
									[
										174058,
										174059
									],
									[
										174073,
										174074
									],
									[
										174088,
										174089
									],
									[
										174103,
										174104
									],
									[
										174247,
										174248
									],
									[
										174262,
										174263
									],
									[
										174301,
										174302
									],
									[
										174427,
										174428
									],
									[
										174441,
										174442
									],
									[
										174464,
										174465
									],
									[
										174478,
										174479
									],
									[
										174518,
										174519
									],
									[
										174718,
										174719
									],
									[
										174949,
										174950
									],
									[
										175115,
										175116
									],
									[
										175155,
										175156
									],
									[
										175187,
										175188
									],
									[
										175222,
										175223
									],
									[
										175332,
										175333
									],
									[
										175374,
										175375
									],
									[
										175433,
										175434
									],
									[
										175485,
										175486
									],
									[
										175715,
										175716
									],
									[
										175891,
										175892
									],
									[
										176074,
										176075
									],
									[
										176090,
										176091
									],
									[
										176250,
										176251
									],
									[
										176331,
										176332
									],
									[
										176416,
										176417
									],
									[
										176422,
										176423
									],
									[
										176468,
										176469
									],
									[
										176481,
										176482
									],
									[
										176535,
										176536
									],
									[
										176540,
										176541
									],
									[
										176548,
										176549
									],
									[
										176586,
										176587
									],
									[
										176591,
										176592
									],
									[
										176599,
										176600
									],
									[
										176796,
										176797
									],
									[
										176812,
										176813
									],
									[
										177114,
										177115
									],
									[
										177361,
										177362
									],
									[
										177588,
										177589
									],
									[
										177604,
										177605
									],
									[
										177776,
										177777
									],
									[
										177887,
										177888
									],
									[
										177965,
										177966
									],
									[
										178029,
										178030
									],
									[
										178108,
										178109
									],
									[
										178306,
										178307
									],
									[
										178322,
										178323
									],
									[
										178493,
										178494
									],
									[
										178501,
										178502
									],
									[
										178551,
										178552
									],
									[
										178562,
										178563
									],
									[
										178685,
										178686
									],
									[
										178696,
										178697
									],
									[
										178826,
										178827
									],
									[
										178837,
										178838
									],
									[
										178950,
										178951
									],
									[
										178962,
										178963
									],
									[
										179096,
										179097
									],
									[
										179108,
										179109
									],
									[
										179213,
										179214
									],
									[
										179225,
										179226
									],
									[
										179410,
										179411
									],
									[
										179427,
										179428
									],
									[
										179464,
										179465
									],
									[
										179483,
										179484
									],
									[
										179608,
										179609
									],
									[
										179627,
										179628
									],
									[
										179764,
										179765
									],
									[
										179783,
										179784
									],
									[
										179915,
										179916
									],
									[
										179934,
										179935
									],
									[
										180079,
										180080
									],
									[
										180093,
										180094
									],
									[
										180262,
										180263
									],
									[
										180348,
										180349
									],
									[
										180351,
										180352
									],
									[
										180362,
										180363
									],
									[
										180365,
										180366
									],
									[
										180446,
										180447
									],
									[
										180449,
										180450
									],
									[
										180460,
										180461
									],
									[
										180465,
										180466
									],
									[
										180616,
										180617
									],
									[
										180619,
										180620
									],
									[
										180639,
										180640
									],
									[
										180642,
										180643
									],
									[
										180653,
										180654
									],
									[
										180658,
										180659
									],
									[
										180719,
										180720
									],
									[
										180724,
										180725
									],
									[
										180905,
										180906
									],
									[
										180944,
										180945
									],
									[
										181114,
										181115
									],
									[
										181116,
										181117
									],
									[
										181307,
										181308
									],
									[
										181309,
										181310
									],
									[
										181327,
										181328
									],
									[
										181329,
										181330
									],
									[
										181417,
										181418
									],
									[
										181419,
										181420
									],
									[
										181665,
										181666
									],
									[
										181667,
										181668
									],
									[
										181684,
										181685
									],
									[
										181686,
										181687
									],
									[
										181759,
										181760
									],
									[
										181761,
										181762
									],
									[
										181956,
										181957
									],
									[
										181958,
										181959
									],
									[
										182208,
										182209
									],
									[
										182269,
										182270
									],
									[
										182279,
										182280
									],
									[
										182287,
										182288
									],
									[
										182317,
										182318
									],
									[
										182327,
										182328
									],
									[
										182335,
										182336
									],
									[
										182345,
										182346
									],
									[
										182353,
										182354
									],
									[
										182383,
										182384
									],
									[
										182393,
										182394
									],
									[
										182401,
										182402
									],
									[
										182411,
										182412
									],
									[
										182419,
										182420
									],
									[
										182429,
										182430
									],
									[
										182437,
										182438
									],
									[
										182672,
										182673
									],
									[
										182686,
										182687
									],
									[
										182824,
										182825
									],
									[
										182884,
										182885
									],
									[
										182941,
										182942
									],
									[
										183054,
										183055
									],
									[
										183303,
										183304
									],
									[
										183332,
										183333
									],
									[
										183539,
										183540
									],
									[
										183745,
										183746
									],
									[
										183774,
										183775
									],
									[
										183938,
										183939
									],
									[
										184045,
										184046
									],
									[
										184049,
										184050
									],
									[
										184052,
										184053
									],
									[
										184288,
										184289
									],
									[
										184297,
										184298
									],
									[
										184479,
										184480
									],
									[
										184488,
										184489
									],
									[
										184685,
										184686
									],
									[
										184724,
										184725
									],
									[
										184745,
										184746
									],
									[
										184781,
										184782
									],
									[
										184966,
										184967
									],
									[
										184993,
										184994
									],
									[
										185002,
										185003
									],
									[
										185029,
										185030
									],
									[
										185241,
										185242
									],
									[
										185248,
										185249
									],
									[
										185345,
										185346
									],
									[
										185511,
										185512
									],
									[
										185514,
										185515
									],
									[
										185689,
										185690
									],
									[
										185697,
										185698
									],
									[
										185720,
										185721
									],
									[
										185725,
										185726
									],
									[
										185786,
										185787
									],
									[
										185789,
										185790
									],
									[
										185835,
										185836
									],
									[
										185852,
										185853
									],
									[
										185864,
										185865
									],
									[
										185981,
										185982
									],
									[
										186154,
										186155
									],
									[
										186166,
										186167
									],
									[
										186403,
										186404
									],
									[
										186412,
										186413
									],
									[
										186421,
										186422
									],
									[
										186671,
										186672
									],
									[
										186685,
										186686
									],
									[
										186692,
										186693
									],
									[
										186706,
										186707
									],
									[
										186936,
										186937
									],
									[
										186961,
										186962
									],
									[
										187071,
										187072
									],
									[
										187075,
										187076
									],
									[
										187112,
										187113
									],
									[
										187161,
										187162
									],
									[
										187293,
										187294
									],
									[
										187497,
										187498
									],
									[
										187562,
										187563
									],
									[
										187611,
										187612
									],
									[
										187743,
										187744
									],
									[
										187955,
										187956
									],
									[
										188166,
										188167
									],
									[
										188291,
										188292
									],
									[
										188437,
										188438
									],
									[
										188577,
										188578
									],
									[
										188587,
										188588
									],
									[
										188635,
										188636
									],
									[
										188648,
										188649
									],
									[
										188845,
										188846
									],
									[
										188853,
										188854
									],
									[
										188934,
										188935
									],
									[
										188942,
										188943
									],
									[
										188950,
										188951
									],
									[
										189031,
										189032
									],
									[
										189207,
										189208
									],
									[
										189392,
										189393
									],
									[
										189400,
										189401
									],
									[
										189478,
										189479
									],
									[
										189487,
										189488
									],
									[
										189701,
										189702
									],
									[
										189844,
										189845
									],
									[
										189852,
										189853
									],
									[
										189904,
										189905
									],
									[
										189915,
										189916
									],
									[
										190089,
										190090
									],
									[
										190100,
										190101
									],
									[
										190323,
										190324
									],
									[
										190458,
										190459
									],
									[
										190466,
										190467
									],
									[
										190518,
										190519
									],
									[
										190529,
										190530
									],
									[
										190718,
										190719
									],
									[
										190885,
										190886
									],
									[
										190922,
										190923
									],
									[
										190933,
										190934
									],
									[
										191140,
										191141
									],
									[
										191165,
										191166
									],
									[
										191172,
										191173
									],
									[
										191197,
										191198
									],
									[
										191336,
										191337
									],
									[
										191477,
										191478
									],
									[
										191643,
										191644
									],
									[
										191662,
										191663
									],
									[
										191693,
										191694
									],
									[
										191888,
										191889
									],
									[
										191891,
										191892
									],
									[
										192035,
										192036
									],
									[
										192040,
										192041
									],
									[
										192125,
										192126
									],
									[
										192130,
										192131
									],
									[
										192295,
										192296
									],
									[
										192450,
										192451
									],
									[
										192455,
										192456
									],
									[
										192542,
										192543
									],
									[
										192547,
										192548
									],
									[
										192743,
										192744
									],
									[
										192928,
										192929
									],
									[
										193001,
										193002
									],
									[
										193168,
										193169
									],
									[
										193344,
										193345
									],
									[
										193476,
										193477
									],
									[
										193630,
										193631
									],
									[
										193793,
										193794
									],
									[
										193895,
										193896
									],
									[
										194033,
										194034
									],
									[
										194178,
										194179
									],
									[
										194385,
										194386
									],
									[
										194564,
										194565
									],
									[
										194641,
										194642
									],
									[
										194719,
										194720
									],
									[
										194943,
										194944
									],
									[
										194953,
										194954
									],
									[
										195065,
										195066
									],
									[
										195135,
										195136
									],
									[
										195144,
										195145
									],
									[
										195273,
										195274
									],
									[
										195302,
										195303
									],
									[
										195508,
										195509
									],
									[
										195536,
										195537
									],
									[
										195739,
										195740
									],
									[
										195918,
										195919
									],
									[
										195994,
										195995
									],
									[
										196072,
										196073
									],
									[
										196178,
										196179
									],
									[
										196243,
										196244
									],
									[
										196253,
										196254
									],
									[
										196382,
										196383
									],
									[
										196411,
										196412
									],
									[
										196617,
										196618
									],
									[
										196645,
										196646
									],
									[
										196862,
										196863
									],
									[
										197027,
										197028
									],
									[
										197108,
										197109
									],
									[
										197363,
										197364
									],
									[
										197532,
										197533
									],
									[
										197535,
										197536
									],
									[
										197670,
										197671
									],
									[
										197673,
										197674
									],
									[
										197843,
										197844
									],
									[
										197846,
										197847
									],
									[
										197914,
										197915
									],
									[
										197917,
										197918
									],
									[
										197959,
										197960
									],
									[
										197962,
										197963
									],
									[
										198126,
										198127
									],
									[
										198129,
										198130
									],
									[
										198147,
										198148
									],
									[
										198150,
										198151
									],
									[
										198193,
										198194
									],
									[
										198196,
										198197
									],
									[
										198335,
										198336
									],
									[
										198338,
										198339
									],
									[
										198473,
										198474
									],
									[
										198476,
										198477
									],
									[
										198646,
										198647
									],
									[
										198837,
										198838
									],
									[
										199043,
										199044
									],
									[
										199154,
										199155
									],
									[
										199551,
										199552
									],
									[
										200184,
										200185
									],
									[
										200444,
										200445
									],
									[
										200451,
										200452
									],
									[
										200732,
										200733
									],
									[
										200951,
										200952
									],
									[
										201206,
										201207
									],
									[
										201213,
										201214
									],
									[
										201378,
										201379
									],
									[
										201397,
										201398
									],
									[
										201834,
										201835
									],
									[
										201949,
										201950
									],
									[
										201959,
										201960
									],
									[
										202041,
										202042
									],
									[
										202242,
										202243
									],
									[
										202326,
										202327
									],
									[
										202502,
										202503
									],
									[
										202644,
										202645
									],
									[
										202654,
										202655
									],
									[
										202774,
										202775
									],
									[
										203001,
										203002
									],
									[
										203212,
										203213
									],
									[
										203220,
										203221
									],
									[
										203432,
										203433
									],
									[
										203652,
										203653
									],
									[
										203893,
										203894
									],
									[
										204056,
										204057
									],
									[
										204058,
										204059
									],
									[
										204176,
										204177
									],
									[
										204457,
										204458
									],
									[
										204511,
										204512
									],
									[
										204529,
										204530
									],
									[
										204846,
										204847
									],
									[
										204859,
										204860
									],
									[
										204920,
										204921
									],
									[
										204933,
										204934
									],
									[
										205244,
										205245
									],
									[
										205257,
										205258
									],
									[
										205318,
										205319
									],
									[
										205331,
										205332
									],
									[
										205626,
										205627
									],
									[
										205637,
										205638
									],
									[
										205700,
										205701
									],
									[
										205711,
										205712
									],
									[
										206026,
										206027
									],
									[
										206037,
										206038
									],
									[
										206100,
										206101
									],
									[
										206111,
										206112
									],
									[
										206302,
										206303
									],
									[
										206466,
										206467
									],
									[
										206469,
										206470
									],
									[
										206530,
										206531
									],
									[
										206533,
										206534
									],
									[
										206712,
										206713
									],
									[
										206719,
										206720
									],
									[
										206780,
										206781
									],
									[
										206787,
										206788
									],
									[
										206972,
										206973
									],
									[
										206975,
										206976
									],
									[
										207036,
										207037
									],
									[
										207039,
										207040
									],
									[
										207220,
										207221
									],
									[
										207223,
										207224
									],
									[
										207288,
										207289
									],
									[
										207291,
										207292
									],
									[
										207490,
										207491
									],
									[
										207493,
										207494
									],
									[
										207537,
										207538
									],
									[
										207540,
										207541
									],
									[
										207588,
										207589
									],
									[
										207591,
										207592
									],
									[
										207635,
										207636
									],
									[
										207638,
										207639
									],
									[
										207773,
										207774
									],
									[
										207888,
										207889
									],
									[
										207911,
										207912
									],
									[
										207984,
										207985
									],
									[
										208008,
										208009
									],
									[
										208051,
										208052
									],
									[
										208072,
										208073
									],
									[
										208088,
										208089
									],
									[
										208096,
										208097
									],
									[
										208435,
										208436
									],
									[
										208635,
										208636
									],
									[
										208730,
										208731
									],
									[
										209208,
										209209
									],
									[
										209390,
										209391
									],
									[
										209485,
										209486
									],
									[
										209573,
										209574
									],
									[
										209875,
										209876
									],
									[
										210055,
										210056
									],
									[
										210150,
										210151
									],
									[
										210239,
										210240
									],
									[
										210435,
										210436
									],
									[
										210448,
										210449
									],
									[
										210496,
										210497
									],
									[
										210534,
										210535
									],
									[
										210544,
										210545
									],
									[
										210552,
										210553
									],
									[
										210951,
										210952
									],
									[
										211020,
										211021
									],
									[
										211023,
										211024
									],
									[
										211042,
										211043
									],
									[
										211047,
										211048
									],
									[
										211060,
										211061
									],
									[
										211065,
										211066
									],
									[
										211147,
										211148
									],
									[
										211150,
										211151
									],
									[
										211353,
										211354
									],
									[
										211521,
										211522
									],
									[
										211539,
										211540
									],
									[
										211647,
										211648
									],
									[
										211667,
										211668
									],
									[
										211752,
										211753
									],
									[
										211815,
										211816
									],
									[
										211972,
										211973
									],
									[
										212035,
										212036
									],
									[
										212223,
										212224
									],
									[
										212231,
										212232
									],
									[
										212400,
										212401
									],
									[
										212483,
										212484
									],
									[
										212607,
										212608
									],
									[
										212871,
										212872
									],
									[
										212922,
										212923
									],
									[
										213219,
										213220
									],
									[
										213344,
										213345
									],
									[
										213363,
										213364
									],
									[
										213366,
										213367
									],
									[
										213538,
										213539
									],
									[
										213617,
										213618
									],
									[
										213620,
										213621
									],
									[
										213662,
										213663
									],
									[
										213798,
										213799
									],
									[
										213810,
										213811
									],
									[
										213890,
										213891
									],
									[
										214053,
										214054
									],
									[
										214196,
										214197
									],
									[
										214208,
										214209
									],
									[
										214242,
										214243
									],
									[
										214389,
										214390
									],
									[
										214403,
										214404
									],
									[
										214464,
										214465
									],
									[
										214612,
										214613
									],
									[
										214758,
										214759
									],
									[
										214829,
										214830
									],
									[
										214846,
										214847
									],
									[
										214903,
										214904
									],
									[
										214916,
										214917
									],
									[
										215045,
										215046
									],
									[
										215194,
										215195
									],
									[
										215470,
										215471
									],
									[
										215550,
										215551
									],
									[
										215679,
										215680
									],
									[
										215696,
										215697
									],
									[
										215907,
										215908
									],
									[
										215922,
										215923
									],
									[
										215930,
										215931
									],
									[
										215937,
										215938
									],
									[
										215982,
										215983
									],
									[
										216018,
										216019
									],
									[
										216101,
										216102
									],
									[
										216147,
										216148
									],
									[
										216184,
										216185
									],
									[
										216438,
										216439
									],
									[
										216441,
										216442
									],
									[
										216462,
										216463
									],
									[
										216465,
										216466
									],
									[
										216471,
										216472
									],
									[
										216474,
										216475
									],
									[
										216534,
										216535
									],
									[
										216537,
										216538
									],
									[
										216558,
										216559
									],
									[
										216561,
										216562
									],
									[
										216567,
										216568
									],
									[
										216570,
										216571
									],
									[
										216726,
										216727
									],
									[
										216731,
										216732
									],
									[
										216754,
										216755
									],
									[
										216757,
										216758
									],
									[
										216763,
										216764
									],
									[
										216768,
										216769
									],
									[
										216902,
										216903
									],
									[
										217206,
										217207
									],
									[
										217475,
										217476
									],
									[
										217483,
										217484
									],
									[
										217605,
										217606
									],
									[
										217825,
										217826
									],
									[
										218006,
										218007
									],
									[
										218174,
										218175
									],
									[
										218183,
										218184
									],
									[
										218268,
										218269
									],
									[
										218326,
										218327
									],
									[
										218493,
										218494
									],
									[
										218675,
										218676
									],
									[
										218847,
										218848
									],
									[
										218968,
										218969
									],
									[
										219057,
										219058
									],
									[
										219243,
										219244
									],
									[
										219522,
										219523
									],
									[
										219730,
										219731
									],
									[
										219735,
										219736
									],
									[
										219743,
										219744
									],
									[
										219754,
										219755
									],
									[
										219759,
										219760
									],
									[
										219800,
										219801
									],
									[
										219805,
										219806
									],
									[
										219975,
										219976
									],
									[
										219980,
										219981
									],
									[
										220061,
										220062
									],
									[
										220066,
										220067
									],
									[
										220074,
										220075
									],
									[
										220085,
										220086
									],
									[
										220090,
										220091
									],
									[
										220131,
										220132
									],
									[
										220136,
										220137
									],
									[
										220306,
										220307
									],
									[
										220311,
										220312
									],
									[
										220379,
										220380
									],
									[
										220382,
										220383
									],
									[
										220392,
										220393
									],
									[
										220403,
										220404
									],
									[
										220406,
										220407
									],
									[
										220449,
										220450
									],
									[
										220452,
										220453
									],
									[
										220624,
										220625
									],
									[
										220627,
										220628
									],
									[
										220692,
										220693
									],
									[
										220713,
										220714
									],
									[
										220716,
										220717
									],
									[
										220726,
										220727
									],
									[
										220737,
										220738
									],
									[
										220740,
										220741
									],
									[
										220783,
										220784
									],
									[
										220786,
										220787
									],
									[
										220958,
										220959
									],
									[
										220961,
										220962
									],
									[
										221127,
										221128
									],
									[
										221175,
										221176
									],
									[
										221185,
										221186
									],
									[
										221188,
										221189
									],
									[
										221378,
										221379
									],
									[
										221433,
										221434
									],
									[
										221436,
										221437
									],
									[
										221743,
										221744
									],
									[
										221898,
										221899
									],
									[
										222082,
										222083
									],
									[
										222237,
										222238
									],
									[
										222240,
										222241
									],
									[
										222301,
										222302
									],
									[
										222304,
										222305
									],
									[
										222475,
										222476
									],
									[
										222482,
										222483
									],
									[
										222543,
										222544
									],
									[
										222550,
										222551
									],
									[
										222727,
										222728
									],
									[
										222730,
										222731
									],
									[
										222791,
										222792
									],
									[
										222794,
										222795
									],
									[
										222967,
										222968
									],
									[
										222970,
										222971
									],
									[
										223035,
										223036
									],
									[
										223038,
										223039
									],
									[
										223229,
										223230
									],
									[
										223232,
										223233
									],
									[
										223276,
										223277
									],
									[
										223279,
										223280
									],
									[
										223326,
										223327
									],
									[
										223329,
										223330
									],
									[
										223373,
										223374
									],
									[
										223376,
										223377
									],
									[
										223553,
										223554
									],
									[
										223558,
										223559
									],
									[
										223611,
										223612
									],
									[
										223616,
										223617
									],
									[
										223729,
										223730
									],
									[
										223734,
										223735
									],
									[
										223790,
										223791
									],
									[
										223795,
										223796
									],
									[
										223904,
										223905
									],
									[
										223907,
										223908
									],
									[
										223962,
										223963
									],
									[
										223965,
										223966
									],
									[
										224080,
										224081
									],
									[
										224083,
										224084
									],
									[
										224138,
										224139
									],
									[
										224141,
										224142
									],
									[
										224283,
										224284
									],
									[
										224299,
										224300
									],
									[
										224475,
										224481
									],
									[
										224647,
										224653
									],
									[
										224770,
										224776
									],
									[
										224992,
										225000
									],
									[
										225040,
										225048
									],
									[
										225070,
										225078
									],
									[
										225101,
										225109
									],
									[
										225272,
										225280
									],
									[
										225391,
										225399
									],
									[
										225624,
										225632
									],
									[
										225672,
										225680
									],
									[
										225702,
										225710
									],
									[
										225733,
										225741
									],
									[
										225879,
										225887
									],
									[
										226088,
										226096
									],
									[
										226136,
										226144
									],
									[
										226166,
										226174
									],
									[
										226197,
										226205
									],
									[
										226332,
										226340
									],
									[
										226513,
										226521
									],
									[
										226740,
										226748
									],
									[
										226788,
										226796
									],
									[
										226818,
										226826
									],
									[
										226849,
										226857
									],
									[
										226994,
										227002
									],
									[
										227169,
										227177
									],
									[
										227391,
										227399
									],
									[
										227439,
										227447
									],
									[
										227469,
										227477
									],
									[
										227500,
										227508
									],
									[
										227788,
										227796
									],
									[
										227924,
										227932
									],
									[
										228130,
										228138
									],
									[
										228178,
										228186
									],
									[
										228208,
										228216
									],
									[
										228239,
										228247
									],
									[
										228403,
										228411
									],
									[
										228442,
										228450
									],
									[
										228471,
										228479
									],
									[
										228614,
										228622
									],
									[
										228831,
										228839
									],
									[
										228879,
										228887
									],
									[
										228909,
										228917
									],
									[
										228940,
										228948
									],
									[
										229103,
										229111
									],
									[
										229150,
										229158
									],
									[
										229179,
										229187
									],
									[
										229386,
										229394
									],
									[
										229434,
										229442
									],
									[
										229464,
										229472
									],
									[
										229495,
										229503
									],
									[
										229650,
										229658
									],
									[
										229916,
										229924
									],
									[
										230076,
										230084
									],
									[
										230330,
										230338
									],
									[
										230378,
										230386
									],
									[
										230408,
										230416
									],
									[
										230439,
										230447
									],
									[
										230566,
										230574
									],
									[
										230713,
										230721
									],
									[
										230889,
										230897
									],
									[
										230987,
										230995
									],
									[
										231317,
										231325
									],
									[
										231365,
										231373
									],
									[
										231395,
										231403
									],
									[
										231426,
										231434
									],
									[
										231621,
										231629
									],
									[
										231765,
										231773
									],
									[
										231941,
										231949
									],
									[
										232072,
										232080
									],
									[
										232385,
										232393
									],
									[
										232433,
										232441
									],
									[
										232463,
										232471
									],
									[
										232494,
										232502
									],
									[
										232748,
										232756
									],
									[
										232833,
										232841
									],
									[
										233012,
										233020
									],
									[
										233156,
										233164
									],
									[
										233419,
										233427
									],
									[
										233467,
										233475
									],
									[
										233497,
										233505
									],
									[
										233528,
										233536
									],
									[
										233655,
										233663
									],
									[
										233739,
										233747
									],
									[
										233914,
										233922
									],
									[
										234029,
										234037
									],
									[
										234262,
										234270
									],
									[
										234278,
										234286
									],
									[
										234391,
										234399
									],
									[
										234532,
										234540
									],
									[
										234696,
										234704
									],
									[
										234713,
										234721
									],
									[
										234758,
										234766
									],
									[
										234872,
										234880
									],
									[
										234905,
										234913
									],
									[
										235163,
										235171
									],
									[
										235211,
										235219
									],
									[
										235241,
										235249
									],
									[
										235272,
										235280
									],
									[
										235412,
										235420
									],
									[
										235626,
										235634
									],
									[
										235674,
										235682
									],
									[
										235704,
										235712
									],
									[
										235735,
										235743
									],
									[
										235881,
										235889
									],
									[
										236066,
										236074
									],
									[
										236114,
										236122
									],
									[
										236144,
										236152
									],
									[
										236175,
										236183
									],
									[
										236313,
										236321
									],
									[
										236497,
										236505
									],
									[
										236715,
										236723
									],
									[
										236763,
										236771
									],
									[
										236793,
										236801
									],
									[
										236824,
										236832
									],
									[
										236967,
										236975
									],
									[
										237177,
										237185
									],
									[
										237225,
										237233
									],
									[
										237255,
										237263
									],
									[
										237286,
										237294
									],
									[
										237421,
										237429
									],
									[
										237437,
										237445
									],
									[
										237458,
										237466
									],
									[
										237480,
										237488
									],
									[
										237600,
										237608
									],
									[
										237690,
										237698
									],
									[
										237959,
										237967
									],
									[
										238007,
										238015
									],
									[
										238037,
										238045
									],
									[
										238068,
										238076
									],
									[
										238211,
										238219
									],
									[
										238224,
										238232
									],
									[
										238416,
										238424
									],
									[
										238464,
										238472
									],
									[
										238494,
										238502
									],
									[
										238525,
										238533
									],
									[
										238658,
										238666
									],
									[
										238793,
										238801
									],
									[
										239021,
										239029
									],
									[
										239069,
										239077
									],
									[
										239099,
										239107
									],
									[
										239130,
										239138
									],
									[
										239278,
										239286
									],
									[
										239299,
										239307
									],
									[
										239435,
										239443
									],
									[
										239637,
										239645
									],
									[
										239685,
										239693
									],
									[
										239715,
										239723
									],
									[
										239746,
										239754
									],
									[
										239881,
										239889
									],
									[
										239954,
										239962
									],
									[
										240138,
										240146
									],
									[
										240159,
										240167
									],
									[
										240317,
										240325
									],
									[
										240374,
										240382
									],
									[
										240586,
										240594
									],
									[
										240634,
										240642
									],
									[
										240664,
										240672
									],
									[
										240695,
										240703
									],
									[
										240843,
										240851
									],
									[
										240859,
										240867
									],
									[
										240986,
										240994
									],
									[
										241019,
										241027
									],
									[
										241137,
										241145
									],
									[
										241186,
										241194
									],
									[
										241213,
										241221
									],
									[
										241241,
										241249
									],
									[
										241520,
										241528
									],
									[
										241670,
										241678
									],
									[
										241715,
										241723
									],
									[
										241886,
										241894
									],
									[
										242047,
										242055
									],
									[
										242087,
										242095
									],
									[
										242399,
										242407
									],
									[
										242447,
										242455
									],
									[
										242477,
										242485
									],
									[
										242508,
										242516
									],
									[
										242679,
										242687
									],
									[
										242798,
										242806
									],
									[
										243031,
										243039
									],
									[
										243079,
										243087
									],
									[
										243109,
										243117
									],
									[
										243140,
										243148
									],
									[
										243286,
										243294
									],
									[
										243495,
										243503
									],
									[
										243543,
										243551
									],
									[
										243573,
										243581
									],
									[
										243604,
										243612
									],
									[
										243739,
										243747
									],
									[
										243920,
										243928
									],
									[
										244147,
										244155
									],
									[
										244195,
										244203
									],
									[
										244225,
										244233
									],
									[
										244256,
										244264
									],
									[
										244401,
										244409
									],
									[
										244576,
										244584
									],
									[
										244798,
										244806
									],
									[
										244846,
										244854
									],
									[
										244876,
										244884
									],
									[
										244907,
										244915
									],
									[
										245195,
										245203
									],
									[
										245331,
										245339
									],
									[
										245537,
										245545
									],
									[
										245585,
										245593
									],
									[
										245615,
										245623
									],
									[
										245646,
										245654
									],
									[
										245810,
										245818
									],
									[
										245849,
										245857
									],
									[
										245878,
										245886
									],
									[
										246021,
										246029
									],
									[
										246238,
										246246
									],
									[
										246286,
										246294
									],
									[
										246316,
										246324
									],
									[
										246347,
										246355
									],
									[
										246510,
										246518
									],
									[
										246557,
										246565
									],
									[
										246586,
										246594
									],
									[
										246793,
										246801
									],
									[
										246841,
										246849
									],
									[
										246871,
										246879
									],
									[
										246902,
										246910
									],
									[
										247057,
										247065
									],
									[
										247323,
										247331
									],
									[
										247483,
										247491
									],
									[
										247737,
										247745
									],
									[
										247785,
										247793
									],
									[
										247815,
										247823
									],
									[
										247846,
										247854
									],
									[
										247973,
										247981
									],
									[
										248120,
										248128
									],
									[
										248296,
										248304
									],
									[
										248394,
										248402
									],
									[
										248724,
										248732
									],
									[
										248772,
										248780
									],
									[
										248802,
										248810
									],
									[
										248833,
										248841
									],
									[
										249028,
										249036
									],
									[
										249172,
										249180
									],
									[
										249348,
										249356
									],
									[
										249479,
										249487
									],
									[
										249792,
										249800
									],
									[
										249840,
										249848
									],
									[
										249870,
										249878
									],
									[
										249901,
										249909
									],
									[
										250155,
										250163
									],
									[
										250240,
										250248
									],
									[
										250419,
										250427
									],
									[
										250563,
										250571
									],
									[
										250826,
										250834
									],
									[
										250874,
										250882
									],
									[
										250904,
										250912
									],
									[
										250935,
										250943
									],
									[
										251062,
										251070
									],
									[
										251146,
										251154
									],
									[
										251321,
										251329
									],
									[
										251436,
										251444
									],
									[
										251669,
										251677
									],
									[
										251685,
										251693
									],
									[
										251798,
										251806
									],
									[
										251939,
										251947
									],
									[
										252103,
										252111
									],
									[
										252120,
										252128
									],
									[
										252165,
										252173
									],
									[
										252279,
										252287
									],
									[
										252312,
										252320
									],
									[
										252570,
										252578
									],
									[
										252618,
										252626
									],
									[
										252648,
										252656
									],
									[
										252679,
										252687
									],
									[
										252819,
										252827
									],
									[
										253033,
										253041
									],
									[
										253081,
										253089
									],
									[
										253111,
										253119
									],
									[
										253142,
										253150
									],
									[
										253288,
										253296
									],
									[
										253473,
										253481
									],
									[
										253521,
										253529
									],
									[
										253551,
										253559
									],
									[
										253582,
										253590
									],
									[
										253720,
										253728
									],
									[
										253904,
										253912
									],
									[
										254122,
										254130
									],
									[
										254170,
										254178
									],
									[
										254200,
										254208
									],
									[
										254231,
										254239
									],
									[
										254374,
										254382
									],
									[
										254584,
										254592
									],
									[
										254632,
										254640
									],
									[
										254662,
										254670
									],
									[
										254693,
										254701
									],
									[
										254828,
										254836
									],
									[
										254844,
										254852
									],
									[
										254865,
										254873
									],
									[
										254887,
										254895
									],
									[
										255007,
										255015
									],
									[
										255097,
										255105
									],
									[
										255366,
										255374
									],
									[
										255414,
										255422
									],
									[
										255444,
										255452
									],
									[
										255475,
										255483
									],
									[
										255618,
										255626
									],
									[
										255631,
										255639
									],
									[
										255823,
										255831
									],
									[
										255871,
										255879
									],
									[
										255901,
										255909
									],
									[
										255932,
										255940
									],
									[
										256065,
										256073
									],
									[
										256200,
										256208
									],
									[
										256428,
										256436
									],
									[
										256476,
										256484
									],
									[
										256506,
										256514
									],
									[
										256537,
										256545
									],
									[
										256685,
										256693
									],
									[
										256706,
										256714
									],
									[
										256842,
										256850
									],
									[
										257044,
										257052
									],
									[
										257092,
										257100
									],
									[
										257122,
										257130
									],
									[
										257153,
										257161
									],
									[
										257288,
										257296
									],
									[
										257361,
										257369
									],
									[
										257545,
										257553
									],
									[
										257566,
										257574
									],
									[
										257724,
										257732
									],
									[
										257781,
										257789
									],
									[
										257993,
										258001
									],
									[
										258041,
										258049
									],
									[
										258071,
										258079
									],
									[
										258102,
										258110
									],
									[
										258250,
										258258
									],
									[
										258266,
										258274
									],
									[
										258393,
										258401
									],
									[
										258426,
										258434
									],
									[
										258543,
										258551
									],
									[
										258592,
										258600
									],
									[
										258619,
										258627
									],
									[
										258647,
										258655
									],
									[
										258927,
										258931
									],
									[
										259204,
										259208
									],
									[
										259546,
										259550
									],
									[
										259999,
										260003
									],
									[
										260308,
										260312
									],
									[
										260657,
										260661
									],
									[
										260888,
										260892
									],
									[
										261201,
										261205
									],
									[
										261386,
										261390
									],
									[
										261597,
										261601
									],
									[
										261847,
										261851
									],
									[
										261933,
										261937
									],
									[
										262124,
										262128
									],
									[
										262210,
										262214
									],
									[
										262343,
										262347
									],
									[
										262458,
										262462
									],
									[
										262544,
										262548
									],
									[
										262580,
										262584
									],
									[
										262757,
										262761
									],
									[
										262953,
										262957
									],
									[
										263122,
										263126
									],
									[
										263373,
										263377
									],
									[
										263561,
										263565
									],
									[
										263788,
										263792
									],
									[
										264050,
										264054
									],
									[
										264254,
										264258
									],
									[
										264396,
										264400
									],
									[
										264664,
										264668
									],
									[
										264871,
										264875
									],
									[
										264940,
										264944
									],
									[
										265143,
										265147
									],
									[
										265396,
										265400
									],
									[
										265593,
										265597
									],
									[
										265788,
										265792
									],
									[
										265990,
										265994
									],
									[
										266226,
										266230
									],
									[
										266499,
										266503
									],
									[
										266555,
										266559
									],
									[
										266784,
										266788
									],
									[
										266926,
										266930
									],
									[
										267172,
										267176
									],
									[
										267402,
										267406
									],
									[
										267625,
										267629
									],
									[
										267790,
										267794
									],
									[
										267843,
										267847
									],
									[
										268024,
										268028
									],
									[
										268265,
										268269
									],
									[
										268360,
										268364
									],
									[
										268785,
										268789
									],
									[
										269021,
										269025
									],
									[
										269178,
										269182
									],
									[
										269521,
										269525
									],
									[
										269804,
										269808
									],
									[
										270057,
										270061
									],
									[
										270289,
										270293
									],
									[
										270595,
										270599
									],
									[
										270735,
										270739
									],
									[
										271030,
										271033
									],
									[
										271315,
										271318
									],
									[
										271369,
										271372
									],
									[
										271505,
										271508
									],
									[
										271739,
										271742
									],
									[
										271766,
										271769
									],
									[
										271935,
										271938
									],
									[
										272136,
										272139
									],
									[
										272177,
										272180
									],
									[
										272297,
										272300
									],
									[
										272471,
										272474
									],
									[
										272922,
										272925
									],
									[
										273122,
										273125
									],
									[
										273141,
										273144
									],
									[
										273272,
										273275
									],
									[
										273456,
										273459
									],
									[
										273475,
										273478
									],
									[
										273676,
										273679
									],
									[
										274049,
										274052
									],
									[
										274073,
										274076
									],
									[
										274112,
										274115
									],
									[
										274293,
										274296
									],
									[
										274486,
										274489
									],
									[
										274701,
										274704
									],
									[
										274857,
										274860
									],
									[
										275045,
										275048
									],
									[
										275304,
										275307
									],
									[
										275548,
										275551
									],
									[
										275596,
										275599
									],
									[
										275786,
										275789
									],
									[
										275966,
										275969
									],
									[
										276277,
										276280
									],
									[
										276307,
										276310
									],
									[
										276448,
										276451
									],
									[
										276695,
										276698
									],
									[
										276720,
										276723
									],
									[
										276855,
										276858
									],
									[
										277037,
										277040
									],
									[
										277234,
										277237
									],
									[
										277472,
										277475
									],
									[
										277520,
										277523
									],
									[
										277792,
										277800
									],
									[
										278132,
										278140
									],
									[
										278482,
										278494
									],
									[
										278656,
										278668
									],
									[
										278847,
										278859
									],
									[
										279079,
										279091
									],
									[
										279461,
										279470
									],
									[
										279588,
										279597
									],
									[
										279728,
										279737
									],
									[
										279915,
										279924
									],
									[
										280171,
										280175
									],
									[
										280448,
										280452
									],
									[
										280790,
										280794
									],
									[
										281243,
										281247
									],
									[
										281552,
										281556
									],
									[
										281901,
										281905
									],
									[
										282132,
										282136
									],
									[
										282333,
										282337
									],
									[
										282668,
										282672
									],
									[
										282853,
										282857
									],
									[
										283064,
										283068
									],
									[
										283314,
										283318
									],
									[
										283400,
										283404
									],
									[
										283591,
										283595
									],
									[
										283677,
										283681
									],
									[
										283810,
										283814
									],
									[
										283925,
										283929
									],
									[
										284011,
										284015
									],
									[
										284047,
										284051
									],
									[
										284224,
										284228
									],
									[
										284420,
										284424
									],
									[
										284589,
										284593
									],
									[
										284840,
										284844
									],
									[
										285028,
										285032
									],
									[
										285255,
										285259
									],
									[
										285517,
										285521
									],
									[
										285721,
										285725
									],
									[
										285863,
										285867
									],
									[
										286131,
										286135
									],
									[
										286338,
										286342
									],
									[
										286407,
										286411
									],
									[
										286610,
										286614
									],
									[
										286863,
										286867
									],
									[
										287060,
										287064
									],
									[
										287255,
										287259
									],
									[
										287457,
										287461
									],
									[
										287693,
										287697
									],
									[
										287966,
										287970
									],
									[
										288022,
										288026
									],
									[
										288251,
										288255
									],
									[
										288393,
										288397
									],
									[
										288639,
										288643
									],
									[
										288869,
										288873
									],
									[
										289092,
										289096
									],
									[
										289257,
										289261
									],
									[
										289310,
										289314
									],
									[
										289491,
										289495
									],
									[
										289732,
										289736
									],
									[
										289827,
										289831
									],
									[
										290252,
										290256
									],
									[
										290488,
										290492
									],
									[
										290645,
										290649
									],
									[
										290988,
										290992
									],
									[
										291271,
										291275
									],
									[
										291524,
										291528
									],
									[
										291756,
										291760
									],
									[
										292096,
										292100
									],
									[
										292223,
										292227
									],
									[
										292421,
										292425
									],
									[
										292645,
										292649
									],
									[
										292730,
										292734
									],
									[
										293004,
										293007
									],
									[
										293289,
										293292
									],
									[
										293343,
										293346
									],
									[
										293479,
										293482
									],
									[
										293713,
										293716
									],
									[
										293740,
										293743
									],
									[
										293909,
										293912
									],
									[
										294110,
										294113
									],
									[
										294151,
										294154
									],
									[
										294271,
										294274
									],
									[
										294445,
										294448
									],
									[
										294896,
										294899
									],
									[
										295096,
										295099
									],
									[
										295115,
										295118
									],
									[
										295246,
										295249
									],
									[
										295430,
										295433
									],
									[
										295449,
										295452
									],
									[
										295650,
										295653
									],
									[
										296023,
										296026
									],
									[
										296047,
										296050
									],
									[
										296086,
										296089
									],
									[
										296267,
										296270
									],
									[
										296460,
										296463
									],
									[
										296675,
										296678
									],
									[
										296831,
										296834
									],
									[
										297019,
										297022
									],
									[
										297278,
										297281
									],
									[
										297522,
										297525
									],
									[
										297570,
										297573
									],
									[
										297760,
										297763
									],
									[
										297940,
										297943
									],
									[
										298251,
										298254
									],
									[
										298281,
										298284
									],
									[
										298422,
										298425
									],
									[
										298669,
										298672
									],
									[
										298694,
										298697
									],
									[
										298829,
										298832
									],
									[
										299011,
										299014
									],
									[
										299208,
										299211
									],
									[
										299446,
										299449
									],
									[
										299494,
										299497
									],
									[
										299706,
										299710
									],
									[
										299728,
										299732
									],
									[
										299776,
										299780
									],
									[
										299806,
										299810
									],
									[
										299837,
										299841
									],
									[
										300008,
										300012
									],
									[
										300127,
										300131
									],
									[
										300338,
										300342
									],
									[
										300360,
										300364
									],
									[
										300408,
										300412
									],
									[
										300438,
										300442
									],
									[
										300469,
										300473
									],
									[
										300615,
										300619
									],
									[
										300802,
										300806
									],
									[
										300824,
										300828
									],
									[
										300872,
										300876
									],
									[
										300902,
										300906
									],
									[
										300933,
										300937
									],
									[
										301068,
										301072
									],
									[
										301249,
										301253
									],
									[
										301454,
										301458
									],
									[
										301476,
										301480
									],
									[
										301524,
										301528
									],
									[
										301554,
										301558
									],
									[
										301585,
										301589
									],
									[
										301730,
										301734
									],
									[
										301905,
										301909
									],
									[
										302142,
										302146
									],
									[
										302195,
										302199
									],
									[
										302217,
										302221
									],
									[
										302265,
										302269
									],
									[
										302295,
										302299
									],
									[
										302326,
										302330
									],
									[
										302614,
										302618
									],
									[
										302766,
										302770
									],
									[
										303032,
										303036
									],
									[
										303216,
										303220
									],
									[
										303238,
										303242
									],
									[
										303286,
										303290
									],
									[
										303316,
										303320
									],
									[
										303347,
										303351
									],
									[
										303511,
										303515
									],
									[
										303550,
										303554
									],
									[
										303579,
										303583
									],
									[
										303722,
										303726
									],
									[
										303917,
										303921
									],
									[
										303939,
										303943
									],
									[
										303987,
										303991
									],
									[
										304017,
										304021
									],
									[
										304048,
										304052
									],
									[
										304211,
										304215
									],
									[
										304258,
										304262
									],
									[
										304287,
										304291
									],
									[
										304488,
										304492
									],
									[
										304561,
										304565
									],
									[
										304583,
										304587
									],
									[
										304631,
										304635
									],
									[
										304661,
										304665
									],
									[
										304692,
										304696
									],
									[
										304847,
										304851
									],
									[
										305113,
										305117
									],
									[
										305273,
										305277
									],
									[
										305505,
										305509
									],
									[
										305527,
										305531
									],
									[
										305575,
										305579
									],
									[
										305605,
										305609
									],
									[
										305636,
										305640
									],
									[
										305763,
										305767
									],
									[
										305910,
										305914
									],
									[
										306092,
										306096
									],
									[
										306221,
										306225
									],
									[
										306261,
										306265
									],
									[
										306436,
										306440
									],
									[
										306534,
										306538
									],
									[
										306549,
										306553
									],
									[
										306842,
										306846
									],
									[
										306864,
										306868
									],
									[
										306912,
										306916
									],
									[
										306942,
										306946
									],
									[
										306973,
										306977
									],
									[
										307157,
										307161
									],
									[
										307186,
										307190
									],
									[
										307330,
										307334
									],
									[
										307506,
										307510
									],
									[
										307637,
										307641
									],
									[
										307652,
										307656
									],
									[
										307928,
										307932
									],
									[
										307950,
										307954
									],
									[
										307998,
										308002
									],
									[
										308028,
										308032
									],
									[
										308059,
										308063
									],
									[
										308313,
										308317
									],
									[
										308398,
										308402
									],
									[
										308577,
										308581
									],
									[
										308721,
										308725
									],
									[
										308973,
										308977
									],
									[
										308995,
										308999
									],
									[
										309043,
										309047
									],
									[
										309073,
										309077
									],
									[
										309104,
										309108
									],
									[
										309231,
										309235
									],
									[
										309315,
										309319
									],
									[
										309482,
										309486
									],
									[
										309624,
										309628
									],
									[
										309739,
										309743
									],
									[
										310003,
										310007
									],
									[
										310128,
										310132
									],
									[
										310144,
										310148
									],
									[
										310257,
										310261
									],
									[
										310398,
										310402
									],
									[
										310562,
										310566
									],
									[
										310579,
										310583
									],
									[
										310624,
										310628
									],
									[
										310738,
										310742
									],
									[
										310771,
										310775
									],
									[
										311167,
										311171
									],
									[
										311189,
										311193
									],
									[
										311237,
										311241
									],
									[
										311267,
										311271
									],
									[
										311298,
										311302
									],
									[
										311438,
										311442
									],
									[
										311630,
										311634
									],
									[
										311652,
										311656
									],
									[
										311700,
										311704
									],
									[
										311730,
										311734
									],
									[
										311761,
										311765
									],
									[
										311907,
										311911
									],
									[
										312062,
										312066
									],
									[
										312127,
										312131
									],
									[
										312305,
										312309
									],
									[
										312327,
										312331
									],
									[
										312375,
										312379
									],
									[
										312405,
										312409
									],
									[
										312436,
										312440
									],
									[
										312574,
										312578
									],
									[
										312758,
										312762
									],
									[
										312954,
										312958
									],
									[
										312976,
										312980
									],
									[
										313024,
										313028
									],
									[
										313054,
										313058
									],
									[
										313085,
										313089
									],
									[
										313228,
										313232
									],
									[
										313465,
										313469
									],
									[
										313506,
										313510
									],
									[
										313552,
										313556
									],
									[
										313598,
										313602
									],
									[
										313744,
										313748
									],
									[
										313797,
										313801
									],
									[
										314018,
										314022
									],
									[
										314059,
										314063
									],
									[
										314105,
										314109
									],
									[
										314151,
										314155
									],
									[
										314307,
										314311
									],
									[
										314483,
										314487
									],
									[
										314505,
										314509
									],
									[
										314553,
										314557
									],
									[
										314583,
										314587
									],
									[
										314614,
										314618
									],
									[
										314749,
										314753
									],
									[
										314765,
										314769
									],
									[
										314786,
										314790
									],
									[
										314808,
										314812
									],
									[
										314923,
										314927
									],
									[
										314928,
										314932
									],
									[
										315018,
										315022
									],
									[
										315265,
										315269
									],
									[
										315287,
										315291
									],
									[
										315335,
										315339
									],
									[
										315365,
										315369
									],
									[
										315396,
										315400
									],
									[
										315534,
										315538
									],
									[
										315539,
										315543
									],
									[
										315552,
										315556
									],
									[
										315684,
										315688
									],
									[
										315736,
										315740
									],
									[
										315955,
										315959
									],
									[
										315977,
										315981
									],
									[
										316025,
										316029
									],
									[
										316055,
										316059
									],
									[
										316086,
										316090
									],
									[
										316219,
										316223
									],
									[
										316354,
										316358
									],
									[
										316560,
										316564
									],
									[
										316582,
										316586
									],
									[
										316630,
										316634
									],
									[
										316660,
										316664
									],
									[
										316691,
										316695
									],
									[
										316834,
										316838
									],
									[
										316839,
										316843
									],
									[
										316860,
										316864
									],
									[
										317041,
										317045
									],
									[
										317115,
										317119
									],
									[
										317252,
										317256
									],
									[
										317374,
										317378
									],
									[
										317543,
										317547
									],
									[
										317565,
										317569
									],
									[
										317613,
										317617
									],
									[
										317643,
										317647
									],
									[
										317674,
										317678
									],
									[
										317809,
										317813
									],
									[
										317882,
										317886
									],
									[
										318066,
										318070
									],
									[
										318087,
										318091
									],
									[
										318245,
										318249
									],
									[
										318265,
										318269
									],
									[
										318302,
										318306
									],
									[
										318505,
										318509
									],
									[
										318654,
										318658
									],
									[
										318720,
										318724
									],
									[
										318762,
										318766
									],
									[
										318833,
										318837
									],
									[
										319023,
										319027
									],
									[
										319045,
										319049
									],
									[
										319093,
										319097
									],
									[
										319123,
										319127
									],
									[
										319154,
										319158
									],
									[
										319302,
										319306
									],
									[
										319318,
										319322
									],
									[
										319445,
										319449
									],
									[
										319478,
										319482
									],
									[
										319648,
										319652
									],
									[
										319675,
										319679
									],
									[
										319752,
										319756
									],
									[
										319801,
										319805
									],
									[
										319828,
										319832
									],
									[
										319856,
										319860
									],
									[
										320181,
										320199
									],
									[
										320493,
										320499
									],
									[
										320636,
										320642
									],
									[
										320704,
										320710
									],
									[
										320847,
										320853
									],
									[
										321186,
										321195
									],
									[
										321313,
										321322
									],
									[
										321453,
										321462
									],
									[
										321640,
										321649
									],
									[
										321932,
										321941
									],
									[
										322059,
										322068
									],
									[
										322199,
										322208
									],
									[
										322386,
										322395
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								321939,
								321939
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"function_name_status_row": 9668,
							"line_numbers": false,
							"output_tag": 38,
							"remote_loading": false,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"synced": false,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 6650.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 28,
					"file": "Compare Version Numbers.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1798,
						"regions":
						{
						},
						"selection":
						[
							[
								603,
								603
							]
						],
						"settings":
						{
							"function_name_status_row": 24,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 40,
					"type": "text"
				},
				{
					"buffer": 29,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 402,
						"regions":
						{
						},
						"selection":
						[
							[
								402,
								402
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 21,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 47,
					"type": "text"
				},
				{
					"buffer": 30,
					"file": "Binary Search Tree Iterator.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1324,
						"regions":
						{
						},
						"selection":
						[
							[
								1324,
								1324
							]
						],
						"settings":
						{
							"auto_name": "//Inorder iterative solution",
							"function_name_status_row": 59,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 46,
					"type": "text"
				},
				{
					"buffer": 31,
					"file": "Factorial Trailing Zeroes.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 423,
						"regions":
						{
						},
						"selection":
						[
							[
								232,
								232
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 8,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 32,
					"file": "Fraction to Recurring Decimal.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1074,
						"regions":
						{
						},
						"selection":
						[
							[
								541,
								541
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 17,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 33,
					"file": "Palindrome Number.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 691,
						"regions":
						{
						},
						"selection":
						[
							[
								556,
								556
							]
						],
						"settings":
						{
							"function_name_status_row": 22,
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 34,
					"file": "Palindrome Partitioning.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 939,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 35,
					"file": "Validate Binary Search Tree.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 870,
						"regions":
						{
						},
						"selection":
						[
							[
								281,
								281
							]
						],
						"settings":
						{
							"function_name_status_row": 13,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 84.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 36,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 223,
						"regions":
						{
						},
						"selection":
						[
							[
								222,
								222
							]
						],
						"settings":
						{
							"auto_name": "n = find(root->left, k, found);",
							"function_name_status_row": 18,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 54,
					"type": "text"
				},
				{
					"buffer": 37,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 142,
						"regions":
						{
						},
						"selection":
						[
							[
								141,
								141
							]
						],
						"settings":
						{
							"auto_name": "",
							"function_name_status_row": 6,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 53,
					"type": "text"
				},
				{
					"buffer": 38,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 151,
						"regions":
						{
						},
						"selection":
						[
							[
								150,
								150
							]
						],
						"settings":
						{
							"auto_name": "",
							"function_name_status_row": 4,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 78,
					"type": "text"
				},
				{
					"buffer": 39,
					"file": "Balanced Binary Tree.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 805,
						"regions":
						{
						},
						"selection":
						[
							[
								304,
								304
							]
						],
						"settings":
						{
							"function_name_status_row": 14,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 84,
					"type": "text"
				},
				{
					"buffer": 40,
					"file": "Infix to Postfix.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 92,
						"regions":
						{
						},
						"selection":
						[
							[
								92,
								92
							]
						],
						"settings":
						{
							"auto_name": "http://www.c4learn.com/data-structure/algorithm-fo",
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 86,
					"type": "text"
				},
				{
					"buffer": 41,
					"file": "Add Two Numbers.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1300,
						"regions":
						{
						},
						"selection":
						[
							[
								4,
								4
							]
						],
						"settings":
						{
							"function_name_status_row": 1,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 89,
					"type": "text"
				},
				{
					"buffer": 42,
					"file": "Generate N-digit number.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 585,
						"regions":
						{
						},
						"selection":
						[
							[
								582,
								582
							]
						],
						"settings":
						{
							"auto_name": "void printNum(vector<char> &num)",
							"function_name_status_row": 29,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 88,
					"type": "text"
				},
				{
					"buffer": 43,
					"file": "Maximum Subarray.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 408,
						"regions":
						{
						},
						"selection":
						[
							[
								408,
								408
							]
						],
						"settings":
						{
							"function_name_status_row": 14,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 44,
					"file": "Big Integer.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1791,
						"regions":
						{
						},
						"selection":
						[
							[
								883,
								892
							]
						],
						"settings":
						{
							"auto_name": "vector<int> covertToBigInt(string str)",
							"function_name_status_row": 34,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 24,
					"type": "text"
				},
				{
					"buffer": 45,
					"file": "LRU Cache.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1727,
						"regions":
						{
						},
						"selection":
						[
							[
								467,
								467
							]
						],
						"settings":
						{
							"function_name_status_row": 20,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 46,
					"file": "Search a 2D Matrix.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 976,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 107,
					"type": "text"
				},
				{
					"buffer": 47,
					"file": "Trapping Rain Water.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3431,
						"regions":
						{
						},
						"selection":
						[
							[
								1707,
								1707
							]
						],
						"settings":
						{
							"function_name_status_row": 19,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				},
				{
					"buffer": 48,
					"file": "Flatten Binary Tree to Linked List.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1537,
						"regions":
						{
						},
						"selection":
						[
							[
								625,
								625
							]
						],
						"settings":
						{
							"function_name_status_row": 26,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 49,
					"file": "Unique Paths II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 740,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								17
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 50,
					"file": "Unique Paths.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 376,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 51,
					"file": "Single Number.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 186,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 48,
					"type": "text"
				},
				{
					"buffer": 52,
					"file": "Single Number II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 946,
						"regions":
						{
						},
						"selection":
						[
							[
								872,
								872
							]
						],
						"settings":
						{
							"function_name_status_row": 18,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 53,
					"file": "Longest Consecutive Sequence.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1016,
						"regions":
						{
						},
						"selection":
						[
							[
								11,
								87
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 54,
					"file": "Next Permutation.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1410,
						"regions":
						{
						},
						"selection":
						[
							[
								34,
								49
							]
						],
						"settings":
						{
							"function_name_status_row": 2,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 41,
					"type": "text"
				},
				{
					"buffer": 55,
					"file": "Permutations II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1065,
						"regions":
						{
						},
						"selection":
						[
							[
								563,
								563
							]
						],
						"settings":
						{
							"function_name_status_row": 18,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 56,
					"file": "Two Sum.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2262,
						"regions":
						{
						},
						"selection":
						[
							[
								1669,
								1669
							]
						],
						"settings":
						{
							"function_name_status_row": 60,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 286.0,
						"zoom_level": 1.0
					},
					"stack_index": 50,
					"type": "text"
				},
				{
					"buffer": 57,
					"file": "Combination Sum II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1392,
						"regions":
						{
						},
						"selection":
						[
							[
								442,
								442
							]
						],
						"settings":
						{
							"function_name_status_row": 17,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 113,
					"type": "text"
				},
				{
					"buffer": 58,
					"file": "Longest Substring Without Repeating Characters.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 687,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 95,
					"type": "text"
				},
				{
					"buffer": 59,
					"file": "Construct Binary Tree from Inorder and Postorder Traversal.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1622,
						"regions":
						{
						},
						"selection":
						[
							[
								575,
								575
							]
						],
						"settings":
						{
							"auto_name": "/**",
							"function_name_status_row": 19,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 90,
					"type": "text"
				},
				{
					"buffer": 60,
					"file": "Clone Graph.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2459,
						"regions":
						{
						},
						"selection":
						[
							[
								1276,
								1276
							]
						],
						"settings":
						{
							"auto_name": "//refer http://fisherlei.blogspot.com/2013/12/leet",
							"function_name_status_row": 38,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 94,
					"type": "text"
				},
				{
					"buffer": 61,
					"file": "Find Minimum in Rotated Sorted Array II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 655,
						"regions":
						{
						},
						"selection":
						[
							[
								313,
								313
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 13,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 52,
					"type": "text"
				},
				{
					"buffer": 62,
					"file": "Excel Sheet Column Number.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 198,
						"regions":
						{
						},
						"selection":
						[
							[
								198,
								198
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 10,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 51,
					"type": "text"
				},
				{
					"buffer": 63,
					"file": "Maximum Depth of Binary Tree.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 585,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 45,
					"type": "text"
				},
				{
					"buffer": 64,
					"file": "Intersection of Two Linked Lists.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1059,
						"regions":
						{
						},
						"selection":
						[
							[
								98,
								98
							]
						],
						"settings":
						{
							"auto_name": "/**",
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 87,
					"type": "text"
				},
				{
					"buffer": 65,
					"file": "Word Ladder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1369,
						"regions":
						{
						},
						"selection":
						[
							[
								1369,
								1369
							]
						],
						"settings":
						{
							"auto_name": "// http://www.programcreek.com/2012/12/leetcode-wo",
							"function_name_status_row": 46,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 93,
					"type": "text"
				},
				{
					"buffer": 66,
					"file": "/Users/Sean/Downloads/ac.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2059,
						"regions":
						{
						},
						"selection":
						[
							[
								1677,
								1677
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 66,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 49,
					"type": "text"
				},
				{
					"buffer": 67,
					"file": "Surrounded Regions.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3415,
						"regions":
						{
						},
						"selection":
						[
							[
								3415,
								3415
							]
						],
						"settings":
						{
							"auto_name": "//http://blog.csdn.net/ojshilu/article/details/226",
							"function_name_status_row": 102,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 20.0,
						"zoom_level": 1.0
					},
					"stack_index": 79,
					"type": "text"
				},
				{
					"buffer": 68,
					"file": "Jump Game.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 511,
						"regions":
						{
						},
						"selection":
						[
							[
								511,
								511
							]
						],
						"settings":
						{
							"auto_name": "// http://fisherlei.blogspot.com/2012/12/leetcode-",
							"function_name_status_row": 15,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 42,
					"type": "text"
				},
				{
					"buffer": 69,
					"file": "Permutations.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 833,
						"regions":
						{
						},
						"selection":
						[
							[
								407,
								407
							]
						],
						"settings":
						{
							"function_name_status_row": 15,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 81,
					"type": "text"
				},
				{
					"buffer": 70,
					"file": "Valid Sudoku.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 815,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 104,
					"type": "text"
				},
				{
					"buffer": 71,
					"file": "Combinations.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 627,
						"regions":
						{
						},
						"selection":
						[
							[
								26,
								624
							]
						],
						"settings":
						{
							"function_name_status_row": 3,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 20,
					"type": "text"
				},
				{
					"buffer": 72,
					"file": "Sort List.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3287,
						"regions":
						{
						},
						"selection":
						[
							[
								5,
								5
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 576.0,
						"zoom_level": 1.0
					},
					"stack_index": 64,
					"type": "text"
				},
				{
					"buffer": 73,
					"file": "Decode Ways.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1113,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 63,
					"type": "text"
				},
				{
					"buffer": 74,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 132,
						"regions":
						{
						},
						"selection":
						[
							[
								128,
								128
							]
						],
						"settings":
						{
							"auto_name": "struct TreeNode",
							"function_name_status_row": 5,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 106,
					"type": "text"
				},
				{
					"buffer": 75,
					"file": "Quicksort.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 750,
						"regions":
						{
						},
						"selection":
						[
							[
								490,
								490
							]
						],
						"settings":
						{
							"function_name_status_row": 31,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 111,
					"type": "text"
				},
				{
					"buffer": 76,
					"file": "Search Insert Position.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 500,
						"regions":
						{
						},
						"selection":
						[
							[
								500,
								500
							]
						],
						"settings":
						{
							"function_name_status_row": 19,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 112,
					"type": "text"
				},
				{
					"buffer": 77,
					"file": "Search in Rotated Sorted Array.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1173,
						"regions":
						{
						},
						"selection":
						[
							[
								189,
								189
							]
						],
						"settings":
						{
							"function_name_status_row": 9,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 77,
					"type": "text"
				},
				{
					"buffer": 78,
					"file": "Divide Two Integers.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1095,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 61,
					"type": "text"
				},
				{
					"buffer": 79,
					"file": "/Users/Sean/Sean/Interview/codility/NumberSolitaire.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 460,
						"regions":
						{
						},
						"selection":
						[
							[
								164,
								164
							]
						],
						"settings":
						{
							"auto_name": "#include <limits.h>",
							"function_name_status_row": 4,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 60,
					"type": "text"
				},
				{
					"buffer": 80,
					"file": "Median of Two Sorted Arrays.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1300,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 76,
					"type": "text"
				},
				{
					"buffer": 81,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 85,
						"regions":
						{
						},
						"selection":
						[
							[
								37,
								37
							]
						],
						"settings":
						{
							"auto_name": "0....  3",
							"function_name_status_row": 3,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 75,
					"type": "text"
				},
				{
					"buffer": 82,
					"file": "Longest Palindromic Substring.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1105,
						"regions":
						{
						},
						"selection":
						[
							[
								342,
								342
							]
						],
						"settings":
						{
							"function_name_status_row": 15,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 39,
					"type": "text"
				},
				{
					"buffer": 83,
					"file": "Search for a Range.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1879,
						"regions":
						{
						},
						"selection":
						[
							[
								1494,
								1494
							]
						],
						"settings":
						{
							"function_name_status_row": 64,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 75.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 74,
					"type": "text"
				},
				{
					"buffer": 84,
					"file": "Find Minimum in Rotated Sorted Array.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 651,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								651
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 73,
					"type": "text"
				},
				{
					"buffer": 85,
					"file": "Max Points on a Line.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1601,
						"regions":
						{
						},
						"selection":
						[
							[
								711,
								711
							]
						],
						"settings":
						{
							"function_name_status_row": 23,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 115,
					"type": "text"
				},
				{
					"buffer": 86,
					"file": "3Sum Closest.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1147,
						"regions":
						{
						},
						"selection":
						[
							[
								565,
								565
							]
						],
						"settings":
						{
							"function_name_status_row": 18,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 105,
					"type": "text"
				},
				{
					"buffer": 87,
					"file": "4Sum.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1927,
						"regions":
						{
						},
						"selection":
						[
							[
								1535,
								1535
							]
						],
						"settings":
						{
							"function_name_status_row": 38,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 7.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 109,
					"type": "text"
				},
				{
					"buffer": 88,
					"file": "Candy.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1435,
						"regions":
						{
						},
						"selection":
						[
							[
								1123,
								1123
							]
						],
						"settings":
						{
							"function_name_status_row": 40,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 349.0,
						"zoom_level": 1.0
					},
					"stack_index": 72,
					"type": "text"
				},
				{
					"buffer": 89,
					"file": "Binary Tree Level Order Traversal II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1072,
						"regions":
						{
						},
						"selection":
						[
							[
								435,
								435
							]
						],
						"settings":
						{
							"function_name_status_row": 19,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 198.0,
						"zoom_level": 1.0
					},
					"stack_index": 32,
					"type": "text"
				},
				{
					"buffer": 90,
					"file": "Binary Tree Maximum Path Sum.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1669,
						"regions":
						{
						},
						"selection":
						[
							[
								1292,
								1292
							]
						],
						"settings":
						{
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 118,
					"type": "text"
				},
				{
					"buffer": 91,
					"file": "Add Binary.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 732,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 85,
					"type": "text"
				},
				{
					"buffer": 92,
					"file": "Same Tree.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 578,
						"regions":
						{
						},
						"selection":
						[
							[
								578,
								578
							]
						],
						"settings":
						{
							"function_name_status_row": 26,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 43,
					"type": "text"
				},
				{
					"buffer": 93,
					"file": "Container With Most Water.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 608,
						"regions":
						{
						},
						"selection":
						[
							[
								288,
								288
							]
						],
						"settings":
						{
							"function_name_status_row": 10,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 22,
					"type": "text"
				},
				{
					"buffer": 94,
					"file": "Anagrams.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 980,
						"regions":
						{
						},
						"selection":
						[
							[
								475,
								475
							]
						],
						"settings":
						{
							"function_name_status_row": 14,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 62,
					"type": "text"
				},
				{
					"buffer": 95,
					"file": "Construct Binary Tree from Preorder and Inorder Traversal.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1471,
						"regions":
						{
						},
						"selection":
						[
							[
								711,
								711
							]
						],
						"settings":
						{
							"auto_name": "/**",
							"function_name_status_row": 25,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 96,
					"type": "text"
				},
				{
					"buffer": 96,
					"file": "3Sum.cpp",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 1498,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 103,
					"type": "text"
				},
				{
					"buffer": 97,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 151,
						"regions":
						{
						},
						"selection":
						[
							[
								138,
								138
							]
						],
						"settings":
						{
							"auto_name": "stack<int>",
							"function_name_status_row": 10,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 102,
					"type": "text"
				},
				{
					"buffer": 98,
					"file": "Pow(x, n).cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 392,
						"regions":
						{
						},
						"selection":
						[
							[
								210,
								210
							]
						],
						"settings":
						{
							"function_name_status_row": 10,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 101,
					"type": "text"
				},
				{
					"buffer": 99,
					"file": "Unique Binary Search Trees.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 508,
						"regions":
						{
						},
						"selection":
						[
							[
								233,
								233
							]
						],
						"settings":
						{
							"function_name_status_row": 12,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 38,
					"type": "text"
				},
				{
					"buffer": 100,
					"file": "Unique Binary Search Trees II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1091,
						"regions":
						{
						},
						"selection":
						[
							[
								544,
								544
							]
						],
						"settings":
						{
							"function_name_status_row": 26,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 37,
					"type": "text"
				},
				{
					"buffer": 101,
					"file": "Regular Expression Matching.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1598,
						"regions":
						{
						},
						"selection":
						[
							[
								443,
								443
							]
						],
						"settings":
						{
							"function_name_status_row": 22,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 35,
					"type": "text"
				},
				{
					"buffer": 102,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14,
						"regions":
						{
						},
						"selection":
						[
							[
								14,
								14
							]
						],
						"settings":
						{
							"auto_name": "middle initial",
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 34,
					"type": "text"
				},
				{
					"buffer": 103,
					"file": "Binary Tree Level Order Traversal.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 859,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 64.0,
						"zoom_level": 1.0
					},
					"stack_index": 33,
					"type": "text"
				},
				{
					"buffer": 104,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4,
						"regions":
						{
						},
						"selection":
						[
							[
								3,
								3
							]
						],
						"settings":
						{
							"auto_name": "a",
							"function_name_status_row": 1,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 36,
					"type": "text"
				},
				{
					"buffer": 105,
					"file": "Gas Station.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 938,
						"regions":
						{
						},
						"selection":
						[
							[
								649,
								649
							]
						],
						"settings":
						{
							"function_name_status_row": 15,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 29,
					"type": "text"
				},
				{
					"buffer": 106,
					"file": "Best Time to Buy and Sell Stock.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 404,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 28,
					"type": "text"
				},
				{
					"buffer": 107,
					"file": "Path Sum.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 552,
						"regions":
						{
						},
						"selection":
						[
							[
								414,
								414
							]
						],
						"settings":
						{
							"function_name_status_row": 18,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 82,
					"type": "text"
				},
				{
					"buffer": 108,
					"file": "Path Sum II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1037,
						"regions":
						{
						},
						"selection":
						[
							[
								423,
								423
							]
						],
						"settings":
						{
							"function_name_status_row": 17,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 44,
					"type": "text"
				},
				{
					"buffer": 109,
					"file": "Maximum Product Subarray.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 704,
						"regions":
						{
						},
						"selection":
						[
							[
								370,
								370
							]
						],
						"settings":
						{
							"auto_name": "//refer http://blog.csdn.net/worldwindjp/article/d",
							"function_name_status_row": 16,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 30,
					"type": "text"
				},
				{
					"buffer": 110,
					"file": "Longest Common Prefix.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 576,
						"regions":
						{
						},
						"selection":
						[
							[
								297,
								297
							]
						],
						"settings":
						{
							"function_name_status_row": 12,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 80,
					"type": "text"
				},
				{
					"buffer": 111,
					"file": "Set Matrix Zeroes Total.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1300,
						"regions":
						{
						},
						"selection":
						[
							[
								1300,
								1300
							]
						],
						"settings":
						{
							"auto_name": "//refer http://fisherlei.blogspot.com/2013/01/leet",
							"function_name_status_row": 47,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 99,
					"type": "text"
				},
				{
					"buffer": 112,
					"file": "Length of Last Word.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 440,
						"regions":
						{
						},
						"selection":
						[
							[
								440,
								440
							]
						],
						"settings":
						{
							"auto_name": "class Solution {",
							"function_name_status_row": 21,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 100,
					"type": "text"
				},
				{
					"buffer": 113,
					"file": "Binary Tree Inorder Traversal.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 607,
						"regions":
						{
						},
						"selection":
						[
							[
								296,
								296
							]
						],
						"settings":
						{
							"auto_name": "/**",
							"function_name_status_row": 13,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 23,
					"type": "text"
				},
				{
					"buffer": 114,
					"file": "Count and Say.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 814,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 98,
					"type": "text"
				},
				{
					"buffer": 115,
					"file": "Climbing Stairs.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 428,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 97,
					"type": "text"
				},
				{
					"buffer": 116,
					"file": "Best Time to Buy and Sell Stock II.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 419,
						"regions":
						{
						},
						"selection":
						[
							[
								390,
								390
							]
						],
						"settings":
						{
							"auto_name": "//refer http://blog.unieagle.net/2012/12/04/leetco",
							"function_name_status_row": 11,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 27,
					"type": "text"
				},
				{
					"buffer": 117,
					"file": "Valid Number.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1930,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"function_name_status_row": 0,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 108,
					"type": "text"
				},
				{
					"buffer": 118,
					"file": "Valid Palindrome.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 469,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 119,
					"type": "text"
				},
				{
					"buffer": 119,
					"file": "Subsets.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1595,
						"regions":
						{
						},
						"selection":
						[
							[
								244,
								244
							]
						],
						"settings":
						{
							"function_name_status_row": 9,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 31,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 27.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 124.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.sftp":
	{
		"height": 0.0
	},
	"project": "leetcode.sublime-project",
	"replace":
	{
		"height": 50.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"palid",
				"Leetcode/Palindrome Partitioning.cpp"
			],
			[
				"pald",
				"Leetcode/Palindrome Number.cpp"
			],
			[
				"pal",
				"Leetcode/Palindrome Partitioning.cpp"
			],
			[
				"re",
				"Leetcode/Reverse Integer.cpp"
			],
			[
				"long",
				"Leetcode/Longest Consecutive Sequence.cpp"
			],
			[
				"uniq",
				"Unique Paths II.cpp"
			],
			[
				"uin",
				"Unique Paths.cpp"
			],
			[
				"po",
				"Populating Next Right Pointers in Each Node II.cpp"
			],
			[
				"populat",
				"Populating Next Right Pointers in Each Node.cpp"
			],
			[
				"",
				"Unique Paths II.cpp"
			],
			[
				"u",
				"Unique Paths II.cpp"
			],
			[
				"fla",
				"Flatten Binary Tree to Linked List.cpp"
			],
			[
				"merge",
				"Merge k Sorted Lists.cpp"
			],
			[
				"palin",
				"Palindrome Partitioning.cpp"
			],
			[
				"co",
				"Combinations.cpp"
			],
			[
				"most",
				"Container With Most Water.cpp"
			],
			[
				"rain",
				"Trapping Rain Water.cpp"
			],
			[
				"inorder",
				"Binary Tree Inorder Traversal.cpp"
			],
			[
				"big",
				"Big Integer.cpp"
			],
			[
				"rever",
				"Reverse Words in a String.cpp"
			],
			[
				"pas",
				"Pascal's Triangle II.cpp"
			],
			[
				"stock",
				"Best Time to Buy and Sell Stock II.cpp"
			],
			[
				"stokc",
				"Best Time to Buy and Sell Stock.cpp"
			],
			[
				"gas",
				"Gas Station.cpp"
			],
			[
				"pro",
				"Maximum Product Subarray.cpp"
			],
			[
				"subse",
				"Subsets.cpp"
			],
			[
				"conse",
				"Longest Consecutive Sequence.cpp"
			],
			[
				"lev",
				"Binary Tree Level Order Traversal II.cpp"
			],
			[
				"regu",
				"Regular Expression Matching.cpp"
			],
			[
				"uni",
				"Unique Binary Search Trees II.cpp"
			],
			[
				"next",
				"Next Permutation.cpp"
			],
			[
				"sub",
				"Maximum Subarray.cpp"
			],
			[
				"prod",
				"Maximum Product Subarray.cpp"
			],
			[
				"max",
				"Maximum Subarray.cpp"
			],
			[
				"maxi",
				"Maximum Depth of Binary Tree.cpp"
			],
			[
				"ju",
				"Jump Game.cpp"
			],
			[
				"va",
				"Validate Binary Search Tree.cpp"
			],
			[
				"bes",
				"Best Time to Buy and Sell Stock.cpp"
			],
			[
				"best",
				"Best Time to Buy and Sell Stock.cpp"
			],
			[
				"div",
				"Divide Two Integers.cpp"
			],
			[
				"decode",
				"Decode Ways.cpp"
			],
			[
				"sort",
				"Sort List.cpp"
			],
			[
				"mer",
				"Merge Sorted Array.cpp"
			],
			[
				"conver",
				"Convert Sorted List to Binary Search Tree.cpp"
			],
			[
				"reverse",
				"Reverse Words in a String.cpp"
			],
			[
				"con",
				"Convert Sorted List to Binary Search Tree.cpp"
			],
			[
				"water",
				"Trapping Rain Water.cpp"
			],
			[
				"wa",
				"Trapping Rain Water.cpp"
			],
			[
				"valid",
				"Validate Binary Search Tree.cpp"
			],
			[
				"convr",
				"Convert Sorted List to Binary Search Tree.cpp"
			],
			[
				"sorted",
				"Convert Sorted Array to Binary Search Tree.cpp"
			],
			[
				"combi",
				"Combination Sum.cpp"
			],
			[
				"candy",
				"Candy.cpp"
			],
			[
				"longe",
				"Longest Palindromic Substring.cpp"
			],
			[
				"sera",
				"Search for a Range.cpp"
			],
			[
				"divi",
				"Divide Two Integers.cpp"
			],
			[
				"rotate",
				"Search in Rotated Sorted Array.cpp"
			],
			[
				"n",
				"N-Queens.cpp"
			],
			[
				"reor",
				"Reorder List.cpp"
			],
			[
				"surr",
				"Surrounded Regions.cpp"
			],
			[
				"com",
				"Combinations.cpp"
			],
			[
				"qu",
				"N-Queens.cpp"
			],
			[
				"common",
				"Longest Common Prefix.cpp"
			],
			[
				"perm",
				"Permutations.cpp"
			],
			[
				"flat",
				"Flatten Binary Tree to Linked List.cpp"
			],
			[
				"pat",
				"Path Sum.cpp"
			],
			[
				"path",
				"Path Sum II.cpp"
			],
			[
				"min",
				"Min Stack.cpp"
			],
			[
				"tree",
				"Same Tree.cpp"
			],
			[
				"addi",
				"Add Binary.cpp"
			],
			[
				"baln",
				"Balanced Binary Tree.cpp"
			],
			[
				"inters",
				"Intersection of Two Linked Lists.cpp"
			],
			[
				"subarr",
				"Maximum Product Subarray.cpp"
			],
			[
				"digit",
				"Generate N-digit number.cpp"
			],
			[
				"n-d",
				"Generate N-digit number.cpp"
			],
			[
				"searchinrotatedsortedarrayii",
				"Search in Rotated Sorted Array II.cpp"
			],
			[
				"longestsubstringwithoutrepeatingcharacters",
				"Longest Substring Without Repeating Characters.cpp"
			],
			[
				"climi",
				"Climbing Stairs.cpp"
			],
			[
				"cout",
				"Count and Say.cpp"
			],
			[
				"countand",
				"Count and Say.cpp"
			],
			[
				"train",
				"Triangle.cpp"
			],
			[
				"tri",
				"Triangle.cpp"
			],
			[
				"pow",
				"Pow(x, n).cpp"
			],
			[
				"permu",
				"Permutations.cpp"
			],
			[
				"fin",
				"Find Minimum in Rotated Sorted Array.cpp"
			],
			[
				"pa",
				"Palindrome Partitioning II.cpp"
			],
			[
				"pali",
				"Palindrome Partitioning.cpp"
			],
			[
				"post",
				"Binary Tree Postorder Traversal.cpp"
			],
			[
				"sud",
				"Valid Sudoku.cpp"
			],
			[
				"lru",
				"LRU Cache.cpp"
			],
			[
				"per",
				"Permutations.cpp"
			],
			[
				"swap",
				"Swap Nodes in Pairs.cpp"
			],
			[
				"sw",
				"Swap Nodes in Pairs.cpp"
			],
			[
				"inord",
				"Populating Next Right Pointers in Each Node.cpp"
			],
			[
				"bin",
				"Binary Tree Preorder Traversal.cpp"
			],
			[
				"4su",
				"4Sum.cpp"
			],
			[
				"q",
				"Quicksort.c"
			],
			[
				"anag",
				"Anagrams.cpp"
			],
			[
				"lo",
				"Longest Substring Without Repeating Characters.cpp"
			],
			[
				"cp",
				"Copy List with Random Pointer.cpp"
			],
			[
				"b",
				"Binary Tree Postorder Traversal.cpp"
			],
			[
				"bi",
				"Binary Tree Postorder Traversal.cpp"
			],
			[
				"subsets",
				"Subsets.cpp"
			],
			[
				"sing",
				"Single Number II.cpp"
			],
			[
				"sin",
				"Single Number.cpp"
			],
			[
				"fl",
				"Flatten Binary Tree to Linked List.cpp"
			],
			[
				"sq",
				"Sqrt(x).cpp"
			],
			[
				"trap",
				"Trapping Rain Water.cpp"
			],
			[
				"search",
				"Search a 2D Matrix.cpp"
			],
			[
				"maxp",
				"Max Points on a Line.cpp"
			],
			[
				"find",
				"Find Minimum in Rotated Sorted Array.cpp"
			],
			[
				"searchfor",
				"Search for a Range.cpp"
			],
			[
				"sear",
				"Search in Rotated Sorted Array II.cpp"
			],
			[
				"searchinrotatedsortedarray",
				"Search in Rotated Sorted Array.cpp"
			],
			[
				"fir",
				"First Missing Positive.cpp"
			],
			[
				"remo",
				"Remove Nth Node From End of List.cpp"
			],
			[
				"ro",
				"Rotate List.cpp"
			],
			[
				"merg",
				"MergeSort.c"
			],
			[
				"two",
				"Two Sum.cpp"
			],
			[
				"combin",
				"Combination Sum.cpp"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
			[
				"",
				"~/Sean/leetcode.sublime-workspace"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 392.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 208.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
