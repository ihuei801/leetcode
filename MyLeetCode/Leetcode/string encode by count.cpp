#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <climits>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;

class EncodedBundle {
public:

    string _encodedData;
    void * _additionalData;

    EncodedBundle(string encodedData, void * additionalData)
    : _encodedData(encodedData), _additionalData(additionalData)
    {
    }


};

/**
 * Given an input string, encodes a
 * compressed representation using the following method:
 *
 * 1. Counts the frequency of each character in the string.
 * 2. Assigns an output encoding to each input character.
 *    All output encodings are made up of '0' and '1' characters.
 *    The most common input character should be encoded as "1".
 *    The second most common should be encoded as "01".
 *    The third most common should be encoded as "001".
 *    The n-th most common should be n '0's followed by a single '1'.
 *    (If multiple characters occur equally frequently, you may choose an arbitrary order).
 * 3. For each character in the input string,
 *    the output string should consist of each encoding concatenated together.
 *
 * ------
 *
 * As an example, for the input string "bJbb++b":
 *  1.  'b' occurs 4 times.
 *      '+' occurs 2 times.
 *      'J' occurs 1 times.
 *  2. Thus, the following encodings are assigned:
 *      'b' -> "1"
 *      '+' -> "01"
 *      'J' -> "001"
 *  3. By concatenating the encodings together, we get:
 *       "1 001 1 1 01 01 1"
 *       Spaces are added for readability, but the actual output
 *       should just be "10011101011".
 */
EncodedBundle * encode(string & input) {
    // TODO: encode input using the method described above
    // and return it as the 'encodedData' parameter below.

    // The 'additionalData' parameter should be used to pass the
    // encoding schema to the decode function.
    map<char, int>count_table;
    multimap<int, char> sorted_table;
    map<char, string>encode_table;
    map<string, char> *decode_table = new map<string, char>;
    string zero_str;
    string encode_str;

    size_t len = input.size();

    for (int i = 0; i < len; i++)
    {
        char c = input[i];
        if (count_table.count(c) > 0)
            count_table[c]++;
        else
            count_table[c] = 1;
    }

    for(map<char, int>::const_iterator it = count_table.begin(); it != count_table.end(); ++it)
        sorted_table.insert(pair<int, char>(it->second, it->first));

    for(multimap<int, char>::const_reverse_iterator it = sorted_table.rbegin(); it != sorted_table.rend(); ++it)
    {
        encode_table[it->second] = zero_str + "1";
        decode_table->operator[](zero_str + "1") = it->second;
        zero_str += "0";
    }

    for (int i = 0; i < len; i++)
        encode_str += encode_table[input[i]];

    return new EncodedBundle(encode_str, decode_table);
}

/**
 * Given an {@link EncodedBundle} generated by {@link encode()},
 * returns the String used to produce it.
 */
string decode(EncodedBundle * bundle) {
    // TODO: Use the data in EncodedBundle to reconstruct the original string.
    string decode_str;
    map<string, char> *decode_table = (map<string, char> *)bundle->_additionalData;
    size_t len = bundle->_encodedData.size();
    string encode_str = bundle->_encodedData;
    string str;

    for (int i = 0; i < len; i++)
    {
        str += encode_str[i];
        if (encode_str[i] == '1')
        {
            decode_str += decode_table->operator[](str);
            str = "";
        }
    }

    delete bundle;
    return decode_str;
}


int main() {
    //ofstream fout(getenv("OUTPUT_PATH"));

    string _input;
    cin >> _input;

    EncodedBundle * bundle = encode(_input);
    cout << "Encoded: \"" << bundle->_encodedData << "\"" << endl;

    string decoded = decode(bundle);
    cout << "Decoded: \"" << decoded << "\"" << endl;


    return 0;
}
